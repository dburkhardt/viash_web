var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/docs/projects/namespaces/",title:"Namespaces",description:"",content:'\u003cp\u003eOnce you start to develop a number of Viash components, you may want to\ngroup them together for improved maintenance and a separation of\nconcerns. In addition, multiple developers could work on different sets\nof components in parallel and later bring them together in a larger\nproject.\u003c/p\u003e\n\u003cp\u003eWe call a group of components a \u003cstrong\u003enamespace\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="building-a-namespace"\u003eBuilding a namespace\u003c/h3\u003e\n\u003cp\u003eYou can assign a component to a namespace by defining its namespace\nattribute in the \u003ca href="/docs/reference_config/config"\u003eviash config file\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: some_component\n  namespace: my_namespace\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively, the namespace can be automatically inferred by\nstructuring the components hierarchically. In the example below, there\nare two namespaces: \u003cstrong\u003efile_processing\u003c/strong\u003e and \u003cstrong\u003enetwork_tools\u003c/strong\u003e. Each of\nthese namespaces has one or more components assigned to them:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003esrc\n├── file_processing\n│   ├── parse_images\n│   │   ├── config.vsh.yaml\n│   │   └── script.sh\n│   └── render_mp4\n│       ├── config.vsh.yaml\n│       └── script.sh\n└── network_tools\n    └── download_files\n        ├── config.vsh.yaml\n        ├── output\n        │   └── download_files\n        └── script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo build a namespace to a set of executables, use the \u003ca href="/docs/reference_commands/ns-build"\u003eviash ns build\ncommand\u003c/a\u003e.\u003c/p\u003e\n'},{id:1,href:"/docs/advanced/config_mods/",title:"Dynamic Config Modding",description:"The config can be dynamically altered from the command line to change the component's behaviour during the build-stage.",content:"\u003cp\u003eSince version 0.4.0, Viash supports modifying a \u003ca href=\"/docs/reference_config/config/\"\u003eviash\nconfig\u003c/a\u003e YAML at runtime using a custom\nDSL. This allows making dynamic changes to your components or projects.\nAll Viash subcommands have support for the DSL through the\n\u003ccode\u003e-c|--config_mod\u003c/code\u003e parameter.\u003c/p\u003e\n\u003cp\u003eThe easiest way to explain is perhaps by showing some examples. The\nfollowing statements are all valid under the DSL definition.\u003c/p\u003e\n\u003cp\u003eChanging the version of a component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.functionality.version := \u0026quot;0.3.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eChanging the registry of docker containers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdding an author to the list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.functionality.authors += { name: \u0026quot;Mr. T\u0026quot;, role: \u0026quot;sponsor\u0026quot; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese commands come in really handy when building a lot of components,\nfor example using the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eviash ns build \\\n  -c '.functionality.version := \u0026quot;0.3.0\u0026quot;' \\\n  -c '.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;' \\\n  -c '.functionality.authors += { name: \u0026quot;Mr. T\u0026quot;, role: \u0026quot;sponsor\u0026quot; }'\n\u003c/code\u003e\u003c/pre\u003e\n"},{id:2,href:"/docs/getting_started/introduction/",title:"Introduction",description:"Viash helps you turn a script (Bash/R/Python/Scala/JavaScript) into a reusable component.",content:'\u003c!-- TODO: What is Viash if you would describe it in one or two sentences?\nViash is a ... --\u003e\n\u003cp\u003eBy providing some meta-data regarding its functionality and the platform\non which you want to run the software, Viash can help you:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWrap your script in an executable with a CLI and \u003ccode\u003e--help\u003c/code\u003e\nfunctionality.\u003c/li\u003e\n\u003cli\u003eSeamlessly execute your component natively on the host platform or\nin a \u003cstrong\u003eDocker\u003c/strong\u003e container.\u003c/li\u003e\n\u003cli\u003eCombine multiple components in a \u003cstrong\u003eNextflow\u003c/strong\u003e pipeline.\u003c/li\u003e\n\u003cli\u003eUnit-test your component to ensure that it works at all times.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="example-use-cases"\u003eExample use cases\u003c/h2\u003e\n\u003cp\u003eHere are a few use cases which serve as motivation for Viash:\u003c/p\u003e\n\u003c!-- TODO: Rewrite use cases, the reason why Viash helps in those situations should be crystal clear to someone that has never seen Viash before, this part of the docs is presented before the installation after all. Ideally each of these should have "Viash can help here by../In this case, Viash can.../etc." --\u003e\n\u003cul\u003e\n\u003cli\u003eYou want to combine several tools in a pipeline and every tool has\nspecific requirements on how they should be run. Even worse: some\nrequirements might directly conflict with each other.\u003c/li\u003e\n\u003cli\u003eYour next data analysis project is very similar to the previous\nproject, so you copy and paste the source code. Unfortunately, you\ndetect a bug in some of your code, so now you need to go back and\nfix the same bug in all the different projects.\u003c/li\u003e\n\u003cli\u003eYou want to look back at a data analysis you performed two years\nago. Unfortunately, the software you used back then is not supported\nanymore, or the newest version produces totally different results.\nWith Viash you can package the older version together with its\ndependencies in an executable so you don’t have to worry about\nconflicts or deprecated versions\u003c/li\u003e\n\u003cli\u003eYou developed a \u003ca href="https://jupyter.org/"\u003eJupyter\u003c/a\u003e notebook report for\na data analysis. You wish to share it with your colleague, only to\nspend two hours installing your \u003ca href="https://docs.conda.io/"\u003eConda\u003c/a\u003e\nstack on their laptop.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="getting-started"\u003eGetting started\u003c/h2\u003e\n\u003cp\u003eHere are some links to get you started with Viash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/getting_started/installation"\u003eInstalling Viash\u003c/a\u003e: This guide\nwalks you through the steps to install Viash on your machine.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/getting_started/what_is_a_viash_component"\u003eRunning your first\ncomponent\u003c/a\u003e: Get a\nfeel for Viash with a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="documentation"\u003eDocumentation\u003c/h2\u003e\n\u003cp\u003eOnce you understand how Viash works and what it could do for you, take a\nlook at our docs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_commands/run/"\u003eviash run command\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config/"\u003eConfig files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/help/frequently_asked_questions/"\u003eFrequently asked questions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCheck out the navigation menu on the left for more in-depth information\nabout each topic.\u003c/p\u003e\n'},{id:3,href:"/docs/getting_started/installation/",title:"Installation",description:"Installation requirements and instructions.",content:'\u003ch2 id="supported-operating-systems"\u003eSupported Operating Systems\u003c/h2\u003e\n\u003cp\u003eYou can run Viash on the following operating systems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003emacOS\u003c/li\u003e\n\u003cli\u003eWindows using \u003ca href="https://docs.microsoft.com/en-us/windows/wsl/install-win10"\u003eWindows Subsystem for\nLinux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eViash is developed in \u003ca href="https://www.scala-lang.org/"\u003eScala 2.12\u003c/a\u003e, so\nyou’ll need an \u003ca href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html"\u003eOracle Java SE Runtime Environment 8\ninstallation\u003c/a\u003e\nor OpenJDK in order to use it.\u003c/li\u003e\n\u003cli\u003eYou will need \u003ca href="https://docs.docker.com/get-docker/"\u003eDocker\u003c/a\u003e to\ninstall Viash and use it to its full potential.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="installing-viash"\u003eInstalling Viash\u003c/h2\u003e\n\u003cp\u003eTo install Viash to a \u003cstrong\u003ebin\u003c/strong\u003e folder in your current directory, run the\nfollowing command to download and run the bootstrap tool:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ewget -qO- get.viash.io | bash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ebin/viash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="installation-options"\u003eInstallation options\u003c/h3\u003e\n\u003cp\u003eAdditional options can be set immediately using the following syntax:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ewget -qO- get.viash.io | bash -s -- OPTIONS\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor example, this command installs a release candidate of Viash in a\ndirectory named ‘applications’:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ewget -qO- get.viash.io | bash -s -- -bin applications -tag 0.5.0-rc3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUse \u003ccode\u003e--help\u003c/code\u003e to get more information on the various parameters. Here’s\nthe full list of options:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ewget -qO- get.viash.io | bash -s -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eviash_bootstrap 0.1\nBootstrap or update a viash project\'s CI/CD artefacts\n\nOptions:\n    --bin\n        type: file, output\n        default: bin\n        Target dir for viash scripts and tools\n\n    -r, --registry\n        type: string\n        default: \n        Docker registry to use, only used when using a registry.\n\n    --namespace_separator\n        type: string\n        default: _\n        The separator to use between the component name and namespace as the image name of a Docker container.\n\n    -c, --config_mod\n        type: string, multiple values allowed\n        Modify a viash config at runtime using a custom DSL. For more information, see the online documentation.\n\n    -t, --tag\n        type: string\n        Which tag/version of viash to use, leave blank for the latest release\n\n    --viash\n        type: file\n        A path to the viash executable. If not specified, this component will look for \'viash\' on the $PATH.\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:4,href:"/docs/getting_started/what_is_a_viash_component/",title:"What is a Viash Component?",description:"We have provided a simple Hello World component as an introduction to Viash. Follow the steps below to learn how to run a component and get a result back from it.",content:'\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/getting_started/installation"\u003einstallation of Viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, Viash parses the\n\u003ca href="https://viash.io/examples/hello_world/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: bash_script\n    path: script.sh\n  tests:\n  - type: bash_script\n    path: test.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world/script.sh"\u003e\u003ccode\u003escript.sh\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small Bash script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e## VIASH START\npar_input=\u0026quot;I am debug!\u0026quot;\npar_greeter=\u0026quot;Hello world!\u0026quot;\n## VIASH END\n\necho $par_greeter $par_input\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nand adding the \u003ccode\u003epar_\u003c/code\u003e prefix, their values will automatically be\nreplaced at runtime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. The component creating tutorials on the\nleft include an example.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/docs/reference_config/platform-native/"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as Viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have Viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make Viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how Viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:5,href:"/docs/creating_components/bash/",title:"Creating a Bash Component",description:"Developing a new Viash component.",content:'\u003cp\u003eIn this tutorial, you’ll create a component that does the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtract all hyperlinks from a markdown file\u003c/li\u003e\n\u003cli\u003eCheck if every URL is reachable\u003c/li\u003e\n\u003cli\u003eCreate a text report with the results\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe component will be able to run locally and as a docker container. In\norder to create a component you need two files: a script for the\nfunctionality and a config file that describes the component.\u003c/p\u003e\n\u003cp\u003eThe files used in this tutorial can be found here:\u003c/p\u003e\n\u003cp\u003e\u003ca href="https://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker"\u003ehttps://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/getting_started/installation"\u003einstallation of Viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://www.docker.com/"\u003eDocker\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://curl.se/"\u003ecURL\u003c/a\u003e. Install this via your\npackage manager if you don’t have it installed yet.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe recommend you take a look at the \u003ca href="/docs/getting_started/what_is_a_viash_component"\u003ehello world\nexample\u003c/a\u003e first to\nunderstand how components work.\u003c/p\u003e\n\u003ch2 id="write-a-script-in-bash"\u003eWrite a script in bash\u003c/h2\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case a bash script.\u003cbr\u003e\nCreate a new folder named \u003cstrong\u003emy_viash_component\u003c/strong\u003e and open it. Now\ncreate a new file named \u003cstrong\u003escript.sh\u003c/strong\u003e in there and add this code as its\ncontent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/usr/bin/env bash\n\n### 1 ###\n\n## VIASH START\n\npar_inputfile=\u0026quot;Testfile.md\u0026quot;\npar_domain=\u0026quot;https://viash.io\u0026quot;\npar_output=\u0026quot;output.txt\u0026quot;\n\n## VIASH END\n\namount_of_errors=0\n\necho \u0026quot;Extracting URLs\u0026quot;\n\n### 2 ###\n\n# Extract the titles and URLs from the markdown file with sed and put them into arrays\nreadarray -t title_array \u0026lt;\u0026lt;\u0026lt;$(sed -rn \'s@^.*\\[(.*)\\]\\((.*)\\).*$@\\1@p\' $par_inputfile)\nreadarray -t url_array \u0026lt;\u0026lt;\u0026lt;$(sed -rn \'s@^.*\\[(.*)\\]\\((.*)\\).*$@\\2@p\' $par_inputfile)\n\n# Get length of array\namount_of_urls=$(echo \u0026quot;${#url_array[@]}\u0026quot;)\n\necho \u0026quot;Checking $amount_of_urls URLs\u0026quot;\n\n# Clear file\n\u0026gt;$par_output\n\n### 3 ###\n\n# Iterate over the array of titles and check each URL\nfor ((n = 0; n \u0026lt; ${#title_array[*]}; n++)); do\n    title=\u0026quot;${title_array[n]}\u0026quot;\n    url=\u0026quot;${url_array[n]}\u0026quot;\n\n    ### 4 ###\n\n    # If an URL doesn\'t start with \'http\', add the domain before it\n    if [[ $url != http* ]]; then\n        url=\u0026quot;$par_domain${url_array[n]}\u0026quot;\n    fi\n\n    echo \u0026quot;$(($n + 1)): $url\u0026quot;\n\n    echo -e \u0026quot;Link name: $title\u0026quot; \u0026gt;\u0026gt;$par_output\n    echo -e \u0026quot;URL: $url\u0026quot; \u0026gt;\u0026gt;$par_output\n\n    ### 5 ###\n\n    # Do a cURL and get the status code from the last response after following any redirects\n    status_code=$(curl -ILs --max-redirs 5 $url | tac | grep -m1 HTTP)\n    expected_code=\u0026quot;200\u0026quot;\n\n    # Check if status code obtained via cURL contains the expected code\n    if [[ $status_code == *$expected_code* ]]; then\n        echo \u0026quot;OK\u0026quot;\n        echo -e \u0026quot;Status: OK, can be reached.\u0026quot; \u0026gt;\u0026gt;$par_output\n    else\n        echo $status_code\n        echo -e \u0026quot;Status: ERROR! URL cannot be reached. Status code: $status_code\u0026quot; \u0026gt;\u0026gt;$par_output\n        amount_of_errors=$(($amount_of_errors + 1))\n    fi\n\n    echo -e \u0026quot;---\u0026quot; \u0026gt;\u0026gt;$par_output\ndone\n\necho \u0026quot;\u0026quot;\necho \u0026quot;$par_inputfile has been checked and a report named $par_output has been generated.\n$amount_of_errors of $amount_of_urls URLs could not be resolved.\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the numbered comments scattered about looking like \u003ccode\u003e### x ###\u003c/code\u003e,\nhere’s a breakdown of the code:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe variables are placed between \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e\nfor debugging purposes, their final values will be dynamically\ngenerated by Viash once the script is turned into a component. If\nyou want to skip the testing of your script, you can leave these out\nand Viash will create variables based on the configuration file.\nThere are three variables:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epar_inputfile\u003c/code\u003e: The markdown file that needs to be parsed.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_domain\u003c/code\u003e: The domain URL that gets inserted before any\nrelative URLs. For example, “/documentation/intro” could be\nreplaced with “\u003ca href="https://my-website/documentation/intro"\u003ehttps://my-website/documentation/intro\u003c/a\u003e” to\ncreate a valid URL.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_output\u003c/code\u003e: The path of the output text file that will contain\nthe report.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe script parses the markdown file and extracts the hyperlink\ntitles and URLs using some nifty\n\u003ca href="https://www.gnu.org/software/sed/manual/sed.html"\u003esed\u003c/a\u003e regex. It\nthen puts those strings into two arrays for later use.\u003c/li\u003e\n\u003cli\u003eStart a for-loop to iterate the title array.\u003c/li\u003e\n\u003cli\u003eAny relative URLs (or those that don’t start with “http” at least)\nwill get the domain added before it.\u003c/li\u003e\n\u003cli\u003ecURL is used to check for a response from the URL. The resulting\nstatus code is stored and compared to the expected code. The results\nget written to the terminal and the report.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id="test-the-script"\u003eTest the script\u003c/h2\u003e\n\u003cp\u003eBefore turning the script into a component, it’s a good idea to test if\nit actually works as expected.\u003cbr\u003e\nAs the script expects a markdown file with hyperlinks, create a new file\nin the script folder named \u003cstrong\u003eTestfile.md\u003c/strong\u003e and paste in the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-markdown"\u003e# Test File\n\nThis is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.\nSome links to websites:\n\n- [Google](https://www.google.com)\n- [Reddit](https://www.reddit.com)\n- [A broken link](http://microsoft.com/random-link)\n\nLinks that are relative to [viash.io](http://www.viash.io):\n\n- You can [install viash here](/docs/getting_started/installation).\n- It all starts with a script and a [config file](/docs/reference_config/config) for your components.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow open a terminal in the folder and execute the following command to\nmake your script executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003echmod +x ./script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, run the script by executing this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe script will now show the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExtracting URLs\nChecking 6 URLs\n1: https://www.google.com\nOK\n2: https://www.reddit.com\nOK\n3: http://microsoft.com/random-link\nHTTP/2 404 \n4: http://www.viash.io\nOK\n5: https://viash.io/docs/getting_started/installation\nHTTP/2 404 \n6: https://viash.io/docs/reference_config/config\nOK\n\nTestfile.md has been checked and a report named output.txt has been generated.\n2 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you get this same output, that means the script is working as\nintended! Feel free to take a peek at the generated \u003cstrong\u003eoutput.txt\u003c/strong\u003e file\nas well. You might have noticed you didn’t have to provide any\narguments, that’s because the values are hard-coded into the script for\ndebugging purposes.\u003c/p\u003e\n\u003cp\u003eNow the script has been tested, it’s time to create a config file to\ndescribe the component based on it.\u003c/p\u003e\n\u003ch2 id="describe-the-component-using-yaml"\u003eDescribe the component using YAML\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eViash config file\u003c/strong\u003e is a \u003ca href="https://yaml.org/"\u003eYAML\u003c/a\u003e file that\ndescribes the behavior and supported platforms of a Viash component.\nCreate new file named \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e and paste the following\ntemplate inside of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: NAME\n  description: DESCRIPTION\n  arguments:                     \n  - type: string\n    name: --input\n    description: INPUT DESCRIPTION\n  resources:\n  - type: LANGUAGE_script\n    path: SCRIPT\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery config file requires these two dictionaries:\n\u003ca href="/docs/getting_started/what_is_a_viash_component/#functionality"\u003efunctionality\u003c/a\u003e\nand\n\u003ca href="/docs/getting_started/what_is_a_viash_component/#platforms"\u003eplatforms\u003c/a\u003e.\nThis bare-bones config file makes it easy to “fill in the blanks” for\nthis example. For more information about config files, you can take a\nlook at the \u003cstrong\u003eReference: Config\u003c/strong\u003e section on the left.\u003c/p\u003e\n\u003cp\u003eLet’s start off by defining the functionality of our component.\u003c/p\u003e\n\u003ch3 id="defining-the-functionality"\u003eDefining the functionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e dictionary describes what the component does and\nthe resources it needs to do so. The first key is \u003cstrong\u003ename\u003c/strong\u003e, this will be\nthe name of the component once it’s built. Replace the \u003cstrong\u003eNAME\u003c/strong\u003e value\nwith \u003cstrong\u003emd_url_checker\u003c/strong\u003e or any other name of your choosing.\u003c/p\u003e\n\u003cp\u003eNext up is the \u003cstrong\u003edescription\u003c/strong\u003e key, its value will be printed out at the\ntop when the \u003cstrong\u003e–help\u003c/strong\u003e command is called. Replace \u003cstrong\u003eDESCRIPTION\u003c/strong\u003e with\n“\u003cstrong\u003eCheck if URLs in a markdown are reachable and create a text report\nwith the results.\u003c/strong\u003e”. You can use multiple lines for a description by\nstarting its value with a pipe (|) and a new line, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: md_url_checker\n  description: |\n    This is the first line of my description.\n    Here\'s a second line!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003cstrong\u003earguments\u003c/strong\u003e dictionary contains all of the arguments that are\naccepted by the component. These arguments will be injected as variables\nin the script. In the case of the example script, this are the variables\nwe’re working with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epar_inputfile\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_domain\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_output\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create good arguments, you need to ask yourself a few essential\nquestions about each variable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat is the most fitting \u003ca href="/docs/reference_config/functionality/#arguments-list"\u003edata\ntype\u003c/a\u003e?\u003c/li\u003e\n\u003cli\u003eIs it an input or an output?\u003c/li\u003e\n\u003cli\u003eIs it required?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s take a closer look at \u003ccode\u003epar_inputfile\u003c/code\u003e for starters:\u003c/p\u003e\n\u003cp\u003eWe know it’s a file, as the script needs the path to a markdown \u003cstrong\u003efile\u003c/strong\u003e\nas its \u003cstrong\u003einput\u003c/strong\u003e. It’s also definitely a \u003cstrong\u003erequired\u003c/strong\u003e variable, as the\nscript would be pointless without it.\u003cbr\u003e\nWith this in mind, modify the first argument as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChange \u003cstrong\u003etype\u003c/strong\u003e’s value to \u003cstrong\u003efile\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eSet \u003cstrong\u003ename\u003c/strong\u003e’s value to \u003cstrong\u003e–inputfile\u003c/strong\u003e. The name of an argument has\nto match the variable name as the argument will be injected into the\nfinal script. In the case of \u003cstrong\u003ebash\u003c/strong\u003e scripts, the variable name\ngets a \u003cstrong\u003e‘par_’\u003c/strong\u003e prefix add to it. This is the reason why the\nscript variables all start with \u003cstrong\u003e‘par_’\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eUse “\u003cstrong\u003eThe input markdown file.\u003c/strong\u003e” for the \u003cstrong\u003edescription\u003c/strong\u003e value.\nThis description will be included when the \u003cstrong\u003e–help\u003c/strong\u003e option is\ncalled.\u003c/li\u003e\n\u003cli\u003eAdd a new key named \u003cstrong\u003erequired\u003c/strong\u003e and set its value to \u003cstrong\u003etrue\u003c/strong\u003e. This\nensures that the component will not be run without a value for this\nargument.\u003c/li\u003e\n\u003cli\u003eAdd another key, name it \u003cstrong\u003emust_exist\u003c/strong\u003e and set its value to\n\u003cstrong\u003etrue\u003c/strong\u003e. This key is unique to \u003cstrong\u003efile\u003c/strong\u003e type arguments, it adds\nextra logic to the component to check if a file exists before\nrunning the component. This saves you from having to do this check\nyourself in the script.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat’s it for the first argument! The result should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow for \u003ccode\u003epar_domain\u003c/code\u003e, this is a simple \u003cstrong\u003eoptional string\u003c/strong\u003e that gets\nadded before relative URLs. Make room for a new argument by creating a\nnew line below \u003ccode\u003emust_exist: true\u003c/code\u003e and press \u003cstrong\u003eShift + Tab\u003c/strong\u003e to back up\none tab so the cursor is aligned with the start of the first argument.\nAdd the \u003ccode\u003e--domain\u003c/code\u003e argument here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument isn’t required, you can simply omit the \u003cstrong\u003erequired\u003c/strong\u003e key.\nAgain, the variable name in the script will get the **’_par’**\nprefix added automatically in bash scripts. Here’s what the arguments\ndictionary look like up until now:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  arguments:                     \n  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe final variable to create an argument for is \u003ccode\u003epar_output\u003c/code\u003e. This is\nanother \u003cstrong\u003efile\u003c/strong\u003e and clearly an \u003cstrong\u003eoutput\u003c/strong\u003e. Its value \u003cstrong\u003eisn’t required\u003c/strong\u003e\nas we can use a \u003cstrong\u003edefault\u003c/strong\u003e path if no explicit value is given.\u003cbr\u003e\nAdd yet another new argument with the following keys and values:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a \u003cstrong\u003etype\u003c/strong\u003e key and set \u003cstrong\u003efile\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eThe next key is \u003cstrong\u003ename\u003c/strong\u003e, use \u003cstrong\u003e–output\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eFor the \u003cstrong\u003edescription\u003c/strong\u003e, use “\u003cstrong\u003eThe path of the output text file\nthat will contain the report.\u003c/strong\u003e”.\u003c/li\u003e\n\u003cli\u003eAdd a new key and name it \u003cstrong\u003edefault\u003c/strong\u003e. This will act as the default\nvalue when not specified by the user of the component. Set its value\nto \u003cstrong\u003e“output.txt”\u003c/strong\u003e, including the quotation marks.\u003c/li\u003e\n\u003cli\u003eFinally, add the \u003cstrong\u003edirection\u003c/strong\u003e key and set its value to \u003cstrong\u003eoutput\u003c/strong\u003e.\nThis specifies the direction of an argument as either \u003cstrong\u003einput\u003c/strong\u003e or\n\u003cstrong\u003eoutput\u003c/strong\u003e, with input being the default. Specifying that an\nargument is an output is important so the component can correctly\nhandle the writing of files and the passing of values in a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe finished argument should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file                           \n    name: --output\n    description: The path of the output text file that will contain the report.\n    default: \u0026quot;output.txt\u0026quot;\n    direction: output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith that, there’s just one more part of the functionality to fill in:\nthe script itself!\u003cbr\u003e\nEvery Viash component has one or more resources, the most important of\nwhich is often the script. The template already contains a \u003cstrong\u003eresources\u003c/strong\u003e\ndictionary, so replace the following values to point to the script:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSet the value of \u003cstrong\u003etype\u003c/strong\u003e to \u003cstrong\u003ebash_script\u003c/strong\u003e. The script used in\nthis case was written in \u003cstrong\u003ebash\u003c/strong\u003e, so the resource type is set\naccordingly so Viash knows what flavor of code to generate to create\nthe final component. You can find a full overview of the different\nresource types on the \u003ca href="/docs/reference_config/functionality/#resources-list"\u003eFunctionality\npage\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eChange the value of \u003cstrong\u003epath\u003c/strong\u003e to \u003cstrong\u003escript.sh\u003c/strong\u003e. This points to the\nresource and can be a relative path, an absolute path or even a URL.\nIn this case we keep the script in the same directory as the config\nfile to keep things simple.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat finishes up the functionality side of the component! All that’s\nleft is defining the platforms with their dependencies and then running\nand building the component.\u003c/p\u003e\n\u003ch3 id="defining-the-platforms"\u003eDefining the platforms\u003c/h3\u003e\n\u003cp\u003eThe platforms dictionary specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform is assumed. Here’s a quick overview of\nthe platforms:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003enative\u003c/strong\u003e: The platform for developers that know what they’re doing\nor for simple components without any dependencies. All dependencies\nneed to be installed on the system the component is run on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edocker\u003c/strong\u003e: This platform is recommended for most components. The\ndependencies are resolved by using \u003ca href="https://www.docker.com/"\u003edocker\u003c/a\u003e\ncontainers, either from scratch or by pulling one from a docker\nrepository. This has huge benefits as the end user doesn’t need to\nhave any of the dependencies installed locally.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enextflow\u003c/strong\u003e: This converts the component into a\n\u003ca href="https://www.nextflow.io/"\u003eNextFlow\u003c/a\u003e module that can be imported\ninto a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn this tutorial, we’ll take a look at both the native and docker\nplatforms. The platforms are also defined in the \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e\nfile at the very bottom. The native platform is actually already defined\nin the template, that one \u003cstrong\u003etype\u003c/strong\u003e key with a value of \u003cstrong\u003enative\u003c/strong\u003e is\nenough! Now for adding the docker platform, add a new line below the\nlast and add the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: docker\n    image: bash:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells Viash that this component can be built to a docker container\nwith the \u003ca href="https://hub.docker.com/_/bash"\u003elatest bash image\u003c/a\u003e as its base.\nIf your script doesn’t depend on any packages, this would be all you’d\nhave to add when using a bash script. The script in our example however\nneeds \u003cstrong\u003ecurl\u003c/strong\u003e installed to work. Luckily, this isn’t a problem since\nViash \u003ca href="/docs/reference_config/platform-docker/#example"\u003esupports defining\ndependencies\u003c/a\u003e which\nthen get pulled from inside the docker container before running the\nscript. To add curl as a dependency that needs to be installed, add\nthese lines below \u003ccode\u003eimage: bash:latest\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e    setup:\n      - type: apk\n        packages: [ curl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will prompt the\n\u003ca href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management"\u003eapk\u003c/a\u003e\npackage manager to download and install curl inside of the container.\nThat’s it for the config! Be sure to save it and let’s move on to\nactually running the component you’ve created. For reference, you can\ntake a look at the completed \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file in \u003ca href="https://github.com/viash-io/viash_web/blob/main/static/examples/md_url_checker/config.vsh.yaml"\u003eour Github\nrepository\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="run-the-component"\u003eRun the component\u003c/h2\u003e\n\u003cp\u003eTime to run the component! First off, let’s see what the output of\n\u003ccode\u003e--help\u003c/code\u003e is. To do that, open a terminal in the \u003cstrong\u003emy_viash_component\u003c/strong\u003e\nfolder and execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will show the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCheck if URLs in a markdown are reachable and create a text report with the results.\n\nOptions:\n    --inputfile=file\n        type: file, required parameter\n        The input markdown file.\n\n    --domain=string\n        type: string\n        The domain URL that gets inserted before any relative URLs. For example, /documentation/intro could be replaced with https://my-website/documentation/intro to create a valid URL.\n\n    --output=file\n        type: file, default: output.txt\n        The path of the output text file that will contain the report.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the values you entered into the config file are all\nhere.\u003cbr\u003e\nNext, let’s run the component natively with some arguments. You can use\none of your own markdown files as the input if you desire. In that case,\nreplace \u003cstrong\u003eTestfile.md\u003c/strong\u003e in the command with the path to your file.\u003cbr\u003e\nExecute the following command to run the component with the default\nplatform, in this case \u003cstrong\u003enative\u003c/strong\u003e as it’s the first in the \u003cstrong\u003eplatforms\u003c/strong\u003e\ndictionary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all goes well, you’ll see something like this output in the terminal\nand a file named \u003cstrong\u003emy_report.txt\u003c/strong\u003e will have appeared:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExtracting URLs\nChecking 6 URLs\n1: https://www.google.com\nOK\n2: https://www.reddit.com\nOK\n3: http://microsoft.com/random-link\nHTTP/2 404 \n4: http://www.viash.io\nOK\n5: https://viash.io//docs/getting_started/installation\nHTTP/2 404 \n6: https://viash.io//docs/reference_config/config\nOK\n\nTestfile.md has been checked and a report named my_report.txt has been generated.\n2 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor more information on the run command, take a look at \u003ca href="/docs/reference_commands/run/"\u003ethe viash run\ncommand page\u003c/a\u003e. Great! With that working,\nthe next step is building an executable.\u003c/p\u003e\n\u003ch2 id="building-an-executable"\u003eBuilding an executable\u003c/h2\u003e\n\u003cp\u003eYou can generate an executable using either the native or the docker\nplatform. The former will generate a file that can be run locally, but\ndepends on your locally installed software packages to work. A docker\nexecutable on the other hand can build and start up a docker container\nthat handles the dependencies for you.\u003cbr\u003e\nTo create a native build, execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA new folder named \u003cstrong\u003eoutput\u003c/strong\u003e will have been created with an executable\ninside named \u003cstrong\u003emd_url_checker\u003c/strong\u003e. To test it out, execute the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eoutput/md_url_checker --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is the same as by running the component, but the executable\ncan be easily shared and now includes the ability to feed arguments to\nit and an included \u003ccode\u003e--help\u003c/code\u003e command. Not bad!\u003cbr\u003e\nNext up is the docker executable. You can specify the platform with the\n\u003ccode\u003e-p\u003c/code\u003e argument and choose an output folder using \u003ccode\u003e-o\u003c/code\u003e, apart from that\nit’s the same as the previous build command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build -p docker -o docker_output config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll now have a \u003cstrong\u003edocker_output\u003c/strong\u003e folder alongside the \u003cstrong\u003eoutput\u003c/strong\u003e\none. This folder also contains a file named \u003cstrong\u003emd_url_checker\u003c/strong\u003e, but\nits inner workings are slightly different than before. Run\n\u003cstrong\u003emd_url_checker\u003c/strong\u003e with the full arguments list to test what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003edocker_output/md_url_checker --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s what just happened:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the docker image wasn’t found, Viash will download it.\u003c/li\u003e\n\u003cli\u003eA check is made to see if a container named “md_url_checker”\nexists. If not, one will be built with the image defined in the\nconfig as its base.\u003c/li\u003e\n\u003cli\u003eAll dependencies defined in the config are taken care of.\u003c/li\u003e\n\u003cli\u003eThe script is run with the passed arguments and the output is passed\nto your shell. The \u003cstrong\u003emy_report.txt\u003c/strong\u003e file is written to your\nworking directory.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor more information about the \u003ccode\u003eviash build\u003c/code\u003e command, take a look at\n\u003ca href="/docs/reference_commands/build/"\u003eits command page\u003c/a\u003e. That concludes the\nbuilding of executables based on components using Viash!\u003c/p\u003e\n\u003ch2 id="writing-and-running-a-unit-test"\u003eWriting and running a unit test\u003c/h2\u003e\n\u003cp\u003eTo finish off this tutorial, it’s important to talk about unit tests. To\nensure that your component works as expected during its development\ncycle, writing one or more tests is essential. Luckily, writing a unit\ntest for a Viash component is straightforward.\u003c/p\u003e\n\u003cp\u003eYou just need to add test parameters in the config file and write a\nscript which runs the executable and verifies the output. When running\ntests, Viash will automatically build an executable and place it\nalongside the other defined resources in a temporary working directory.\nTo get started, open up \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file again and add this at\nthe end of the functionality dictionary, between the \u003ccode\u003epath: script.sh\u003c/code\u003e\nand \u003ccode\u003eplatforms:\u003c/code\u003e lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  tests:\n  - type: bash_script\n    path: test.sh\n  - path: Testfile.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis test dictionary contains a reference to the test script and all of\nthe files that need to be copied over in order to complete a test. In\nthe case of our example, \u003cstrong\u003etest.sh\u003c/strong\u003e will be the test script and\n\u003cstrong\u003eTestfile.md\u003c/strong\u003e is necessary as an input markdown file is required for\nthe script to function. Now create a new file named \u003cstrong\u003etest.sh\u003c/strong\u003e in the\n\u003cstrong\u003emy_viash_component\u003c/strong\u003e folder and add this as its content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eset -ex # exit the script when one of the checks fail and output all commands.\n\n# check 1\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\u0026quot;\n\n# run component with required input(s)\n./md_url_checker --inputfile Testfile.md \u0026gt; test-output.txt\n\n[[ ! -f test-output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Test output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\ngrep -q \'1: https://www.google.com\' test-output.txt # Did the script find the URL?\ngrep -q \'HTTP/2 404\' test-output.txt  # Did the web request return a 404 for the page that doesn\'t exist?\n\n# check 2\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\u0026quot;\n\n[[ ! -f output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\ngrep -q \'URL: https://www.google.com\' output.txt # Was the URL written correctly in the report?\ngrep -q \'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404\' output.txt # Was the error written correctly in the report?\ngrep -q \'Link name: install viash here\' output.txt # Was link name written correctly in the report?\n\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\u0026quot;\nexit 0 # don\'t forget to put this at the end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis bash script will run the component and perform several checks to\nits output. A successful test runs all the way down and exits with a \u003cstrong\u003e0\nexit code\u003c/strong\u003e, any other code means a failure:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eset -ex\u003c/code\u003e will stop the script once any of the lines fail and will\noutput all commands to the shell with a ‘+’ before it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./md_url_checker --inputfile Testfile.md \u0026gt; test-output.txt\u003c/code\u003e runs\nthe component and writes its output to a file.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e[[ ! -f test-output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Test output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\u003c/code\u003e\nchecks is the output file exists, if it doesn’t exit with a 1 code.\u003c/li\u003e\n\u003cli\u003eAll of the \u003ccode\u003egrep\u003c/code\u003e calls check if a certain piece of text could be\nfound. Each of these calls can exit the script if the text wasn’t\nfound.\u003c/li\u003e\n\u003cli\u003eIf everything succeeded, exit with a 0 code. Make sure not to forget\nthis final line in your own tests.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMake sure both the config and test files are saved, then run a test by\nrunning this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRunning tests in temporary directory: \'/tmp/viash_test_md_url_checker5828773777380597444\'\n====================================================================\n+/tmp/viash_test_md_url_checker5828773777380597444/build_executable/md_url_checker ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker5828773777380597444/test_test.sh/test.sh\n\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\'\n+ ./md_url_checker --inputfile Testfile.md\n+ [[ ! -f test-output.txt ]]\n+ grep -q \'1: https://www.google.com\' test-output.txt\n+ grep -q \'HTTP/2 404\' test-output.txt\n\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\'\n+ [[ ! -f output.txt ]]\n+ grep -q \'URL: https://www.google.com\' output.txt\n+ grep -q \'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404\' output.txt\n+ grep -q \'Link name: install viash here\' output.txt\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\'\n\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\n+ exit 0\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the test succeeds it simply writes the full output to the shell. If\nthere’s any issues, the script stops and an error message will appear in\nred. For more information on tests take a look at the \u003ca href="/docs/reference_commands/test/"\u003eviash test\ncommand page\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow you’re ready to use Viash to creating components from your own\nscripts, check out the rest of our documentation on the left. Here are\nsome good starting points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eReference: Commands\u003c/strong\u003e section on the left\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="/docs/reference_config/functionality/"\u003eoverview of the functionality\ndictionary\u003c/a\u003e of the config\nfile\u003c/li\u003e\n\u003cli\u003eMore details about \u003ca href="/docs/reference_config/platform-docker/"\u003ethe docker\nplatform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:6,href:"/docs/creating_components/python/",title:"Creating a Python Component",description:"Developing a new Viash component.",content:'\u003cp\u003eIn this tutorial, you’ll create a component that does the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtract all hyperlinks from a markdown file\u003c/li\u003e\n\u003cli\u003eCheck if every URL is reachable\u003c/li\u003e\n\u003cli\u003eCreate a text report with the results\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe component will be able to run locally and as a docker container. In\norder to create a component you need two files: a script for the\nfunctionality and a config file that describes the component.\u003c/p\u003e\n\u003cp\u003eThe files used in this tutorial can be found here:\u003c/p\u003e\n\u003cp\u003e\u003ca href="https://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker_py"\u003ehttps://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker_py\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/getting_started/installation"\u003einstallation of Viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://www.docker.com/"\u003eDocker\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://www.python.org/downloads/"\u003ePython 3.8 or newer\u003c/a\u003e. You may\nhave to install the \u003ccode\u003epython-is-python3\u003c/code\u003e package on Ubuntu and its\nderivatives.\u003c/li\u003e\n\u003cli\u003eAn installation of\n\u003ca href="https://lxml.de/installation.html"\u003epython3-lxml\u003c/a\u003e. Install this via\nyour package manager if you don’t have it installed yet.\u003c/li\u003e\n\u003cli\u003eInstall the following packages via\n\u003ca href="https://pypi.org/project/pip/"\u003epip\u003c/a\u003e: markdown, lxml and requests.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe recommend you take a look at the \u003ca href="/docs/getting_started/what_is_a_viash_component"\u003ehello world\nexample\u003c/a\u003e first to\nunderstand how components work.\u003c/p\u003e\n\u003ch2 id="write-a-script-in-python"\u003eWrite a script in python\u003c/h2\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case a python script.\u003cbr\u003e\nCreate a new folder named \u003cstrong\u003emy_viash_component\u003c/strong\u003e and open it. Now\ncreate a new file named \u003cstrong\u003escript.py\u003c/strong\u003e in there and add this code as its\ncontent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003e# Dependencies:\n# packages: python3-lxml\n# pip: markdown, lxml, requests\n\n### 1 ###\n\n## VIASH START\n\npar = {\n  \u0026quot;inputfile\u0026quot;: \u0026quot;Testfile.md\u0026quot;,\n  \u0026quot;domain\u0026quot;: \u0026quot;https://viash.io\u0026quot;,\n  \u0026quot;output\u0026quot;: \u0026quot;output.txt\u0026quot;\n}\n\n## VIASH END\n\nimport markdown\nfrom lxml import etree\nimport requests\n\n### 2 ###\n\n# Open markdown file, convert it to html and parse it to an ElementTree\nwith open(par[\u0026quot;inputfile\u0026quot;], encoding=\u0026quot;utf8\u0026quot;) as file:\n    md = file.read().replace(\'\\n\', \'\')\n\ndoc = etree.fromstring(markdown.markdown(md))\n\n# Create and clear output file\noutput_file = open(par[\'output\'], \'a\')\noutput_file.truncate(0)\n\namount_of_urls = len(doc.xpath(\'//a\'))\namount_of_errors = 0\nexpected_code = 200\n\n### 3 ###\n\n# Iterate over all hyperlinks and check each URL\nfor index, link in enumerate(doc.xpath(\'//a\')):\n    title = link.text\n    url = link.get(\'href\')\n\n    ### 4 ###\n\n    # If an URL doesn\'t start with \'http\', add the domain before it\n    if not url.startswith(\'http\') and par[\u0026quot;domain\u0026quot;] != None:\n        url = \'{}{}\'.format(par[\u0026quot;domain\u0026quot;] , url)\n\n    print(str(index+1) + \u0026quot;: \u0026quot; + url)\n\n    output_file.write(\u0026quot;Link name: \u0026quot; + title + \u0026quot;\\n\u0026quot;)\n    output_file.write(\u0026quot;URL: \u0026quot; + url + \u0026quot;\\n\u0026quot;)\n\n    ### 5 ###\n\n    try:\n        # Do a HEAD request and get the status code from the last response after following any redirects\n        req = requests.head(url, allow_redirects=True)\n\n        # Check if status code contains 200, which means the connection was succesful\n        if req.status_code == 200:\n            print(\'OK\')\n            output_file.write(\u0026quot;Status: OK, can be reached.\\n\u0026quot;)\n        else:\n            print(req.status_code) \n            output_file.write(\u0026quot;Status: ERROR! URL cannot be reached. Status code: \u0026quot; + str(req.status_code) + \u0026quot;\\n\u0026quot;)\n            amount_of_errors+=1\n\n    except requests.ConnectionError:\n        print(\u0026quot;Could not connect\u0026quot;)\n        output_file.write(\u0026quot;Status: ERROR! URL cannot be reached. A connection error occured.\\n\u0026quot;)\n        amount_of_errors+=1\n    except:\n        print(\u0026quot;Something went wrong\u0026quot;)\n        output_file.write(\u0026quot;Status: ERROR! URL cannot be reached. Something went wrong.\\n\u0026quot;)\n        amount_of_errors+=1\n\n    output_file.write(\u0026quot;---\\n\u0026quot;)\n\nprint(\u0026quot;\\n\u0026quot; + par[\u0026quot;inputfile\u0026quot;] + \u0026quot; has been checked and a report named \u0026quot; + par[\u0026quot;output\u0026quot;] + \u0026quot; has been generated.\\n\u0026quot; +\nstr(amount_of_errors) + \u0026quot; of \u0026quot; + str(amount_of_urls) + \u0026quot; URLs could not be resolved.\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the numbered comments scattered about looking like \u003ccode\u003e### x ###\u003c/code\u003e,\nhere’s a breakdown of the code:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe variables are placed between \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e\nfor debugging purposes, their final values will be dynamically\ngenerated by Viash once the script is turned into a component. If\nyou want to skip the testing of your script, you can leave these out\nand Viash will create variables based on the configuration file.\nThere are three variables:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einputfile\u003c/code\u003e: The markdown file that needs to be parsed.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edomain\u003c/code\u003e: The domain URL that gets inserted before any relative\nURLs. For example, “/documentation/intro” could be replaced with\n“\u003ca href="https://my-website/documentation/intro"\u003ehttps://my-website/documentation/intro\u003c/a\u003e” to create a valid\nURL.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoutput\u003c/code\u003e: The path of the output text file that will contain the\nreport.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe script converts the markdown file to html and extracts the\nhyperlinks into an\n\u003ca href="https://lxml.de/tutorial.html#the-elementtree-class"\u003eElementTree\u003c/a\u003e\nfor later use.\u003c/li\u003e\n\u003cli\u003eStart a for-loop to iterate the hyperlinks.\u003c/li\u003e\n\u003cli\u003eAny relative URLs (or those that don’t start with “http” at least)\nwill get the domain added before it.\u003c/li\u003e\n\u003cli\u003eA HEAD request is used to check for a response from the URL. The\nresulting status code is stored and compared to the expected code.\nThe results get written to the terminal and the report.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id="test-the-script"\u003eTest the script\u003c/h2\u003e\n\u003cp\u003eBefore turning the script into a component, it’s a good idea to test if\nit actually works as expected.\u003cbr\u003e\nAs the script expects a markdown file with hyperlinks, create a new file\nin the script folder named \u003cstrong\u003eTestfile.md\u003c/strong\u003e and paste in the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-markdown"\u003e# Test File\n\nThis is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.\nSome links to websites:\n\n- [Google](https://www.google.com)\n- [Reddit](https://www.reddit.com)\n- [A broken link](http://microsoft.com/random-link)\n\nLinks that are relative to [viash.io](http://www.viash.io):\n\n- You can [install viash here](/docs/getting_started/installation).\n- It all starts with a script and a [config file](/docs/reference_config/config) for your components.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow open a terminal in the folder and execute the following command to\nrun the python script:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003epython script.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe script will now show the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1: https://www.google.com\nOK\n2: https://www.reddit.com\n401\n3: http://microsoft.com/random-link\n404\n4: http://www.viash.io\nOK\n5: https://viash.io/docs/getting_started/installation\n404\n6: https://viash.io/docs/reference_config/config\nOK\n\nTestfile.md has been checked and a report named output.txt has been generated.\n3 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you get this same output, that means the script is working as\nintended! Feel free to take a peek at the generated \u003cstrong\u003eoutput.txt\u003c/strong\u003e file\nas well. You might have noticed you didn’t have to provide any\narguments, that’s because the values are hard-coded into the script for\ndebugging purposes.\u003c/p\u003e\n\u003cp\u003eNow the script has been tested, it’s time to create a config file to\ndescribe the component based on it.\u003c/p\u003e\n\u003ch2 id="describe-the-component-using-yaml"\u003eDescribe the component using YAML\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eviash config file\u003c/strong\u003e is a \u003ca href="https://yaml.org/"\u003eYAML\u003c/a\u003e file that\ndescribes the behavior and supported platforms of a Viash component.\nCreate new file named \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e and paste the following\ntemplate inside of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: NAME\n  description: DESCRIPTION\n  arguments:                     \n  - type: string\n    name: --input\n    description: INPUT DESCRIPTION\n  resources:\n  - type: LANGUAGE_script\n    path: SCRIPT\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery config file requires these two dictionaries:\n\u003ca href="/docs/getting_started/what_is_a_viash_component/#functionality"\u003efunctionality\u003c/a\u003e\nand\n\u003ca href="/docs/getting_started/what_is_a_viash_component/#platforms"\u003eplatforms\u003c/a\u003e.\nThis bare-bones config file makes it easy to “fill in the blanks” for\nthis example. For more information about config files, you can take a\nlook at the \u003cstrong\u003eReference: Config\u003c/strong\u003e section on the left.\u003c/p\u003e\n\u003cp\u003eLet’s start off by defining the functionality of our component.\u003c/p\u003e\n\u003ch3 id="defining-the-functionality"\u003eDefining the functionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e dictionary describes what the component does and\nthe resources it needs to do so. The first key is \u003cstrong\u003ename\u003c/strong\u003e, this will be\nthe name of the component once it’s built. Replace the \u003cstrong\u003eNAME\u003c/strong\u003e value\nwith \u003cstrong\u003emd_url_checker_py\u003c/strong\u003e or any other name of your choosing.\u003c/p\u003e\n\u003cp\u003eNext up is the \u003cstrong\u003edescription\u003c/strong\u003e key, its value will be printed out at the\ntop when the \u003cstrong\u003e–help\u003c/strong\u003e command is called. Replace \u003cstrong\u003eDESCRIPTION\u003c/strong\u003e with\n“\u003cstrong\u003eCheck if URLs in a markdown are reachable and create a text report\nwith the results.\u003c/strong\u003e”. You can use multiple lines for a description by\nstarting its value with a pipe (|) and a new line, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: md_url_checker_py\n  description: |\n    This is the first line of my description.\n    Here\'s a second line!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003cstrong\u003earguments\u003c/strong\u003e dictionary contains all of the arguments that are\naccepted by the component. These arguments will be injected as variables\nin the script. In the case of the example script, this are the variables\nwe’re working with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einputfile\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edomain\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoutput\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create good arguments, you need to ask yourself a few essential\nquestions about each variable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat is the most fitting \u003ca href="/docs/reference_config/functionality/#arguments-list"\u003edata\ntype\u003c/a\u003e?\u003c/li\u003e\n\u003cli\u003eIs it an input or an output?\u003c/li\u003e\n\u003cli\u003eIs it required?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s take a closer look at \u003ccode\u003einputfile\u003c/code\u003e for starters:\u003c/p\u003e\n\u003cp\u003eWe know it’s a file, as the script needs the path to a markdown \u003cstrong\u003efile\u003c/strong\u003e\nas its \u003cstrong\u003einput\u003c/strong\u003e. It’s also definitely a \u003cstrong\u003erequired\u003c/strong\u003e variable, as the\nscript would be pointless without it.\u003cbr\u003e\nWith this in mind, modify the first argument as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChange \u003cstrong\u003etype\u003c/strong\u003e’s value to \u003cstrong\u003efile\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eSet \u003cstrong\u003ename\u003c/strong\u003e’s value to \u003cstrong\u003e–inputfile\u003c/strong\u003e. The name of an argument has\nto match the variable name as the argument will be injected into the\nfinal script. In the case of \u003cstrong\u003epython\u003c/strong\u003e scripts, the variables are\nadded to a dictionary named \u003cstrong\u003epar\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eUse “\u003cstrong\u003eThe input markdown file.\u003c/strong\u003e” for the \u003cstrong\u003edescription\u003c/strong\u003e value.\nThis description will be included when the \u003cstrong\u003e–help\u003c/strong\u003e option is\ncalled.\u003c/li\u003e\n\u003cli\u003eAdd a new key named \u003cstrong\u003erequired\u003c/strong\u003e and set its value to \u003cstrong\u003etrue\u003c/strong\u003e. This\nensures that the component will not be run without a value for this\nargument.\u003c/li\u003e\n\u003cli\u003eAdd another key, name it \u003cstrong\u003emust_exist\u003c/strong\u003e and set its value to\n\u003cstrong\u003etrue\u003c/strong\u003e. This key is unique to \u003cstrong\u003efile\u003c/strong\u003e type arguments, it adds\nextra logic to the component to check if a file exists before\nrunning the component. This saves you from having to do this check\nyourself in the script.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat’s it for the first argument! The result should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow for \u003ccode\u003edomain\u003c/code\u003e, this is a simple \u003cstrong\u003eoptional string\u003c/strong\u003e that gets added\nbefore relative URLs. Make room for a new argument by creating a new\nline below \u003ccode\u003emust_exist: true\u003c/code\u003e and press \u003cstrong\u003eShift + Tab\u003c/strong\u003e to back up one\ntab so the cursor is aligned with the start of the first argument. Add\nthe \u003ccode\u003e--domain\u003c/code\u003e argument here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument isn’t required, you can simply omit the \u003cstrong\u003erequired\u003c/strong\u003e key.\nHere’s what the arguments dictionary look like up until now:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  arguments:                     \n  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe final variable to create an argument for is \u003ccode\u003eoutput\u003c/code\u003e. This is\nanother \u003cstrong\u003efile\u003c/strong\u003e and clearly an \u003cstrong\u003eoutput\u003c/strong\u003e. Its value \u003cstrong\u003eisn’t required\u003c/strong\u003e\nas we can use a \u003cstrong\u003edefault\u003c/strong\u003e path if no explicit value is given.\u003cbr\u003e\nAdd yet another new argument with the following keys and values:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a \u003cstrong\u003etype\u003c/strong\u003e key and set \u003cstrong\u003efile\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eThe next key is \u003cstrong\u003ename\u003c/strong\u003e, use \u003cstrong\u003e–output\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eFor the \u003cstrong\u003edescription\u003c/strong\u003e, use “\u003cstrong\u003eThe path of the output text file\nthat will contain the report.\u003c/strong\u003e”.\u003c/li\u003e\n\u003cli\u003eAdd a new key and name it \u003cstrong\u003edefault\u003c/strong\u003e. This will act as the default\nvalue when not specified by the user of the component. Set its value\nto \u003cstrong\u003e“output.txt”\u003c/strong\u003e, including the quotation marks.\u003c/li\u003e\n\u003cli\u003eFinally, add the \u003cstrong\u003edirection\u003c/strong\u003e key and set its value to \u003cstrong\u003eoutput\u003c/strong\u003e.\nThis specifies the direction of an argument as either \u003cstrong\u003einput\u003c/strong\u003e or\n\u003cstrong\u003eoutput\u003c/strong\u003e, with input being the default. Specifying that an\nargument is an output is important so the component can correctly\nhandle the writing of files and the passing of values in a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe finished argument should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file                           \n    name: --output\n    description: The path of the output text file that will contain the report.\n    default: \u0026quot;output.txt\u0026quot;\n    direction: output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith that, there’s just one more part of the functionality to fill in:\nthe script itself!\u003cbr\u003e\nEvery Viash component has one or more resources, the most important of\nwhich is often the script. The template already contains a \u003cstrong\u003eresources\u003c/strong\u003e\ndictionary, so replace the following values to point to the script:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSet the value of \u003cstrong\u003etype\u003c/strong\u003e to \u003cstrong\u003epython_script\u003c/strong\u003e. The script used in\nthis case was written in \u003cstrong\u003epython\u003c/strong\u003e, so the resource type is set\naccordingly so Viash knows what flavor of code to generate to create\nthe final component. You can find a full overview of the different\nresource types on the \u003ca href="/docs/reference_config/functionality/#resources-list"\u003eFunctionality\npage\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eChange the value of \u003cstrong\u003epath\u003c/strong\u003e to \u003cstrong\u003escript.py\u003c/strong\u003e. This points to the\nresource and can be a relative path, an absolute path or even a URL.\nIn this case we keep the script in the same directory as the config\nfile to keep things simple.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat finishes up the functionality side of the component! All that’s\nleft is defining the platforms with their dependencies and then running\nand building the component.\u003c/p\u003e\n\u003ch3 id="defining-the-platforms"\u003eDefining the platforms\u003c/h3\u003e\n\u003cp\u003eThe platforms dictionary specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform is assumed. Here’s a quick overview of\nthe platforms:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003enative\u003c/strong\u003e: The platform for developers that know what they’re doing\nor for simple components without any dependencies. All dependencies\nneed to be installed on the system the component is run on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edocker\u003c/strong\u003e: This platform is recommended for most components. The\ndependencies are resolved by using \u003ca href="https://www.docker.com/"\u003edocker\u003c/a\u003e\ncontainers, either from scratch or by pulling one from a docker\nrepository. This has huge benefits as the end user doesn’t need to\nhave any of the dependencies installed locally.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enextflow\u003c/strong\u003e: This converts the component into a\n\u003ca href="https://www.nextflow.io/"\u003eNextFlow\u003c/a\u003e module that can be imported\ninto a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn this tutorial, we’ll take a look at both the native and docker\nplatforms. The platforms are also defined in the \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e\nfile at the very bottom. The native platform is actually already defined\nin the template, that one \u003cstrong\u003etype\u003c/strong\u003e key with a value of \u003cstrong\u003enative\u003c/strong\u003e is\nenough! Now for adding the docker platform, add a new line below the\nlast and add the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: docker\n    image: python:3.9.5-slim-buster\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells Viash that this component can be built to a docker container\nwith the a \u003ca href="https://hub.docker.com/_/python"\u003eslimmed down version of the python\nimage\u003c/a\u003e as its base. If your script\ndoesn’t depend on any packages, this would be all you’d have to add when\nusing a python script. The script in our example however needs a few\npackages installed to work. Luckily, this isn’t a problem since Viash\n\u003ca href="/docs/reference_config/platform-docker/#example"\u003esupports defining\ndependencies\u003c/a\u003e which\nthen get pulled from inside the docker container before running the\nscript. To add the dependencies that needs to be installed, add these\nlines below \u003ccode\u003eimage: python:3.9.5-slim-buster\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e    setup:\n      - type: apt\n        packages: [ python3-lxml ]\n      - type: python\n        pip: [ markdown, lxml, requests ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will prompt the \u003ca href="https://en.wikipedia.org/wiki/APT_(software)"\u003eapt\u003c/a\u003e\npackage manager to download and install \u003cstrong\u003epython3-lxml\u003c/strong\u003e inside of the\ncontainer. Next, the python dependencies are resolved by using\n\u003ca href="https://pypi.org/project/pip/"\u003epip\u003c/a\u003e, the package installer for Python\nto download the necessary packages for reading markdown and html on top\nof sending web requests. That’s it for the config! Be sure to save it\nand let’s move on to actually running the component you’ve created. For\nreference, you can take a look at the completed \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file\nin \u003ca href="https://github.com/viash-io/viash_web/blob/main/static/examples/md_url_checker_py/config.vsh.yaml"\u003eour Github\nrepository\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="run-the-component"\u003eRun the component\u003c/h2\u003e\n\u003cp\u003eTime to run the component! First off, let’s see what the output of\n\u003ccode\u003e--help\u003c/code\u003e is. To do that, open a terminal in the \u003cstrong\u003emy_viash_component\u003c/strong\u003e\nfolder and execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will show the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCheck if URLs in a markdown are reachable and create a text report with the results.\n\nOptions:\n    --inputfile=file\n        type: file, required parameter\n        The input markdown file.\n\n    --domain=string\n        type: string\n        The domain URL that gets inserted before any relative URLs. For example, /documentation/intro could be replaced with https://my-website/documentation/intro to create a valid URL.\n\n    --output=file\n        type: file, default: output.txt\n        The path of the output text file that will contain the report.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the values you entered into the config file are all\nhere.\u003cbr\u003e\nNext, let’s run the component natively with some arguments. You can use\none of your own markdown files as the input if you desire. In that case,\nreplace \u003cstrong\u003eTestfile.md\u003c/strong\u003e in the command with the path to your file.\u003cbr\u003e\nExecute the following command to run the component with the default\nplatform, in this case \u003cstrong\u003enative\u003c/strong\u003e as it’s the first in the \u003cstrong\u003eplatforms\u003c/strong\u003e\ndictionary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all goes well, you’ll see something like this output in the terminal\nand a file named \u003cstrong\u003emy_report.txt\u003c/strong\u003e will have appeared:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1: https://www.google.com\nOK\n2: https://www.reddit.com\n401\n3: http://microsoft.com/random-link\n404\n4: http://www.viash.io\nOK\n5: https://viash.io//docs/getting_started/installation\n404\n6: https://viash.io//docs/reference_config/config\nOK\n\nTestfile.md has been checked and a report named my_report.txt has been generated.\n3 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor more information on the run command, take a look at \u003ca href="/docs/reference_commands/run/"\u003ethe Viash run\ncommand page\u003c/a\u003e. Great! With that working,\nthe next step is building an executable.\u003c/p\u003e\n\u003ch2 id="building-an-executable"\u003eBuilding an executable\u003c/h2\u003e\n\u003cp\u003eYou can generate an executable using either the native or the docker\nplatform. The former will generate a file that can be run locally, but\ndepends on your locally installed software packages to work. A docker\nexecutable on the other hand can build and start up a docker container\nthat handles the dependencies for you.\u003cbr\u003e\nTo create a native build, execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA new folder named \u003cstrong\u003eoutput\u003c/strong\u003e will have been created with an executable\ninside named \u003cstrong\u003emd_url_checker_py\u003c/strong\u003e. To test it out, execute the\nfollowing command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eoutput/md_url_checker_py --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is the same as by running the component, but the executable\ncan be easily shared and now includes the ability to feed arguments to\nit and an included \u003ccode\u003e--help\u003c/code\u003e command. Not bad!\u003cbr\u003e\nNext up is the docker executable. You can specify the platform with the\n\u003ccode\u003e-p\u003c/code\u003e argument and choose an output folder using \u003ccode\u003e-o\u003c/code\u003e, apart from that\nit’s the same as the previous build command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build -p docker -o docker_output config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll now have a \u003cstrong\u003edocker_ouput\u003c/strong\u003e folder alongside the \u003cstrong\u003eoutput\u003c/strong\u003e one.\nThis folder also contains a file named \u003cstrong\u003emd_url_checker_py\u003c/strong\u003e, but its\ninner workings are slightly different than before. Run\n\u003cstrong\u003emd_url_checker_py\u003c/strong\u003e with the full arguments list to test what\nhappens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003edocker_output/md_url_checker_py --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s what just happened:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the docker image wasn’t found, Viash will download it.\u003c/li\u003e\n\u003cli\u003eA check is made to see if a container named “md_url_checker_py”\nexists. If not, one will be built with the image defined in the\nconfig as its base.\u003c/li\u003e\n\u003cli\u003eAll dependencies defined in the config are taken care of.\u003c/li\u003e\n\u003cli\u003eThe script is run with the passed arguments and the output is passed\nto your shell. The \u003cstrong\u003emy_report.txt\u003c/strong\u003e file is written to your\nworking directory.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor more information about the \u003ccode\u003eviash build\u003c/code\u003e command, take a look at\n\u003ca href="/docs/reference_commands/build/"\u003eits command page\u003c/a\u003e. That concludes the\nbuilding of executables based on components using Viash!\u003c/p\u003e\n\u003ch2 id="writing-and-running-a-unit-test"\u003eWriting and running a unit test\u003c/h2\u003e\n\u003cp\u003eTo finish off this tutorial, it’s important to talk about unit tests. To\nensure that your component works as expected during its development\ncycle, writing one or more tests is essential. Luckily, writing a unit\ntest for a Viash component is straightforward.\u003c/p\u003e\n\u003cp\u003eYou just need to add test parameters in the config file and write a\nscript which runs the executable and verifies the output. When running\ntests, Viash will automatically build an executable and place it\nalongside the other defined resources in a temporary working directory.\nTo get started, open up \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file again and add this at\nthe end of the functionality dictionary, between the \u003ccode\u003epath: script.py\u003c/code\u003e\nand \u003ccode\u003eplatforms:\u003c/code\u003e lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  tests:\n  - type: python_script\n    path: test.py\n  - path: Testfile.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis test dictionary contains a reference to the test script and all of\nthe files that need to be copied over in order to complete a test. In\nthe case of our example, \u003cstrong\u003etest.py\u003c/strong\u003e will be the test script and\n\u003cstrong\u003eTestfile.md\u003c/strong\u003e is necessary as an input markdown file is required for\nthe script to function. Now create a new file named \u003cstrong\u003etest.py\u003c/strong\u003e in the\n\u003cstrong\u003emy_viash_component\u003c/strong\u003e folder and add this as its content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003eimport unittest\nfrom os import path\nimport subprocess\n\nclass Tester(unittest.TestCase):\n    def test_arguments(self):\n        out = subprocess.check_output([\u0026quot;./md_url_checker_py\u0026quot;, \u0026quot;--inputfile\u0026quot;, \u0026quot;Testfile.md\u0026quot;, \u0026quot;--domain\u0026quot;, \u0026quot;https://viash.io\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertIn(\u0026quot;1: https://www.google.com\u0026quot;, out) # Did the script find the URL?\n        self.assertIn(\u0026quot;404\u0026quot;, out) # Did the web request return a 404 for the page that doesn\'t exist?\n        \n    def test_output_file(self):\n        with open (\u0026quot;output.txt\u0026quot;, \u0026quot;r\u0026quot;) as output:\n            out=output.readlines()\n        self.assertIn(\u0026quot;URL: https://www.google.com\\n\u0026quot;, out) # Was the URL written correctly in the report?\n        self.assertIn(\u0026quot;Status: ERROR! URL cannot be reached. Status code: 404\\n\u0026quot;, out) # Was the error written correctly in the report?\n        self.assertIn(\u0026quot;Link name: install viash here\\n\u0026quot;, out) # Was the error written correctly in the report?\n\n\nunittest.main()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis python script will run the component and perform several checks to\nits output using\n\u003ca href="https://docs.python.org/3/library/unittest.html"\u003eunittest\u003c/a\u003e. A\nsuccessful test runs all the way down and exits with “OK”.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esubprocess.check_output()\u003c/code\u003e runs the component and writes its output\nto a string.\u003c/li\u003e\n\u003cli\u003eAll of the \u003ccode\u003eself.assertIn()\u003c/code\u003e calls check if a certain piece of text\ncould be found.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunittest.main()\u003c/code\u003e executes the tests.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMake sure both the config and test files are saved, then run a test by\nrunning this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRunning tests in temporary directory: \'/tmp/viash_test_md_url_checker_py499183458416491146\'\n====================================================================\n+/tmp/viash_test_md_url_checker_py499183458416491146/build_executable/md_url_checker_py ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker_py499183458416491146/test_test.py/test.py\n..\n----------------------------------------------------------------------\nRan 2 tests in 2.672s\n\nOK\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the test succeeds it simply writes the full output to the shell. If\nthere’s any issues, the script stops and an error message will appear in\nred. For more information on tests take a look at the \u003ca href="/docs/reference_commands/test/"\u003eviash test\ncommand page\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow you’re ready to use Viash to creating components from your own\nscripts, check out the rest of our documentation on the left. Here are\nsome good starting points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eReference: Commands\u003c/strong\u003e section on the left\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="/docs/reference_config/functionality/"\u003eoverview of the functionality\ndictionary\u003c/a\u003e of the config\nfile\u003c/li\u003e\n\u003cli\u003eMore details about \u003ca href="/docs/reference_config/platform-docker/"\u003ethe docker\nplatform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- --\u003e\n\u003cpre\u003e\u003ccode\u003erm: can\'t remove \'output.txt\': No such file or directory\nrm: can\'t remove \'my_report.txt\': No such file or directory\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:7,href:"/docs/creating_components/r/",title:"Creating an R Component",description:"Developing a new Viash component.",content:'\u003cp\u003eIn this tutorial, you’ll create a component that does the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtract all hyperlinks from a markdown file\u003c/li\u003e\n\u003cli\u003eCheck if every URL is reachable\u003c/li\u003e\n\u003cli\u003eCreate a text report with the results\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe component will be able to run locally and as a docker container. In\norder to create a component you need two files: a script for the\nfunctionality and a config file that describes the component.\u003c/p\u003e\n\u003cp\u003eThe files used in this tutorial can be found here:\u003c/p\u003e\n\u003cp\u003e\u003ca href="https://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker_r"\u003ehttps://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker_r\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/getting_started/installation"\u003einstallation of Viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://www.docker.com/"\u003eDocker\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://cran.r-project.org/mirrors.html"\u003einstallation of the R software\nenvironment\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eThe following CRAN packages: tidyverse and testthat.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe recommend you take a look at the \u003ca href="/docs/getting_started/what_is_a_viash_component"\u003ehello world\nexample\u003c/a\u003e first to\nunderstand how components work.\u003c/p\u003e\n\u003ch2 id="write-a-script-in-r"\u003eWrite a script in R\u003c/h2\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case an R script.\u003cbr\u003e\nCreate a new folder named \u003cstrong\u003emy_viash_component\u003c/strong\u003e and open it. Now\ncreate a new file named \u003cstrong\u003escript.R\u003c/strong\u003e in there and add this code as its\ncontent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-r"\u003eoptions(tidyverse.quiet = TRUE)\nlibrary(tidyverse)\nlibrary(httr, quietly = TRUE)\nlibrary(rvest, quietly = TRUE)\n\n## VIASH START\npar \u0026lt;- list(\n  inputfile = \u0026quot;Testfile.md\u0026quot;,\n  domain = \u0026quot;https://viash.io\u0026quot;,\n  output = \u0026quot;output.txt\u0026quot;\n)\n\n## VIASH END\n\ntemp_html \u0026lt;- tempfile(fileext = \u0026quot;.html\u0026quot;)\non.exit(file.remove(temp_html)) # remove tempfile after scripts exits to make sure it\'s always removed\n\n# Convert the markdown file to html\nrmarkdown::render(\n  input = par$inputfile,\n  output_format = \u0026quot;html_document\u0026quot;,\n  output_file = temp_html,\n  quiet = TRUE,\n  runtime = \u0026quot;static\u0026quot;\n)\nhtml \u0026lt;- rvest::read_html(temp_html)\n\ncat(\u0026quot;Extracting URLs\\n\u0026quot;)\nurls \u0026lt;- html %\u0026gt;% html_elements(\u0026quot;a\u0026quot;) %\u0026gt;%\n  html_attr(\u0026quot;href\u0026quot;)\ntitles \u0026lt;- html %\u0026gt;% html_elements(\u0026quot;a\u0026quot;) %\u0026gt;%\n  html_text()\n\ncat(\u0026quot;Checking\u0026quot;, length(urls), \u0026quot;URLs\\n\u0026quot;)\noutputs \u0026lt;- map_df(seq_along(urls), function(i) {\n  url \u0026lt;- urls[i]\n  title \u0026lt;- titles[i]\n\n  # If an URL doesn\'t start with \'http\', add the domain before it\n  if (!grepl(\u0026quot;^https?://\u0026quot;, url)) {\n    url = paste0(par$domain, url)\n  }\n\n  output \u0026lt;- tibble(url, title)\n\n  # Do a web request and get the status code\n  output$status \u0026lt;-\n    tryCatch({\n      code \u0026lt;- status_code(GET(url))\n      if (code == \u0026quot;200\u0026quot;) {\n        \u0026quot;OK\u0026quot;\n      } else {\n        paste0(\u0026quot;ERROR! URL cannot be reached. Status code: \u0026quot;, code)\n      }\n    },\n    error = function(cond) {\n      \u0026quot;ERROR! URL does not seem to exist!\u0026quot;\n    },\n    warning = function(cond) {\n      \u0026quot;ERROR! URL caused a warning!\u0026quot;\n    })\n\n  output\n})\n\nprint(outputs)\n\ncontent \u0026lt;- paste0(\n  \u0026quot;Link name: \u0026quot;, outputs$title, \u0026quot;\\n\u0026quot;,\n  \u0026quot;URL: \u0026quot;, outputs$url, \u0026quot;\\n\u0026quot;,\n  outputs$status, \u0026quot;\\n\u0026quot;,\n  \u0026quot;---\u0026quot;\n)\n\nwrite_lines(content, par$output)\n\ncat(\u0026quot;\u0026quot;)\ncat(\u0026quot;Input \'\u0026quot;, par$inputfile, \u0026quot;\' has been checked and a report named \'\u0026quot;, par$output, \u0026quot;\' has been generated.\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\ncat(sum(outputs$status != \u0026quot;OK\u0026quot;), \u0026quot; out of \u0026quot;, nrow(outputs), \u0026quot; URLs could not be reached.\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the numbered comments scattered about looking like \u003ccode\u003e### x ###\u003c/code\u003e,\nhere’s a breakdown of the code:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe variables are placed between \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e\nfor debugging purposes, their final values will be dynamically\ngenerated by Viash once the script is turned into a component. If\nyou want to skip the testing of your script, you can leave these out\nand Viash will create variables based on the configuration file.\nThere are three variables inside of a list named \u003ccode\u003epar\u003c/code\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einputfile\u003c/code\u003e: The markdown file that needs to be parsed.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edomain\u003c/code\u003e: The domain URL that gets inserted before any relative\nURLs. For example, “/documentation/intro” could be replaced with\n“\u003ca href="https://my-website/documentation/intro"\u003ehttps://my-website/documentation/intro\u003c/a\u003e” to create a valid\nURL.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoutput\u003c/code\u003e: The path of the output text file that will contain the\nreport.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe script converts the markdown file to html and extracts the URLs\nand titles for later use.\u003c/li\u003e\n\u003cli\u003eStart a for-loop to iterate the hyperlinks.\u003c/li\u003e\n\u003cli\u003eAny relative URLs (or those that don’t start with “http” at least)\nwill get the domain added before it.\u003c/li\u003e\n\u003cli\u003eA GET request is used to check for a response from the URL. The\nresulting status code is stored and compared to the expected code.\nThe results get written to the terminal and the report.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id="test-the-script"\u003eTest the script\u003c/h2\u003e\n\u003cp\u003eBefore turning the script into a component, it’s a good idea to test if\nit actually works as expected.\u003cbr\u003e\nAs the script expects a markdown file with hyperlinks, create a new file\nin the script folder named \u003cstrong\u003eTestfile.md\u003c/strong\u003e and paste in the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-markdown"\u003e# Test File\n\nThis is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.\nSome links to websites:\n\n- [Google](https://www.google.com)\n- [Reddit](https://www.reddit.com)\n- [A broken link](http://microsoft.com/random-link)\n\nLinks that are relative to [viash.io](http://www.viash.io):\n\n- You can [install viash here](/docs/getting_started/installation).\n- It all starts with a script and a [config file](/docs/reference_config/config) for your components.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow open a terminal in the folder and execute the following command to\nrun the R script:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eRscript script.R\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe script will now show the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAttaching package: ‘rvest’\n\nThe following object is masked from ‘package:readr’:\n\n    guess_encoding\n\n[WARNING] This document format requires a nonempty \u0026lt;title\u0026gt; element.\n  Defaulting to \'Testfile\' as the title.\n  To specify a title, use \'title\' in metadata or --metadata title=\u0026quot;...\u0026quot;.\nExtracting URLs\nChecking 6 URLs\n# A tibble: 6 x 3\n  url                               title         status                        \n  \u0026lt;chr\u0026gt;                             \u0026lt;chr\u0026gt;         \u0026lt;chr\u0026gt;                         \n1 https://www.google.com            Google        OK                            \n2 https://www.reddit.com            Reddit        OK                            \n3 http://microsoft.com/random-link  A broken link ERROR! URL cannot be reached.…\n4 http://www.viash.io               viash.io      OK                            \n5 https://viash.io/docs/getting_st… install vias… ERROR! URL cannot be reached.…\n6 https://viash.io/docs/reference_… config file   OK                            \nInput \'Testfile.md\' has been checked and a report named \'output.txt\' has been generated.\n2 out of 6 URLs could not be reached.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you get this same output, that means the script is working as\nintended! Feel free to take a peek at the generated \u003cstrong\u003eoutput.txt\u003c/strong\u003e file\nas well. You might have noticed you didn’t have to provide any\narguments, that’s because the values are hard-coded into the script for\ndebugging purposes.\u003c/p\u003e\n\u003cp\u003eNow the script has been tested, it’s time to create a config file to\ndescribe the component based on it.\u003c/p\u003e\n\u003ch2 id="describe-the-component-using-yaml"\u003eDescribe the component using YAML\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eviash config file\u003c/strong\u003e is a \u003ca href="https://yaml.org/"\u003eYAML\u003c/a\u003e file that\ndescribes the behavior and supported platforms of a Viash component.\nCreate new file named \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e and paste the following\ntemplate inside of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: NAME\n  description: DESCRIPTION\n  arguments:                     \n  - type: string\n    name: --input\n    description: INPUT DESCRIPTION\n  resources:\n  - type: LANGUAGE_script\n    path: SCRIPT\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery config file requires these two dictionaries:\n\u003ca href="/docs/getting_started/what_is_a_viash_component/#functionality"\u003efunctionality\u003c/a\u003e\nand\n\u003ca href="/docs/getting_started/what_is_a_viash_component/#platforms"\u003eplatforms\u003c/a\u003e.\nThis bare-bones config file makes it easy to “fill in the blanks” for\nthis example. For more information about config files, you can take a\nlook at the \u003cstrong\u003eReference: Config\u003c/strong\u003e section on the left.\u003c/p\u003e\n\u003cp\u003eLet’s start off by defining the functionality of our component.\u003c/p\u003e\n\u003ch3 id="defining-the-functionality"\u003eDefining the functionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e dictionary describes what the component does and\nthe resources it needs to do so. The first key is \u003cstrong\u003ename\u003c/strong\u003e, this will be\nthe name of the component once it’s built. Replace the \u003cstrong\u003eNAME\u003c/strong\u003e value\nwith \u003cstrong\u003emd_url_checker_r\u003c/strong\u003e or any other name of your choosing.\u003c/p\u003e\n\u003cp\u003eNext up is the \u003cstrong\u003edescription\u003c/strong\u003e key, its value will be printed out at the\ntop when the \u003cstrong\u003e–help\u003c/strong\u003e command is called. Replace \u003cstrong\u003eDESCRIPTION\u003c/strong\u003e with\n“\u003cstrong\u003eCheck if URLs in a markdown are reachable and create a text report\nwith the results.\u003c/strong\u003e”. You can use multiple lines for a description by\nstarting its value with a pipe (|) and a new line, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: md_url_checker_r\n  description: |\n    This is the first line of my description.\n    Here\'s a second line!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003cstrong\u003earguments\u003c/strong\u003e dictionary contains all of the arguments that are\naccepted by the component. These arguments will be injected as variables\nin the script. In the case of the example script, this are the variables\nwe’re working with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einputfile\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edomain\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoutput\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create good arguments, you need to ask yourself a few essential\nquestions about each variable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat is the most fitting \u003ca href="/docs/reference_config/functionality/#arguments-list"\u003edata\ntype\u003c/a\u003e?\u003c/li\u003e\n\u003cli\u003eIs it an input or an output?\u003c/li\u003e\n\u003cli\u003eIs it required?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s take a closer look at \u003ccode\u003einputfile\u003c/code\u003e for starters:\u003c/p\u003e\n\u003cp\u003eWe know it’s a file, as the script needs the path to a markdown \u003cstrong\u003efile\u003c/strong\u003e\nas its \u003cstrong\u003einput\u003c/strong\u003e. It’s also definitely a \u003cstrong\u003erequired\u003c/strong\u003e variable, as the\nscript would be pointless without it.\u003cbr\u003e\nWith this in mind, modify the first argument as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChange \u003cstrong\u003etype\u003c/strong\u003e’s value to \u003cstrong\u003efile\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eSet \u003cstrong\u003ename\u003c/strong\u003e’s value to \u003cstrong\u003e–inputfile\u003c/strong\u003e. The name of an argument has\nto match the variable name as the argument will be injected into the\nfinal script. In the case of \u003cstrong\u003er\u003c/strong\u003e scripts, the variables are added\nto a list named \u003cstrong\u003epar\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eUse “\u003cstrong\u003eThe input markdown file.\u003c/strong\u003e” for the \u003cstrong\u003edescription\u003c/strong\u003e value.\nThis description will be included when the \u003cstrong\u003e–help\u003c/strong\u003e option is\ncalled.\u003c/li\u003e\n\u003cli\u003eAdd a new key named \u003cstrong\u003erequired\u003c/strong\u003e and set its value to \u003cstrong\u003etrue\u003c/strong\u003e. This\nensures that the component will not be run without a value for this\nargument.\u003c/li\u003e\n\u003cli\u003eAdd another key, name it \u003cstrong\u003emust_exist\u003c/strong\u003e and set its value to\n\u003cstrong\u003etrue\u003c/strong\u003e. This key is unique to \u003cstrong\u003efile\u003c/strong\u003e type arguments, it adds\nextra logic to the component to check if a file exists before\nrunning the component. This saves you from having to do this check\nyourself in the script.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat’s it for the first argument! The result should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow for \u003ccode\u003edomain\u003c/code\u003e, this is a simple \u003cstrong\u003eoptional string\u003c/strong\u003e that gets added\nbefore relative URLs. Make room for a new argument by creating a new\nline below \u003ccode\u003emust_exist: true\u003c/code\u003e and press \u003cstrong\u003eShift + Tab\u003c/strong\u003e to back up one\ntab so the cursor is aligned with the start of the first argument. Add\nthe \u003ccode\u003e--domain\u003c/code\u003e argument here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument isn’t required, you can simply omit the \u003cstrong\u003erequired\u003c/strong\u003e key.\nHere’s what the arguments dictionary look like up until now:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  arguments:                     \n  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe final variable to create an argument for is \u003ccode\u003eoutput\u003c/code\u003e. This is\nanother \u003cstrong\u003efile\u003c/strong\u003e and clearly an \u003cstrong\u003eoutput\u003c/strong\u003e. Its value \u003cstrong\u003eisn’t required\u003c/strong\u003e\nas we can use a \u003cstrong\u003edefault\u003c/strong\u003e path if no explicit value is given.\u003cbr\u003e\nAdd yet another new argument with the following keys and values:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a \u003cstrong\u003etype\u003c/strong\u003e key and set \u003cstrong\u003efile\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eThe next key is \u003cstrong\u003ename\u003c/strong\u003e, use \u003cstrong\u003e–output\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eFor the \u003cstrong\u003edescription\u003c/strong\u003e, use “\u003cstrong\u003eThe path of the output text file\nthat will contain the report.\u003c/strong\u003e”.\u003c/li\u003e\n\u003cli\u003eAdd a new key and name it \u003cstrong\u003edefault\u003c/strong\u003e. This will act as the default\nvalue when not specified by the user of the component. Set its value\nto \u003cstrong\u003e“output.txt”\u003c/strong\u003e, including the quotation marks.\u003c/li\u003e\n\u003cli\u003eFinally, add the \u003cstrong\u003edirection\u003c/strong\u003e key and set its value to \u003cstrong\u003eoutput\u003c/strong\u003e.\nThis specifies the direction of an argument as either \u003cstrong\u003einput\u003c/strong\u003e or\n\u003cstrong\u003eoutput\u003c/strong\u003e, with input being the default. Specifying that an\nargument is an output is important so the component can correctly\nhandle the writing of files and the passing of values in a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe finished argument should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file                           \n    name: --output\n    description: The path of the output text file that will contain the report.\n    default: \u0026quot;output.txt\u0026quot;\n    direction: output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith that, there’s just one more part of the functionality to fill in:\nthe script itself!\u003cbr\u003e\nEvery Viash component has one or more resources, the most important of\nwhich is often the script. The template already contains a \u003cstrong\u003eresources\u003c/strong\u003e\ndictionary, so replace the following values to point to the script:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSet the value of \u003cstrong\u003etype\u003c/strong\u003e to \u003cstrong\u003er_script\u003c/strong\u003e. The script used in this\ncase was written in \u003cstrong\u003eR\u003c/strong\u003e, so the resource type is set accordingly\nso Viash knows what flavor of code to generate to create the final\ncomponent. You can find a full overview of the different resource\ntypes on the \u003ca href="/docs/reference_config/functionality/#resources-list"\u003eFunctionality\npage\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eChange the value of \u003cstrong\u003epath\u003c/strong\u003e to \u003cstrong\u003escript.R\u003c/strong\u003e. This points to the\nresource and can be a relative path, an absolute path or even a URL.\nIn this case we keep the script in the same directory as the config\nfile to keep things simple.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat finishes up the functionality side of the component! All that’s\nleft is defining the platforms with their dependencies and then running\nand building the component.\u003c/p\u003e\n\u003ch3 id="defining-the-platforms"\u003eDefining the platforms\u003c/h3\u003e\n\u003cp\u003eThe platforms dictionary specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform is assumed. Here’s a quick overview of\nthe platforms:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003enative\u003c/strong\u003e: The platform for developers that know what they’re doing\nor for simple components without any dependencies. All dependencies\nneed to be installed on the system the component is run on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edocker\u003c/strong\u003e: This platform is recommended for most components. The\ndependencies are resolved by using \u003ca href="https://www.docker.com/"\u003edocker\u003c/a\u003e\ncontainers, either from scratch or by pulling one from a docker\nrepository. This has huge benefits as the end user doesn’t need to\nhave any of the dependencies installed locally.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enextflow\u003c/strong\u003e: This converts the component into a\n\u003ca href="https://www.nextflow.io/"\u003eNextFlow\u003c/a\u003e module that can be imported\ninto a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn this tutorial, we’ll take a look at both the native and docker\nplatforms. The platforms are also defined in the \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e\nfile at the very bottom. The native platform is actually already defined\nin the template, that one \u003cstrong\u003etype\u003c/strong\u003e key with a value of \u003cstrong\u003enative\u003c/strong\u003e is\nenough! Now for adding the docker platform, add a new line below the\nlast and add the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: docker\n    image: rocker/tidyverse:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells Viash that this component can be built to a docker container\nwith the a \u003ca href="https://hub.docker.com/r/rocker/tidyverse"\u003eRocker image including\ntidyverse\u003c/a\u003e as its base. If\nyour script doesn’t depend on any packages, this would be all you’d have\nto add when using an R script. The script in our example however needs\nan extra package installed to work. Luckily, this isn’t a problem since\nViash \u003ca href="/docs/reference_config/platform-docker/#example"\u003esupports defining\ndependencies\u003c/a\u003e which\nthen get pulled from inside the docker container before running the\nscript. To add the dependencies that needs to be installed, add these\nlines below \u003ccode\u003eimage: rocker/tidyverse:latest\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e    setup:\n    - type: apt\n      packages:\n        - pandoc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will prompt the \u003ca href="https://en.wikipedia.org/wiki/APT_(software)"\u003eapt\u003c/a\u003e\npackage manager to download and install \u003cstrong\u003epandoc\u003c/strong\u003e inside of the\ncontainer. That’s it for the config! Be sure to save it and let’s move\non to actually running the component you’ve created. For reference, you\ncan take a look at the completed \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file in \u003ca href="https://github.com/viash-io/viash_web/blob/main/static/examples/md_url_checker_r/config.vsh.yaml"\u003eour Github\nrepository\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="run-the-component"\u003eRun the component\u003c/h2\u003e\n\u003cp\u003eTime to run the component! First off, let’s see what the output of\n\u003ccode\u003e--help\u003c/code\u003e is. To do that, open a terminal in the \u003cstrong\u003emy_viash_component\u003c/strong\u003e\nfolder and execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will show the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCheck if URLs in a markdown are reachable and create a text report with the results.\n\nOptions:\n    --inputfile=file\n        type: file, required parameter\n        The input markdown file.\n\n    --domain=string\n        type: string\n        The domain URL that gets inserted before any relative URLs. For example, /documentation/intro could be replaced with https://my-website/documentation/intro to create a valid URL.\n\n    --output=file\n        type: file, default: output.txt\n        The path of the output text file that will contain the report.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the values you entered into the config file are all\nhere.\u003cbr\u003e\nNext, let’s run the component natively with some arguments. You can use\none of your own markdown files as the input if you desire. In that case,\nreplace \u003cstrong\u003eTestfile.md\u003c/strong\u003e in the command with the path to your file.\u003cbr\u003e\nExecute the following command to run the component with the default\nplatform, in this case \u003cstrong\u003enative\u003c/strong\u003e as it’s the first in the \u003cstrong\u003eplatforms\u003c/strong\u003e\ndictionary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all goes well, you’ll see something like this output in the terminal\nand a file named \u003cstrong\u003emy_report.txt\u003c/strong\u003e will have appeared:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAttaching package: ‘rvest’\n\nThe following object is masked from ‘package:readr’:\n\n    guess_encoding\n\n[WARNING] This document format requires a nonempty \u0026lt;title\u0026gt; element.\n  Defaulting to \'Testfile\' as the title.\n  To specify a title, use \'title\' in metadata or --metadata title=\u0026quot;...\u0026quot;.\nExtracting URLs\nChecking 6 URLs\n# A tibble: 6 x 3\n  url                               title         status                        \n  \u0026lt;chr\u0026gt;                             \u0026lt;chr\u0026gt;         \u0026lt;chr\u0026gt;                         \n1 https://www.google.com            Google        OK                            \n2 https://www.reddit.com            Reddit        OK                            \n3 http://microsoft.com/random-link  A broken link ERROR! URL cannot be reached.…\n4 http://www.viash.io               viash.io      OK                            \n5 https://viash.io//docs/getting_s… install vias… ERROR! URL cannot be reached.…\n6 https://viash.io//docs/reference… config file   OK                            \nInput \'Testfile.md\' has been checked and a report named \'my_report.txt\' has been generated.\n2 out of 6 URLs could not be reached.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor more information on the run command, take a look at \u003ca href="/docs/reference_commands/run/"\u003ethe Viash run\ncommand page\u003c/a\u003e. Great! With that working,\nthe next step is building an executable.\u003c/p\u003e\n\u003ch2 id="building-an-executable"\u003eBuilding an executable\u003c/h2\u003e\n\u003cp\u003eYou can generate an executable using either the native or the docker\nplatform. The former will generate a file that can be run locally, but\ndepends on your locally installed software packages to work. A docker\nexecutable on the other hand can build and start up a docker container\nthat handles the dependencies for you.\u003cbr\u003e\nTo create a native build, execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA new folder named \u003cstrong\u003eoutput\u003c/strong\u003e will have been created with an executable\ninside named \u003cstrong\u003emd_url_checker_r\u003c/strong\u003e. To test it out, execute the\nfollowing command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eoutput/md_url_checker_r --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is the same as by running the component, but the executable\ncan be easily shared and now includes the ability to feed arguments to\nit and an included \u003ccode\u003e--help\u003c/code\u003e command. Not bad!\u003cbr\u003e\nNext up is the docker executable. You can specify the platform with the\n\u003ccode\u003e-p\u003c/code\u003e argument and choose an output folder using \u003ccode\u003e-o\u003c/code\u003e, apart from that\nit’s the same as the previous build command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build -p docker -o docker_output config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll now have a \u003cstrong\u003edocker_ouput\u003c/strong\u003e folder alongside the \u003cstrong\u003eoutput\u003c/strong\u003e one.\nThis folder also contains a file named \u003cstrong\u003emd_url_checker_r\u003c/strong\u003e, but its\ninner workings are slightly different than before. Run\n\u003cstrong\u003emd_url_checker_r\u003c/strong\u003e with the full arguments list to test what\nhappens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003edocker_output/md_url_checker_r --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s what just happened:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the docker image wasn’t found, Viash will download it.\u003c/li\u003e\n\u003cli\u003eA check is made to see if a container named “md_url_checker_r”\nexists. If not, one will be built with the image defined in the\nconfig as its base.\u003c/li\u003e\n\u003cli\u003eAll dependencies defined in the config are taken care of.\u003c/li\u003e\n\u003cli\u003eThe script is run with the passed arguments and the output is passed\nto your shell. The \u003cstrong\u003emy_report.txt\u003c/strong\u003e file is written to your\nworking directory.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor more information about the \u003ccode\u003eviash build\u003c/code\u003e command, take a look at\n\u003ca href="/docs/reference_commands/build/"\u003eits command page\u003c/a\u003e. That concludes the\nbuilding of executables based on components using Viash!\u003c/p\u003e\n\u003ch2 id="writing-and-running-a-unit-test"\u003eWriting and running a unit test\u003c/h2\u003e\n\u003cp\u003eTo finish off this tutorial, it’s important to talk about unit tests. To\nensure that your component works as expected during its development\ncycle, writing one or more tests is essential. Luckily, writing a unit\ntest for a Viash component is straightforward.\u003c/p\u003e\n\u003cp\u003eYou just need to add test parameters in the config file and write a\nscript which runs the executable and verifies the output. When running\ntests, Viash will automatically build an executable and place it\nalongside the other defined resources in a temporary working directory.\nTo get started, open up \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file again and add this at\nthe end of the functionality dictionary, between the \u003ccode\u003epath: script.R\u003c/code\u003e\nand \u003ccode\u003eplatforms:\u003c/code\u003e lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  tests:\n  - type: r_script\n    path: test.R\n  - path: Testfile.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis test dictionary contains a reference to the test script and all of\nthe files that need to be copied over in order to complete a test. In\nthe case of our example, \u003cstrong\u003etest.R\u003c/strong\u003e will be the test script and\n\u003cstrong\u003eTestfile.md\u003c/strong\u003e is necessary as an input markdown file is required for\nthe script to function. Now create a new file named \u003cstrong\u003etest.R\u003c/strong\u003e in the\n\u003cstrong\u003emy_viash_component\u003c/strong\u003e folder and add this as its content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-r"\u003elibrary(testthat)\nlibrary(processx)\n\n# check 1\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./md_url_checker_r\u0026quot;, c(\u0026quot;--inputfile\u0026quot;, \u0026quot;Testfile.md\u0026quot;, \u0026quot;--domain\u0026quot;, \u0026quot;https://viash.io\u0026quot;))\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;https://www.google.com\u0026quot;)\nexpect_match(out$stdout, regexp = \u0026quot;ERROR! URL cannot be reached\u0026quot;)\n\n# check 2\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output file is correct\\n\u0026quot;)\noutput_file \u0026lt;- paste(readLines(\u0026quot;output.txt\u0026quot;), collapse=\u0026quot;\\n\u0026quot;)\nexpect_match(output_file, regexp = \u0026quot;https://www.google.com\u0026quot;)\nexpect_match(output_file, regexp = \u0026quot;ERROR! URL cannot be reached.\u0026quot;)\nexpect_match(output_file, regexp = \u0026quot;Link name: install viash here\u0026quot;)\n\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\\n\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis R script will run the component and perform several checks to its\noutput using\n\u003ca href="https://cran.r-project.org/web/packages/processx/index.html"\u003eprocessx\u003c/a\u003e\nand \u003ca href="https://testthat.r-lib.org/"\u003etestthat\u003c/a\u003e. A successful test runs all\nthe way down and exits with “OK”.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eprocessx::run()\u003c/code\u003e runs the component and writes its output to a\nstring.\u003c/li\u003e\n\u003cli\u003eAll of the \u003ccode\u003eexpect_match()\u003c/code\u003e calls check if a certain piece of text\ncould be found using regex.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMake sure both the config and test files are saved, then run a test by\nrunning this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRunning tests in temporary directory: \'/tmp/viash_test_md_url_checker_r652043861673572437\'\n====================================================================\n+/tmp/viash_test_md_url_checker_r652043861673572437/build_executable/md_url_checker_r ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker_r652043861673572437/test_test.R/test.R\n\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\n\u0026gt;\u0026gt;\u0026gt; Checking whether output file is correct\n\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the test succeeds it simply writes the full output to the shell. If\nthere’s any issues, the script stops and an error message will appear in\nred. For more information on tests take a look at the \u003ca href="/docs/reference_commands/test/"\u003eviash test\ncommand page\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow you’re ready to use Viash to creating components from your own\nscripts, check out the rest of our documentation on the left. Here are\nsome good starting points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eReference: Commands\u003c/strong\u003e section on the left\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="/docs/reference_config/functionality/"\u003eoverview of the functionality\ndictionary\u003c/a\u003e of the config\nfile\u003c/li\u003e\n\u003cli\u003eMore details about \u003ca href="/docs/reference_config/platform-docker/"\u003ethe docker\nplatform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:8,href:"/docs/creating_components/supported_languages/",title:"Supported Languages",description:"You can use several programming languages with Viash to write your own components.",content:'\u003cp\u003eTo get started with your preferred language, take a look at the language\nspecific examples below.\u003c/p\u003e\n\u003ch2 id="bash"\u003eBash\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e: This\ntutorial explains how to create your own Viash component from\nscratch using a Bash script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="python"\u003ePython\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/python"\u003eCreating a Python component\u003c/a\u003e:\nThis tutorial explains how to create your own Viash component from\nscratch using a Python script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="r"\u003eR\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/r"\u003eCreating an R component\u003c/a\u003e: This\ntutorial explains how to create your own Viash component from\nscratch using an R script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="scala"\u003eScala\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="javascript"\u003eJavascript\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="c"\u003eC#\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n'},{id:9,href:"/docs/creating_components/file_formats/",title:"Regarding File Formats",description:"",content:'\u003cp\u003eThe following two file formats are equivalent.\u003c/p\u003e\n\u003ch2 id="config-format"\u003eConfig format\u003c/h2\u003e\n\u003cp\u003eMetadata \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello\n  arguments:\n    - name: \u0026quot;name\u0026quot;\n      type: string\n      default: Bob\n  resources:\n    - type: bash_script\n      path: script.sh\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScript \u003ccode\u003escript.sh\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/bin/bash\necho Hello $par_name\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="script-format"\u003eScript format\u003c/h2\u003e\n\u003cp\u003eScript \u003ccode\u003escript.vsh.sh\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/bin/bash\n\n#\' functionality:\n#\'   name: hello\n#\'   arguments:\n#\'     - name: \u0026quot;name\u0026quot;\n#\'       type: string\n#\'       default: Bob\n#\' platforms:\n#\' - type: native\n\necho Hello $par_name\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:10,href:"/docs/reference_commands/run/",title:"viash run",description:"",content:'\u003cp\u003eExecutes a viash component from the provided viash config file. viash\ngenerates a temporary executable and immediately executes it with the\ngiven parameters.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml [-p docker] [-k true/false]  -- [arguments for script]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="config"\u003e–config\u003c/h3\u003e\n\u003cp\u003eA \u003ca href="/docs/reference_config/config"\u003eviash config file\u003c/a\u003e (example:\n\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This argument can also be a script with the config\nas a header.\u003c/p\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e. (default = List())\u003c/p\u003e\n\u003ch3 id="-k-keep-arg"\u003e-k, –keep \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eWhether or not to keep temporary files. By default, files will be\ndeleted if all goes well but remain when an error occurs. By specifying\n–keep true, the temporary files will always be retained, whereas –keep\nfalse will always delete them. The temporary directory can be\noverwritten by setting defining a VIASH_TEMP directory.\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eSpecifies which platform amongst those specified in the \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e to use. If this is not provided,\nthe first platform will be used. If no platforms are defined in the\n\u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="running-without-arguments"\u003eRunning without arguments\u003c/h3\u003e\n\u003cp\u003eSimply run a Viash component with its default platform and no script\narguments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="passing-script-arguments"\u003ePassing script arguments\u003c/h3\u003e\n\u003cp\u003eRun a component with script arguments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --input=\u0026quot;Hello!\u0026quot; -o=my_file.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="preserve-temporary-files"\u003ePreserve temporary files\u003c/h3\u003e\n\u003cp\u003eHere’s how you run a Viash component using the \u003ca href="/docs/reference_config/platform-docker"\u003eDocker\nplatform\u003c/a\u003e and keep the temporary\nfiles:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml --platform docker --keep true\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="combining-run-options-with-script-arguments"\u003eCombining run options with script arguments\u003c/h3\u003e\n\u003cp\u003eThis example runs a component using the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e and passes arguments\nto the script:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml --platform native -- --input=\u0026quot;Hello!\u0026quot; -o=my_file.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="override-a-config-with-config-mods"\u003eOverride a config with config mods\u003c/h3\u003e\n\u003cp\u003eRun a Viash component using a \u003ca href="/docs/advanced/config_mods"\u003econfig mod\u003c/a\u003e\nto override the \u003ca href="/docs/reference_config/config"\u003econfig file\u003c/a\u003e. In this\ncase, pull an image from a docker registry and specify a specific docker\nregistry server URL.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -p docker \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].setup_strategy := \u0026quot;pull\u0026quot;\' \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:11,href:"/docs/creating_pipelines/platform-nextflow/",title:"Creating a Nextflow Pipeline",description:"Developing a pipeline in Nextflow with Viash.",content:'\u003ch2 id="introduction"\u003eIntroduction\u003c/h2\u003e\n\u003ch3 id="pipelines--workflows"\u003ePipelines / Workflows\u003c/h3\u003e\n\u003cp\u003eIt’s possible to \u003cem\u003econvert\u003c/em\u003e a Viash component into a NextFlow module.\nViash uses NextFlow’s DSL2 for this, effectively creating \u003cem\u003emodules\u003c/em\u003e that\ncan be imported in a \u003ccode\u003emain.nf\u003c/code\u003e pipeline definition that deals with the\n\u003cem\u003elogic\u003c/em\u003e of the pipeline rather than the low-level machinery.\u003c/p\u003e\n\u003cp\u003eWhen it comes to this low-level machinery and the way Viash creates a\nmodule, we refer to \u003ca href="https://www.data-intuitive.com/diflow"\u003ethe step-by-step introduction about\nDiFlow\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="parallelization"\u003eParallelization\u003c/h3\u003e\n\u003cp\u003eNextFlow, as any other pipeline platform is able to run tasks in\nparallel if the pipeline logic allows for that. In order to keep\ndifferent parallel branch unique, we add a unique identifier \u003ccode\u003eid\u003c/code\u003e. This\nidentifier can be a sample identifier, or a plate id (sequencing),\nversions of reference files to consider, etc.\u003c/p\u003e\n\u003cp\u003eIn a pipeline, one is often interested in running some computation on\ndifferent datasets, inputs or parts of an input. This means that\nobviously we need to keep track of where the input chunks are located.\nBut more importantly, we can not just simply name an output file because\nmultiple parallel processes might just overwrite each other’s output\nfiles.\u003c/p\u003e\n\u003ch3 id="output-filenames"\u003eOutput Filenames\u003c/h3\u003e\n\u003cp\u003eTherefore, it’s important to keep output files distinct across different\nsteps of the pipeline but also between different parallel runs. In order\nto assure this, a module will define its own output file name. It is\nconstructed from 3 ingredients:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe unique \u003ccode\u003eid\u003c/code\u003e of the data going into the process\u003c/li\u003e\n\u003cli\u003eThe name of the current component/task\u003c/li\u003e\n\u003cli\u003eAn extension\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe extension is derived from the component configuration if a\n\u003ccode\u003edefault: ...\u003c/code\u003e attribute is present for the corresponding output\nargument. If no such default value is provided, the \u003cem\u003ename\u003c/em\u003e of the option\nis used.\u003c/p\u003e\n\u003cp\u003eAs an example, the following argument for a component \u003ccode\u003ecomp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003ename: --log\ntype: file\ndirection: Output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewill result in \u003ccode\u003e\u0026lt;id\u0026gt;.comp.log\u003c/code\u003e, while the following\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003ename: --log\ntype: file\ndirection: Output\ndefault: log.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewill become in \u003ccode\u003e\u0026lt;id\u0026gt;.comp.txt\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe config can define a directory as output as well, it will be named\naccordingly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRemark\u003c/strong\u003e: If the output is a directory, \u003ccode\u003etype: file\u003c/code\u003e should still be\nused, but the corresponding script/code should take care of writing the\ncontent to that directory.\u003c/p\u003e\n\u003ch2 id="tips"\u003eTips\u003c/h2\u003e\n\u003ch3 id="how-to-specify-multiple-inputs"\u003eHow to specify multiple inputs?\u003c/h3\u003e\n\u003cp\u003eIf a component deals with just one input file, that input file should be\nprovided as the second element in the\n\u003ca href="https://www.data-intuitive.com/diflow/"\u003eDiFlow\u003c/a\u003e triplet. In other\nwords, if this is the first component in a (sub)workflow, two options\nare available:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eChannel.fromPath(\u0026lt;...\u0026gt;).map{ file -\u0026gt; [ \u0026lt;id\u0026gt;, file, params ] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eChannel.from(\u0026lt;...\u0026gt;).map{ filename -\u0026gt; [ \u0026lt;id\u0026gt;, file(filename), params ] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is crucial that this second element in the triplet is of type \u003ccode\u003ePath\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf multiple inputs are to be provided corresponding to the same option\nfor the underlying process or tool a \u003ccode\u003eList\u003c/code\u003e of \u003ccode\u003ePath\u003c/code\u003e objects can be\nprovided.\u003c/p\u003e\n\u003cp\u003eFor example, say we ran multiple parallel workflows for a single sample\nand want to join the result of that. The way to express this in NextFlow\nwould be something like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003econcatenate_ = singleSample_ \\\n    | toList \\\n    | map{ it -\u0026gt; [ it.collect{ b -\u0026gt; b[0]}, it.collect{ a -\u0026gt; a[1] }, params ]} \\\n    | concatenate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn other words, we pass a \u003ccode\u003eList\u003c/code\u003e of Path objects to the concatenate\nmodule.\u003c/p\u003e\n\u003cp\u003eIn some cases, multiple input arguments deal with different input files,\nfor instance \u003ccode\u003efastq\u003c/code\u003e files and a reference file for mapping and\ncounting. One can pass this to the concatenation module by means of a\n\u003ccode\u003eMap\u003c/code\u003e. This approach, for instance can be used to merge meta information\n(from a file) to an \u003ccode\u003eh5ad\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003e    singleSample_ = input_ \\\n        ...\n        | combine(meta_) \\\n        | map{ id, output, params, meta -\u0026gt;\n            [ id, [ \u0026quot;input\u0026quot; : output, \u0026quot;meta\u0026quot; : meta ], params ]\n        } \\\n        | annotate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere the \u003ccode\u003emeta_\u003c/code\u003e \u003ccode\u003eChannel\u003c/code\u003e points to the meta file to be used.\u003c/p\u003e\n\u003cp\u003eIn other words, we either provide a \u003ccode\u003eList\u003c/code\u003e of Path values or in the case\nmultiple options take different files we use a \u003ccode\u003eHashMap\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRemark: Be sure to mark the arguments at hand as being of \u003ccode\u003etype: file\u003c/code\u003e\nand \u003ccode\u003edirection: input\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="multiple-outputs"\u003eMultiple outputs\u003c/h2\u003e\n\u003cp\u003eInternally, DiFlow uses a similar approach to keeping track of outputs\nas discussed for inputs. What comes out of a module, however, is\nslightly different. Since a \u003ccode\u003eworkflow\u003c/code\u003e can not emit a multi-channel\nobject, we are forced to put all outputs on the same \u003ccode\u003eChannel\u003c/code\u003e and so we\nuse a \u003ccode\u003eMap\u003c/code\u003e again to distinguish both. This is only done for multiple\noutputs, though.\u003c/p\u003e\n\u003cp\u003eBy means of an example: Say a module outputs one file, then the triplet\nthat is returned from the module looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[ \u0026lt;id\u0026gt;, file, params ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf our tools has two output files, say for instance \u003ccode\u003eoutputfile.txt\u003c/code\u003e and\n\u003ccode\u003elogfile.txt\u003c/code\u003e (as indicated by the command line for the tool that looks\nfor instance like this:\n\u003ccode\u003e.... --output outputfile.txt --log logfile.txt\u003c/code\u003e), we still get one\n\u003ccode\u003eChannel\u003c/code\u003e back, but on that \u003ccode\u003eChannel\u003c/code\u003e there are now two \u003cem\u003eevents\u003c/em\u003e and\nthose look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[ \u0026lt;id\u0026gt;, [ output: outputfile.txt ], params ]\n[ \u0026lt;id\u0026gt;, [ log: logfile.txt ], params ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s up to the receiving end of the module to split this downstream. The\nimplicit workflow defined in all the generated module contains some\nexample code to that, for instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eresult \\\n  | filterOutput \\\n  | view{ \u0026quot;Output for output: \u0026quot; + it[1] }\n\nresult \\\n  | filterLog \\\n  | view{ \u0026quot;Output for log: \u0026quot; + it[1] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere the \u003ccode\u003efilterLog\u003c/code\u003e process for instance is defined like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// A process that filters out output from the output Map\nprocess filterOutput {\n\n  input:\n    tuple val(id), val(input), val(_params)\n  output:\n    tuple val(id), val(output), val(_params)\n  when:\n    input.keySet().contains(\u0026quot;output\u0026quot;)\n  exec:\n    output = input[\u0026quot;output\u0026quot;]\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively, one could also use methods on the \u003ccode\u003eChannel\u003c/code\u003e itself:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eresult \\\n  | filter{ it[1].keySet().contains(\u0026quot;output\u0026quot;) }\n  | map{ [ it[0], it[1][\u0026quot;output\u0026quot;], it[2] ] }\n  | view{ \u0026quot;Output for log: \u0026quot; + it[1] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne more option is to use the \u003ccode\u003ebranch\u003c/code\u003e or \u003ccode\u003emultiMap\u003c/code\u003e \u003ccode\u003eChannel\u003c/code\u003e forking\noperators in NextFlow.\u003c/p\u003e\n\u003ch2 id="access-arguments-from-the-nextflow-cli-v041"\u003eAccess arguments from the \u003ccode\u003enextflow\u003c/code\u003e CLI (\u003ccode\u003ev0.4.1+\u003c/code\u003e)\u003c/h2\u003e\n\u003cp\u003eWe provide a way to access the argument values for all the arguments for\nevery component from the NextFlow CLI. All components store their\nrespective arguments under a component-specific key that corresponds to\nthe component name.\u003c/p\u003e\n\u003cp\u003eFurthermore, the value that will effectively be passed to the process\ndepends on the following attributes for an argument:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003erequired: true/false\ndefault: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument is \u003ccode\u003erequired: true\u003c/code\u003e, it can have\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea \u003ccode\u003edefault: ...\u003c/code\u003e value: It will use this default value on the CLI\nunless you override it on the CLI\u003c/li\u003e\n\u003cli\u003eno default value: In this case, one has to provide a value when\nstarting a NextFlow pipeline. Otherwise Viash will give a warning\nand NXF will throw an error.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf an argument is \u003ccode\u003erequired: false\u003c/code\u003e, it can have\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea default: ...\u003c/code\u003e value: It will use this default value unless you\noverride it from the CLI\u003c/li\u003e\n\u003cli\u003eno default value: In this case, this argument will not be present on\nthe CLI, but it can still be overridden from the CLI\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePlease refer to \u003ca href="https://github.com/viash-io/viash/issues/46"\u003ethis\nissue\u003c/a\u003e for more\ninformation.\u003c/p\u003e\n\u003cp\u003eGiven the above, its possible to override any of these using the\nfollowing scheme:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e--\u0026lt;component_name\u0026gt;__\u0026lt;argument_name\u0026gt; \u0026lt;value\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enextflow run main.nf --filter__threshold 0.2\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:12,href:"/docs/reference_commands/build/",title:"viash build",description:"",content:'\u003cp\u003eBuild an executable from the provided viash config file.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml -o output [-p docker] [-m] [-s]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="config"\u003e–config\u003c/h3\u003e\n\u003cp\u003eA \u003ca href="/docs/reference_config/config"\u003eviash config file\u003c/a\u003e (example:\n\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This argument can also be a script with the config\nas a header.\u003c/p\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e. (default = List())\u003c/p\u003e\n\u003ch3 id="-m-meta"\u003e-m, –meta\u003c/h3\u003e\n\u003cp\u003ePrint out some meta information at the end.\u003c/p\u003e\n\u003ch3 id="-o-output-arg"\u003e-o, –output \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003ePath to directory in which the executable and any resources is built to.\nDefault: “output/”. (default = output/)\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eSpecifies which platform amongst those specified in the \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e to use. If this is not provided,\nthe first platform will be used. If no platforms are defined in the\n\u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="push"\u003e–push\u003c/h3\u003e\n\u003cp\u003eWhether or not to push the container to a Docker registry [\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\nplatform\u003c/a\u003e only].\u003c/p\u003e\n\u003ch3 id="-s-setup"\u003e-s, –setup\u003c/h3\u003e\n\u003cp\u003eWhether or not to set up the platform environment after building the\nexecutable.\u003c/p\u003e\n\u003ch3 id="-w-write_meta"\u003e-w, –write_meta\u003c/h3\u003e\n\u003cp\u003eWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="building-with-no-arguments"\u003eBuilding with no arguments\u003c/h3\u003e\n\u003cp\u003eBuild a Viash component with only the path to the \u003ca href="/docs/reference_config/config"\u003eviash config\nfile\u003c/a\u003e as an argument. This will create an\n‘output’ directory and generate an executable inside it with the first\nplatform defined in in your config. If no platform is found, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e is used:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="specifying-a-platform-and-an-output-folder"\u003eSpecifying a platform and an output folder\u003c/h3\u003e\n\u003cp\u003eThis builds a Viash component based on your \u003ca href="/docs/reference_config/config"\u003eviash config\nfile\u003c/a\u003e in a ‘bin’ folder that will use\nDocker to run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml --platform docker --output \u0026quot;bin\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="using-a-docker-setup-strategy-post-build"\u003eUsing a Docker setup strategy post-build\u003c/h3\u003e\n\u003cp\u003eCreate a build for the Docker platform and afterwards execute a\n\u003ccode\u003e---setup\u003c/code\u003e with a specific \u003ca href="/docs/running/executables-docker"\u003edocker setup\nstrategy\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml -p docker --setup alwaysbuild\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="print-out-meta-information"\u003ePrint out meta information\u003c/h3\u003e\n\u003cp\u003eBuild a Viash component for the native platform and output information\nabout the build in the terminal:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml -p native --meta\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s an example of what the output might look like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash version:      0.5.0\nconfig:             config.vsh.yaml\nplatform:           native\nexecutable:         output/hello_world\noutput:             output/\nremote git repo:    \u0026lt;NA\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="generate-a-meta-file"\u003eGenerate a meta file\u003c/h3\u003e\n\u003cp\u003eThis builds a Viash component and puts a \u003cstrong\u003eviash.yaml\u003c/strong\u003e file next to the\nexecutable containing the full configuration information of the\ncomponent for later reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml --write_meta\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="override-a-config-with-config-mods"\u003eOverride a config with config mods\u003c/h3\u003e\n\u003cp\u003eBuild a Viash component and use a \u003ca href="/docs/advanced/config_mods"\u003econfig\nmod\u003c/a\u003e to override the \u003ca href="/docs/reference_config/config"\u003econfig\nfile\u003c/a\u003e. In this case, pull an image from a\ndocker registry and specify a specific docker registry server URL.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml -p docker \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].setup_strategy := \u0026quot;pull\u0026quot;\' \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/running/executables-docker"\u003eExecutables with a Docker\nbackend\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:13,href:"/docs/reference_commands/test/",title:"viash test",description:"",content:'\u003cp\u003eTest the component using the tests defined in the viash config file.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml [-p docker] [-k true/false]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="config"\u003e–config\u003c/h3\u003e\n\u003cp\u003eA \u003ca href="/docs/reference_config/config"\u003eviash config file\u003c/a\u003e (example:\n\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This argument can also be a script with the config\nas a header.\u003c/p\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e. (default = List())\u003c/p\u003e\n\u003ch3 id="-k-keep-arg"\u003e-k, –keep \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eWhether or not to keep temporary files. By default, files will be\ndeleted if all goes well but remain when an error occurs. By specifying\n–keep true, the temporary files will always be retained, whereas –keep\nfalse will always delete them. The temporary directory can be\noverwritten by setting defining a VIASH_TEMP directory.\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eSpecifies which platform amongst those specified in the \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e to use. If this is not provided,\nthe first platform will be used. If no platforms are defined in the\n\u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="running-a-test-with-no-arguments"\u003eRunning a test with no arguments\u003c/h3\u003e\n\u003cp\u003eTest a Viash component with only the path to the \u003ca href="/docs/reference_config/config"\u003eviash config\nfile\u003c/a\u003e as an argument. This will create a\ntemporary directory in the VIASH_TEMP directory (\u003ccode\u003e/tmp/\u003c/code\u003e by default)\nand copy over any test files that are specified in the \u003ca href="/docs/reference_config/config"\u003eviash config\nfile\u003c/a\u003e.\u003cbr\u003e\nNext, Viash generates an executable inside that directory with the first\nplatform defined in in your config. If no platform is found, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e is used.\u003c/p\u003e\n\u003cp\u003eFinally, Viash will run the test script to do a unit test, with the\nresults being printed out to the terminal.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="test-a-specific-platform"\u003eTest a specific platform\u003c/h3\u003e\n\u003cp\u003eThis runs a test on a component that utilises the Docker backend:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml --platform docker\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="always-keep-temporary-files-after-running-a-test"\u003eAlways keep temporary files after running a test\u003c/h3\u003e\n\u003cp\u003eThe command below runs a test and prevents the deletion of temporary\nfiles. By default, these files are only retained when an error occured.\nSetting \u003ccode\u003ekeep\u003c/code\u003e to \u003ccode\u003efalse\u003c/code\u003e results in the temporary files being deleted\nin all circumstances.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml -p native --keep true\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="override-a-config-with-config-mods"\u003eOverride a config with config mods\u003c/h3\u003e\n\u003cp\u003eTest a Viash component while using a \u003ca href="/docs/advanced/config_mods"\u003econfig\nmod\u003c/a\u003e to override the \u003ca href="/docs/reference_config/config"\u003econfig\nfile\u003c/a\u003e. In this case, pull an image from a\ndocker registry and specify a specific docker registry server URL.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml -p docker \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].setup_strategy := \u0026quot;pull\u0026quot;\' \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:14,href:"/docs/reference_commands/config-view/",title:"viash config view",description:"",content:'\u003cp\u003eView the \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e file after\nparsing.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash config view config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="config"\u003e–config\u003c/h3\u003e\n\u003cp\u003eA \u003ca href="/docs/reference_config/config"\u003eViash config file\u003c/a\u003e (example:\n\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This argument can also be a script with the config\nas a header.\u003c/p\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eSpecifies which platform amongst those specified in the \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e to use. If this is not provided,\nthe first platform will be used. If no platforms are defined in the\n\u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="print-a-viash-config-to-the-terminal"\u003ePrint a Viash config to the terminal\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003econfig view\u003c/code\u003e command prints a \u003cstrong\u003eparsed\u003c/strong\u003e version of a \u003ca href="/docs/reference_config/config"\u003econfig\nfile\u003c/a\u003e to the terminal. This includes all\nfields, even those that were not given values in the config file itself:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash config view config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor the \u003ca href="/examples/hello_world/config.vsh.yaml"\u003ehello_world example config\nfile\u003c/a\u003e, this prints out the\nfollowing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: \u0026quot;hello_world\u0026quot;\n  authors: []\n  arguments:\n  - type: \u0026quot;string\u0026quot;\n    name: \u0026quot;input\u0026quot;\n    alternatives: []\n    required: false\n    direction: \u0026quot;Input\u0026quot;\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: \u0026quot;string\u0026quot;\n    name: \u0026quot;--greeter\u0026quot;\n    alternatives: []\n    default: \u0026quot;Hello world!\u0026quot;\n    required: false\n    direction: \u0026quot;Input\u0026quot;\n    multiple: false\n    multiple_sep: \u0026quot;:\u0026quot;\n  resources:\n  - type: \u0026quot;bash_script\u0026quot;\n    path: \u0026quot;script.sh\u0026quot;\n    is_executable: true\n    parent: \u0026quot;file:///home/user/hello_world/config.vsh.yaml\u0026quot;\n  description: \u0026quot;A very simple \'Hello world\' component.\u0026quot;\n  tests:\n  - type: \u0026quot;bash_script\u0026quot;\n    path: \u0026quot;test.sh\u0026quot;\n    is_executable: true\n    parent: \u0026quot;file:///home/user/hello_world/config.vsh.yaml\u0026quot;\n  info: {}\nplatforms:\n- type: \u0026quot;native\u0026quot;\n  id: \u0026quot;native\u0026quot;\n  setup: []\n- type: \u0026quot;docker\u0026quot;\n  id: \u0026quot;docker\u0026quot;\n  image: \u0026quot;bash:4.0\u0026quot;\n  namespace_separator: \u0026quot;_\u0026quot;\n  resolve_volume: \u0026quot;Automatic\u0026quot;\n  chown: true\n  setup_strategy: \u0026quot;alwayscachedbuild\u0026quot;\n  push_strategy: \u0026quot;pushifnotpresent\u0026quot;\n  privileged: false\n  setup: []\n- type: \u0026quot;docker\u0026quot;\n  id: \u0026quot;alpine\u0026quot;\n  image: \u0026quot;alpine\u0026quot;\n  namespace_separator: \u0026quot;_\u0026quot;\n  resolve_volume: \u0026quot;Automatic\u0026quot;\n  chown: true\n  setup_strategy: \u0026quot;alwayscachedbuild\u0026quot;\n  push_strategy: \u0026quot;pushifnotpresent\u0026quot;\n  privileged: false\n  setup:\n  - type: \u0026quot;apk\u0026quot;\n    packages:\n    - \u0026quot;bash\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="override-a-config-with-config-mods"\u003eOverride a config with config mods\u003c/h3\u003e\n\u003cp\u003ePrints out what a \u003cstrong\u003eparsed\u003c/strong\u003e Viash component config would look like\nwhile using a \u003ca href="/docs/advanced/config_mods"\u003econfig mod\u003c/a\u003e to override the\n\u003ca href="/docs/reference_config/config"\u003econfig file\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash config view config.vsh.yaml \\\n-c \'.platforms[.type == \u0026quot;docker\u0026quot;].setup_strategy := \u0026quot;pull\u0026quot;\' \\\n-c \'.platforms[.type == \u0026quot;docker\u0026quot;].image := \u0026quot;bash:latest\u0026quot;\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:15,href:"/docs/reference_commands/ns-build/",title:"viash ns build",description:"",content:'\u003cp\u003eBuild a namespace from many viash config files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build [-n nmspc] [-s src] [-t target] [-p docker] [--setup] [---push] [--parallel] [--flatten]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="-f-flatten"\u003e-f, –flatten\u003c/h3\u003e\n\u003cp\u003eFlatten the target builds, handy for building one platform to a bin\ndirectory.\u003c/p\u003e\n\u003ch3 id="-l-parallel"\u003e-l, –parallel\u003c/h3\u003e\n\u003cp\u003eWhether or not to run the process in parallel.\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eActs as a regular expression to filter the platform ids specified in the\nfound config files. If this is not provided, all platforms will be used.\nIf no platforms are defined in a config, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="push"\u003e–push\u003c/h3\u003e\n\u003cp\u003eWhether or not to push the container to a Docker registry [\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\nplatform\u003c/a\u003e only].\u003c/p\u003e\n\u003ch3 id="-q-query-arg"\u003e-q, –query \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which components get selected by name and namespace. Can be a\nregex. Example: “^mynamespace/component1$”.\u003c/p\u003e\n\u003ch3 id="query_name-arg"\u003e–query_name \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which components get selected by name. Can be a regex. Example:\n“^component1”.\u003c/p\u003e\n\u003ch3 id="-n-query_namespace-arg"\u003e-n, –query_namespace \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which namespaces get selected by namespace. Can be a regex.\nExample: “^mynamespace$”.\u003c/p\u003e\n\u003ch3 id="setup"\u003e–setup\u003c/h3\u003e\n\u003cp\u003eWhether or not to set up the platform environment after building the\nexecutable.\u003c/p\u003e\n\u003ch3 id="-s-src-arg"\u003e-s, –src \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eA source directory containing viash config files, possibly structured in\na hierarchical folder structure. Default: src/.\u003c/p\u003e\n\u003ch3 id="-t-target-arg"\u003e-t, –target \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eA target directory to build the executables into. Default: target/.\u003c/p\u003e\n\u003ch3 id="-w-write_meta"\u003e-w, –write_meta\u003c/h3\u003e\n\u003cp\u003eWrite out some meta information to RESOURCES_DIR/viash.yaml at the end.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="building-with-no-arguments"\u003eBuilding with no arguments\u003c/h3\u003e\n\u003cp\u003eWhen no arguments are given. All components in a subdirectory named\n\u003cstrong\u003esrc\u003c/strong\u003e are built with all available platforms to a directory named\n\u003cstrong\u003etarget\u003c/strong\u003e. See \u003ca href="/docs/projects/namespaces"\u003eNamespaces\u003c/a\u003e for an overview\nof how you should structure your components for this to work correctly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s the output when running this command with three component that\nsupport the native and docker platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eExporting src/parse_images/ (my_namespace) =native=\u0026gt; target/native/my_namespace/parse_images\nExporting src/parse_images/ (my_namespace) =docker=\u0026gt; target/docker/my_namespace/parse_images\nExporting src/download_files/ (my_namespace) =native=\u0026gt; target/native/my_namespace/download_files\nExporting src/download_files/ (my_namespace) =docker=\u0026gt; target/docker/my_namespace/download_files\nExporting src/render_mp4/ (my_namespace) =native=\u0026gt; target/native/my_namespace/render_mp4\nExporting src/render_mp4/ (my_namespace) =docker=\u0026gt; target/docker/my_namespace/render_mp4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is how the structure of the \u003cstrong\u003etarget\u003c/strong\u003e directory might look like\nafter running this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003etarget\n├── docker\n│   └── my_namespace\n│       ├── download_files\n│       │   └── download_files\n│       ├── parse_images\n│       │   └── parse_images\n│       └── render_mp4\n│           └── render_mp4\n└── native\n    └── my_namespace\n        ├── download_files\n        │   └── download_files\n        ├── parse_images\n        │   └── parse_images\n        └── render_mp4\n            └── render_mp4\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="specifying-a-source-folder-and-a-namespace"\u003eSpecifying a source folder and a namespace\u003c/h3\u003e\n\u003cp\u003eIn order for namespace querying to work, make sure your config files\ninclude a \u003ca href="/docs/reference_config/functionality/#namespace-string"\u003enamespace\nfield\u003c/a\u003e. The\ncommand below searches the \u003cstrong\u003emy_components_dir\u003c/strong\u003e directory for all\nViash components in the \u003cstrong\u003emy_namespace\u003c/strong\u003e namespace and builds them into\nexecutables.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build --src \'my_components_dir\' --query_namespace \'my_namespace\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="filter-a-specific-component-to-build"\u003eFilter a specific component to build\u003c/h3\u003e\n\u003cp\u003eThis builds any Viash components where the name contains “parse”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build --query_name  \u0026quot;parse\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="build-targetting-a-specific-platform-and-an-output-folder"\u003eBuild targetting a specific platform and an output folder\u003c/h3\u003e\n\u003cp\u003eThis builds a Viash namespace for just the \u003ca href="/docs/reference_config/platform-docker"\u003eDocker\nplatform\u003c/a\u003e to a directory named\n\u003cstrong\u003ebuilt_namespace\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build --platform docker --target \u0026quot;built_namespace\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="run-the-build-process-in-parallel"\u003eRun the build process in parallel\u003c/h3\u003e\n\u003cp\u003eBy default, the building of namespaces is a serial process, meaning\nevery components gets built one by one. With the \u003ccode\u003e--parallel\u003c/code\u003e option,\nyou can run the process in parallel, allowing you to build all of the\ncomponents at the same time, potentially saving you a lot of time:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build --parallel\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="flatten-the-output-of-the-build-to-a-single-directory"\u003eFlatten the output of the build to a single directory\u003c/h3\u003e\n\u003cp\u003eBy running the command below, all of the generated executables will be\nput next to each other in a single directory.\u003c/p\u003e\n\u003cp\u003eNote: Make sure to define a platform when using the \u003ccode\u003e--flatten\u003c/code\u003e option,\nthe single directory structure doesn’t group the executables together\nper platform. Without the \u003ccode\u003e--platform\u003c/code\u003e option, executables will be built\nfor every defined platform and written away to a single file per\ncomponent, effectively overwriting the same file over and over again.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build -p native --flatten\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe result is a flat target structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003etarget\n├── download_files\n├── parse_images\n└── render_mp4\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="using-a-docker-setup-strategy-post-build"\u003eUsing a Docker setup strategy post-build\u003c/h3\u003e\n\u003cp\u003eCreate a build for the Docker platform and afterwards execute a\n\u003ccode\u003e---setup\u003c/code\u003e with a specific \u003ca href="/docs/running/executables-docker"\u003edocker setup\nstrategy\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build -p docker --setup alwaysbuild\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="generate-meta-files"\u003eGenerate meta files\u003c/h3\u003e\n\u003cp\u003eThis builds a Viash namespace and puts a \u003cstrong\u003eviash.yaml\u003c/strong\u003e file next to\neach executable containing the full configuration information of the\ncomponent for later reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build --write_meta\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="override-a-namespace-with-config-mods"\u003eOverride a namespace with config mods\u003c/h3\u003e\n\u003cp\u003eBuild a Viash namespace and use a \u003ca href="/docs/advanced/config_mods"\u003econfig\nmod\u003c/a\u003e to override the \u003ca href="/docs/reference_config/config"\u003econfig\nfiles\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns build -p docker \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].setup_strategy := \u0026quot;pull\u0026quot;\' \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].image := \u0026quot;bash:latest\u0026quot;\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/projects/namespaces"\u003eNamespaces\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:16,href:"/docs/reference_commands/ns-test/",title:"viash ns test",description:"",content:'\u003cp\u003eTest a namespace containing many viash config files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test [-n nmspc] [-s src] [-p docker] [--parallel] [--tsv file.tsv] [--append]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="-a-append"\u003e-a, –append\u003c/h3\u003e\n\u003cp\u003eAppend to tsv instead of overwrite\u003c/p\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="-k-keep-arg"\u003e-k, –keep \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eWhether or not to keep temporary files. By default, files will be\ndeleted if all goes well but remain when an error occurs. By specifying\n–keep true, the temporary files will always be retained, whereas –keep\nfalse will always delete them. The temporary directory can be\noverwritten by setting defining a VIASH_TEMP directory.\u003c/p\u003e\n\u003ch3 id="-l-parallel"\u003e-l, –parallel\u003c/h3\u003e\n\u003cp\u003eWhether or not to run the process in parallel.\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eActs as a regular expression to filter the platform ids specified in the\nfound config files. If this is not provided, all platforms will be used.\nIf no platforms are defined in a config, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="-q-query-arg"\u003e-q, –query \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which components get selected by name and namespace. Can be a\nregex. Example: “^mynamespace/component1$”.\u003c/p\u003e\n\u003ch3 id="query_name-arg"\u003e–query_name \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which components get selected by name. Can be a regex. Example:\n“^component1”.\u003c/p\u003e\n\u003ch3 id="-n-query_namespace-arg"\u003e-n, –query_namespace \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which namespaces get selected by namespace. Can be a regex.\nExample: “^mynamespace$”.\u003c/p\u003e\n\u003ch3 id="-s-src-arg"\u003e-s, –src \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eA source directory containing viash config files, possibly structured in\na hierarchical folder structure. Default: src/.\u003c/p\u003e\n\u003ch3 id="-t-tsv-arg"\u003e-t, –tsv \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003ePath to write a summary of the test results to.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="testing-with-no-arguments"\u003eTesting with no arguments\u003c/h3\u003e\n\u003cp\u003eWhen no arguments are given. All components in a subdirectory named\n\u003cstrong\u003esrc\u003c/strong\u003e are tested. This includes testing if a component can be built\nand any tests defined in its \u003ca href="/docs/reference_config/config"\u003econfig\nfile\u003c/a\u003e. See\n\u003ca href="/docs/projects/namespaces"\u003eNamespaces\u003c/a\u003e for an overview of how you\nshould structure your components for this to work correctly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter running this command, a test report is printed to the terminal\nwith the results.\u003c/p\u003e\n\u003ch3 id="specifying-a-source-folder-and-a-namespace"\u003eSpecifying a source folder and a namespace\u003c/h3\u003e\n\u003cp\u003eIn order for namespace querying to work, make sure your config files\ninclude a \u003ca href="/docs/reference_config/functionality/#namespace-string"\u003enamespace\nfield\u003c/a\u003e. The\ncommand below searches the \u003cstrong\u003emy_components_dir\u003c/strong\u003e directory for all\nViash components in the \u003cstrong\u003emy_namespace\u003c/strong\u003e namespace and tests them.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test --src \'my_components_dir\' --query_namespace \'my_namespace\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="filter-a-specific-component-to-test"\u003eFilter a specific component to test\u003c/h3\u003e\n\u003cp\u003eThis tests any Viash components where the name contains “parse”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test --query_name  \u0026quot;parse\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="test-a-specific-platform"\u003eTest a specific platform\u003c/h3\u003e\n\u003cp\u003eThis runs a test on all components that utilises the Docker backend:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test --platform docker\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="run-the-tests-in-parallel"\u003eRun the tests in parallel\u003c/h3\u003e\n\u003cp\u003eBy default, the testing of namespaces is a serial process, meaning every\ncomponents gets tested one by one. With the \u003ccode\u003e--parallel\u003c/code\u003e option, you can\nrun the process in parallel, allowing you to test all of the components\nat the same time, potentially saving you a lot of time:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test --parallel\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="save-the-test-results-in-a-file"\u003eSave the test results in a file\u003c/h3\u003e\n\u003cp\u003eYou can export the test results to a tab-seperated values (TSV) file\nwith the \u003ccode\u003e--tsv\u003c/code\u003e option. In the example below, a file named\n\u003cstrong\u003ereport.tsv\u003c/strong\u003e gets generated.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns test --tsv \u0026quot;report.tsv\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/projects/namespaces"\u003eNamespaces\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:17,href:"/docs/reference_commands/ns-list/",title:"viash ns list",description:"",content:'\u003cp\u003eList a namespace containing many viash config files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns list [-n nmspc] [-s src] [-p docker] [--tsv file.tsv]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments"\u003eArguments\u003c/h2\u003e\n\u003ch3 id="-c-config_mod-arg"\u003e-c, –config_mod \u003carg\u003e…\u003c/h3\u003e\n\u003cp\u003eModify a \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e at runtime using\na \u003ca href="/docs/advanced/config_mods"\u003ecustom DSL\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="-k-keep-arg"\u003e-k, –keep \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eWhether or not to keep temporary files. By default, files will be\ndeleted if all goes well but remain when an error occurs. By specifying\n–keep true, the temporary files will always be retained, whereas –keep\nfalse will always delete them. The temporary directory can be\noverwritten by setting defining a VIASH_TEMP directory.\u003c/p\u003e\n\u003ch3 id="-l-parallel"\u003e-l, –parallel\u003c/h3\u003e\n\u003cp\u003eWhether or not to run the process in parallel.\u003c/p\u003e\n\u003ch3 id="-p-platform-arg"\u003e-p, –platform \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eActs as a regular expression to filter the platform ids specified in the\nfound config files. If this is not provided, all platforms will be used.\nIf no platforms are defined in a config, the \u003ca href="/docs/reference_config/platform-native"\u003enative\nplatform\u003c/a\u003e will be used. In\naddition, the path to a platform yaml file can also be specified.\u003c/p\u003e\n\u003ch3 id="-q-query-arg"\u003e-q, –query \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which components get selected by name and namespace. Can be a\nregex. Example: “^mynamespace/component1$”.\u003c/p\u003e\n\u003ch3 id="query_name-arg"\u003e–query_name \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which components get selected by name. Can be a regex. Example:\n“^component1”.\u003c/p\u003e\n\u003ch3 id="-n-query_namespace-arg"\u003e-n, –query_namespace \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eFilter which namespaces get selected by namespace. Can be a regex.\nExample: “^mynamespace$”.\u003c/p\u003e\n\u003ch3 id="-s-src-arg"\u003e-s, –src \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003eA source directory containing viash config files, possibly structured in\na hierarchical folder structure. Default: src/.\u003c/p\u003e\n\u003ch3 id="-t-tsv-arg"\u003e-t, –tsv \u003carg\u003e\u003c/h3\u003e\n\u003cp\u003ePath to write a summary of the list results to.\u003c/p\u003e\n\u003ch3 id="-h-help"\u003e-h, –help\u003c/h3\u003e\n\u003cp\u003eShow help message\u003c/p\u003e\n\u003ch2 id="examples"\u003eExamples\u003c/h2\u003e\n\u003ch3 id="list-a-namespace-without-arguments"\u003eList a namespace without arguments\u003c/h3\u003e\n\u003cp\u003eWhen no arguments are given, the \u003ccode\u003ens list\u003c/code\u003e command prints a \u003cstrong\u003eparsed\u003c/strong\u003e\nversion of all \u003ca href="/docs/reference_config/config"\u003econfig files\u003c/a\u003e in a\nsubdirectory named \u003cstrong\u003esrc\u003c/strong\u003e to the terminal. This includes all fields,\neven those that were not given values in the config file itself.\u003cbr\u003e\nSee \u003ca href="/docs/projects/namespaces"\u003eNamespaces\u003c/a\u003e for an overview of how you\nshould structure your components for this to work correctly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter running this command, you’ll see a list similar to this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e- functionality:\n    name: \u0026quot;download_files\u0026quot;\n    namespace: \u0026quot;my_namespace\u0026quot;\n    authors: []\n    arguments:\n    - type: \u0026quot;string\u0026quot;\n      name: \u0026quot;url\u0026quot;\n      alternatives: []\n      required: false\n      direction: \u0026quot;Input\u0026quot;\n      multiple: true\n      multiple_sep: \u0026quot; \u0026quot;\n    - type: \u0026quot;string\u0026quot;\n      name: \u0026quot;--filter\u0026quot;\n      alternatives: []\n      required: false\n      direction: \u0026quot;Input\u0026quot;\n      multiple: false\n      multiple_sep: \u0026quot;:\u0026quot;\n    resources:\n    - type: \u0026quot;bash_script\u0026quot;\n      path: \u0026quot;script.sh\u0026quot;\n      is_executable: true\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="specifying-a-source-folder-and-a-namespace"\u003eSpecifying a source folder and a namespace\u003c/h3\u003e\n\u003cp\u003eIn order for namespace querying to work, make sure your config files\ninclude a \u003ca href="/docs/reference_config/functionality/#namespace-string"\u003enamespace\nfield\u003c/a\u003e. The\ncommand below searches the \u003cstrong\u003emy_components_dir\u003c/strong\u003e directory for all\nViash components in the \u003cstrong\u003emy_namespace\u003c/strong\u003e namespace and prints out the\nconfig information to the terminal.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns list --src \'my_components_dir\' -n \'my_namespace\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="filter-a-specific-component-to-list"\u003eFilter a specific component to list\u003c/h3\u003e\n\u003cp\u003eThis lists any Viash components where the name contains “parse”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns list --query_name  \u0026quot;parse\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="override-a-namespace-with-config-mods"\u003eOverride a namespace with config mods\u003c/h3\u003e\n\u003cp\u003eList a Viash namespace and use a \u003ca href="/docs/advanced/config_mods"\u003econfig\nmod\u003c/a\u003e to override the \u003ca href="/docs/reference_config/config"\u003econfig\nfiles\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash ns list -p docker \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].setup_strategy := \u0026quot;pull\u0026quot;\' \\\n  -c \'.platforms[.type == \u0026quot;docker\u0026quot;].image := \u0026quot;bash:latest\u0026quot;\'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="see-also"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config"\u003eConfig file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/advanced/config_mods"\u003eDynamic Config Modding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-native"\u003eNative platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/platform-docker"\u003eDocker platform\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/projects/namespaces"\u003eNamespaces\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:18,href:"/docs/reference_config/config/",title:"Config File",description:"",content:'\u003ch1 id="the-viash-config-file"\u003eThe Viash config file\u003c/h1\u003e\n\u003cp\u003eA Viash config file describes the behaviour of a script and the platform\nit runs on. It consists of two main sections: \u003ccode\u003efunctionality\u003c/code\u003e and\n\u003ccode\u003eplatforms\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href="/docs/reference_config/functionality/"\u003efunctionality\u003c/a\u003e section\ndescribes the core functionality of the component, such as its inputs,\noutputs, arguments, and extra resources. For each of the arguments,\nspecifying a description and a set of argument restrictions help create\na useful command-line interface. To ensure that your component works as\nexpected, writing one or more tests is essential.\u003c/p\u003e\n\u003cp\u003eThe platforms section specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native/"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eUsually, the config file is accompanied by a script which contains the\nactual code for the component.\u003c/p\u003e\n\u003cp\u003eOnly a small example of a Viash config file is shown below, but check\nout the more detailed documentation regarding the\n\u003ca href="/docs/reference_config/functionality/"\u003efunctionality\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-native/"\u003eNative\nplatform\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\nplatform\u003c/a\u003e, and the \u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\nplatform\u003c/a\u003e for the full\nspecifications for each of these subsections.\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: addrowlines\n  description: Add rowlines to a text file.\n  arguments:\n  - name: input                           \n    type: file\n    description: The input file.\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: nextflow\n    image: bash:4.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ecat -n $par_input\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe component can be executed as follows.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- config.vsh.yaml | head -5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e     1  functionality:\n     2    name: addrowlines\n     3    description: Add rowlines to a text file.\n     4    arguments:\n     5    - name: input                           \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWould you rather use Docker as a backend? Easy as pie!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -P docker config.vsh.yaml -- config.vsh.yaml | head -5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eUnable to find image \'addrowlines:latest\' locally\ndocker: Error response from daemon: pull access denied for addrowlines, repository does not exist or may require \'docker login\': denied: requested access to the resource is denied.\nSee \'docker run --help\'.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eAdd rowlines to a text file.\n\nOptions:\n    file\n        type: file\n        The input file.\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:19,href:"/docs/reference_config/functionality/",title:"Functionality",description:"The functionality-part of the config file describes the behaviour of the script in terms of arguments and resources.",content:'\u003cp\u003eBy specifying a few restrictions (e.g. mandatory arguments) and adding\nsome descriptions, Viash will automatically generate a stylish\ncommand-line interface for you.\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eAn example of such a functionality yaml can be found below, each part of\nwhich is explained in more depth in the following sections.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: exe\n  namespace: my_namespace\n  version: \u0026quot;1.0.0\u0026quot;\n  description: |\n    This component performs function Y and Z.\n    It is possible to make this a multiline string.\n  arguments:\n    - name: --input\n      type: file\n      direction: input\n      alternatives: [-i]\n      description: Input file(s)\n      default: input.txt\n      must_exist: true\n      required: false\n      multiple: true\n      multiple_sep: \u0026quot;,\u0026quot;\n    - name: --output                           \n      type: file\n      direction: output\n      alternatives: [-o]\n      description: Output file\n      default: output.txt\n      required: true\n      multiple: false\n  resources:\n    - type: bash_script\n      path: script.sh\n    - path: additional_resource.txt\n  tests:\n    - type: bash_script\n      path: tests/first_unit_test.sh\n    - type: r_script\n      path: tests/second_unit_test.R\n    - path: tests/test_resource.txt\n  authors:\n    - name: Bob Cando\n      roles: [maintainer, author]\n      email: bob@can.do\n      props: {github: bobcando, orcid: 0000-0001-0002-0003}\n    - name: Tim Farbe\n      roles: [author]\n      email: tim@far.be\n  info:\n    foo: bar\n    custom_tag: custom_value\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="name-string"\u003ename [string]\u003c/h2\u003e\n\u003cp\u003eName of the component and the filename of the executable when built with\n\u003ccode\u003eviash build\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003ename: exe\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="namespace-string"\u003enamespace [string]\u003c/h2\u003e\n\u003cp\u003eNamespace this component is a part of. This is required when grouping\ncomponents together in a pipeline and building multiple components at\nonce using \u003ccode\u003eviash ns build\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003enamespace: fancy_components\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="version-string"\u003eversion [string]\u003c/h2\u003e\n\u003cp\u003eVersion of the component. This field will be used to version the\nexecutable and the Docker container.\u003c/p\u003e\n\u003ch2 id="description-string"\u003edescription [string]\u003c/h2\u003e\n\u003cp\u003eA description of the component. This will be displayed with \u003ccode\u003e--help\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003edescription: |\n  This component performs function Y and Z.\n  It is possible to make this a multiline string.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments-list"\u003earguments [list]\u003c/h2\u003e\n\u003cp\u003eA list of arguments for this component. For each argument, a type and a\nname must be specified. Depending on the type of argument, different\nproperties can be set. Common properties for all argument types are the\nfollowing.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etype: string/file/integer/double/boolean/boolean_true/boolean_false\u003c/code\u003e,\nthe type of argument determining to what object type the value will\nbe cast in the downstream scripts.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edirection: input/output\u003c/code\u003e, the directionality of the argument. Only\nneeds to be specified for output files. Default: “input”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ename: --foo\u003c/code\u003e, the name of the argument. Can also be \u003ccode\u003e-foo\u003c/code\u003e or\n\u003ccode\u003efoo\u003c/code\u003e. The number of dashes determines how values can be passed:\n\u003cul\u003e\n\u003cli\u003ewith \u003ccode\u003e--foo\u003c/code\u003e: long option, e.g. \u003ccode\u003eexe --foo=bar\u003c/code\u003e or\n\u003ccode\u003eexe --foo bar\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ewith \u003ccode\u003e-foo\u003c/code\u003e: short option, e.g. \u003ccode\u003eexe -foo bar\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ewith \u003ccode\u003efoo\u003c/code\u003e: argument, e.g. \u003ccode\u003eexe bar\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ealternatives: [-f]\u003c/code\u003e, list of alternative names. Typically only used\nto provide a short alternative option.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edescription: Description of foo\u003c/code\u003e, a description of the argument.\nMultiline descriptions are supported.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefault: bar\u003c/code\u003e, the default value when no argument value is\nprovided. Not allowed when \u003ccode\u003erequired: true\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequired: true/false\u003c/code\u003e, whether the argument is required. If true\nand the functionality is executed, an error will be produced if no\nvalue is provided. Default = false.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultiple: true/false\u003c/code\u003e, whether to treat the argument value as an\narray or not. Arrays can be passed using the delimiter \u003ccode\u003e--foo=1:2:3\u003c/code\u003e\nor by providing the same argument multiple times \u003ccode\u003e--foo 1 --foo 2\u003c/code\u003e.\nDefault = false.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultiple_sep: \u0026quot;:\u0026quot;\u003c/code\u003e, the delimiter for providing multiple values.\nDefault = “:”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn types: * \u003ccode\u003etype: string\u003c/code\u003e, The value passed through an argument of\nthis type is converted to an ‘str’ object in Python, and to a\n‘character’ object in R. * \u003ccode\u003etype: integer\u003c/code\u003e, The resulting value is an\n‘int’ in Python and an ‘integer’ in R. * \u003ccode\u003etype: double\u003c/code\u003e, The resulting\nvalue is a ‘float’ in Python and an ‘double’ in R. * \u003ccode\u003etype: boolean\u003c/code\u003e,\nThe resulting value is a ‘bool’ in Python and a ‘logical’ in R. *\n\u003ccode\u003etype: boolean_true/boolean_false\u003c/code\u003e, Arguments of this type can only be\nused by providing a flag \u003ccode\u003e--foo\u003c/code\u003e or not. The resulting value is a ‘bool’\nin Python and a ‘logical’ in R. These properties cannot be altered:\nrequired is false, default is undefined, multiple is false. *\n\u003ccode\u003etype: file\u003c/code\u003e, The resulting value is still an ‘str’ in Python and a\n‘character’ in R. In order to correctly pass files in some platforms\n(e.g. Docker and Nextflow), Viash needs to know which arguments are\ninput/output files. Additional property values: -\n\u003ccode\u003emust_exist: true/false\u003c/code\u003e, denotes whether the file or folder should\nexist at the start of the execution.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e- name: --foo                           \n  type: file\n  alternatives: [-f]\n  description: Description of foo\n  default: \u0026quot;/foo/bar\u0026quot;\n  must_exist: true\n  required: false\n  multiple: true\n  multiple_sep: \u0026quot;,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="resources-list"\u003eresources [list]\u003c/h2\u003e\n\u003cp\u003eThe first resource should be a script (\u003ccode\u003ebash_script\u003c/code\u003e, \u003ccode\u003er_script\u003c/code\u003e,\n\u003ccode\u003epython_script\u003c/code\u003e, \u003ccode\u003ejavascript_script\u003c/code\u003e, \u003ccode\u003escala_script\u003c/code\u003e) which is what will\nbe executed when the functionality is run. Additional resources will be\ncopied to the same directory.\u003c/p\u003e\n\u003cp\u003eCommon properties:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etype: file/r_script/python_script/bash_script/javascript_script/scala_script\u003c/code\u003e,\nthe type of resource. The first resource cannot be of type \u003ccode\u003efile\u003c/code\u003e.\nWhen the type is not specified, the default type is simply \u003ccode\u003efile\u003c/code\u003e.\nFor more information regarding how to write a script in Bash, R or\nPython with Viash, check out the guides for the respective languages\non the left.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ename: filename\u003c/code\u003e, the resulting name of the resource.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epath: path/to/file\u003c/code\u003e, the path of the input file. Can be a relative\nor an absolute path, or a URI.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etext: ...multiline text...\u003c/code\u003e, the raw content of the input file.\nExactly one of \u003ccode\u003epath\u003c/code\u003e or \u003ccode\u003etext\u003c/code\u003e must be defined, the other\nundefined.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis_executable: true/false\u003c/code\u003e, whether the resulting file is made\nexecutable.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eresources:\n  - type: r_script\n    path: script.R\n  - type: file\n    path: resource1.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="tests-list"\u003etests [list]\u003c/h2\u003e\n\u003cp\u003eOne or more Bash/R/Python scripts to be used to test the component\nbehaviour when \u003ccode\u003eviash test\u003c/code\u003e is invoked. Additional files of type \u003ccode\u003efile\u003c/code\u003e\nwill be made available only during testing. Each test script should\nexpect no command-line inputs, be platform-independent, and return an\nexit code \u0026gt;0 when unexpected behaviour occurs during testing.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003etests:\n  - type: bash_script\n    path: tests/test1.sh\n  - type: r_script\n    path: tests/test2.R\n  - path: resource1.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="authors-list"\u003eauthors [list]\u003c/h2\u003e\n\u003cp\u003eA list of authors (introduced in Viash 0.3.1). An author must at least\nhave a name, but can also have a list of roles, an e-mail address, and a\nmap of custom properties.\u003c/p\u003e\n\u003cp\u003eSuggested values for roles are:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eRole\u003c/th\u003e\n\u003cth\u003eAbbrev.\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003emaintainer\u003c/td\u003e\n\u003ctd\u003emnt\u003c/td\u003e\n\u003ctd\u003efor the maintainer of the code. Ideally, exactly one maintainer is specified.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eauthor\u003c/td\u003e\n\u003ctd\u003eaut\u003c/td\u003e\n\u003ctd\u003efor persons who have made substantial contributions to the software.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003econtributor\u003c/td\u003e\n\u003ctd\u003ectb\u003c/td\u003e\n\u003ctd\u003efor persons who have made smaller contributions (such as code patches).\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003edatacontributor\u003c/td\u003e\n\u003ctd\u003edtc\u003c/td\u003e\n\u003ctd\u003efor persons or organisations that contributed data sets for the software\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ecopyrightholder\u003c/td\u003e\n\u003ctd\u003ecph\u003c/td\u003e\n\u003ctd\u003efor all copyright holders. This is a legal concept so should use the legal name of an institution or corporate body.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003efunder\u003c/td\u003e\n\u003ctd\u003efnd\u003c/td\u003e\n\u003ctd\u003efor persons or organizations that furnished financial support for the development of the software\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eThe \u003ca href="https://www.loc.gov/marc/relators/relaterm.html"\u003efull list of\nroles\u003c/a\u003e is extremely\ncomprehensive.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eauthors:\n  - name: Bob Cando\n    roles: [maintainer, author]\n    email: bob@can.do\n    props: {github: bobcando, orcid: 0000-0001-0002-0003}\n  - name: Tim Farbe\n    roles: [author]\n    email: tim@far.be\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="info-list"\u003einfo [list]\u003c/h2\u003e\n\u003cp\u003eA map for storing custom annotation (introduced in Viash 0.4.0).\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003einfo:\n  foo: bar\n  custom_tag: custom_value\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:20,href:"/docs/reference_config/platform-native/",title:"Native Platform",description:"Running a Viash component on a native platform means that the script will be executed in your current environment.",content:'\u003cp\u003eAny dependencies are assumed to have been installed by the user, so the\nnative platform is meant for developers (who know what they’re doing) or\nfor simple bash scripts (which have no extra dependencies).\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eAn example of a native platform yaml can be found below, each part of\nwhich is explained in more depth in the following sections.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eplatforms:\n  - type: native\n    id: native_platform\n    version: \u0026quot;1.0.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="id-string"\u003eid [string]\u003c/h2\u003e\n\u003cp\u003eAs with all platforms, you can give a platform a different name. By\nspecifying \u003ccode\u003eid: foo\u003c/code\u003e, you can target this platform (only) by specifying\n\u003ccode\u003e-p foo\u003c/code\u003e in any of the Viash commands.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eid: foo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="version-string"\u003eversion [string]\u003c/h2\u003e\n\u003cp\u003eThe version of the platform specifications. Has no significant impact\nwhen using the native platform.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eversion: \u0026quot;0.1.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:21,href:"/docs/reference_config/platform-docker/",title:"Docker Platform",description:"Run a Viash component on a Docker backend platform.",content:'\u003cp\u003eBy specifying which dependencies your component needs, users will be\nable to build a docker container from scratch using the setup flag, or\npull it from a docker repository.\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eAn example of a docker platform yaml can be found below, each part of\nwhich is explained in more depth in the following sections.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e- type: docker\n  id: custom_platform_name\n  image: bash:4.0\n  version: \u0026quot;0.1.0\u0026quot;\n  target_image: myorganisation/example_docker\n  chown: true\n  port: [80, 8080]\n  workdir: /app\n  setup:\n    - type: docker\n      build_args: \n        - GITHUB_PAT=\u0026quot;$GITHUB_PAT\u0026quot;\n    - type: apt\n      packages:\n        - imagemagick\n    - type: r\n      cran:\n        - tidyverse\n        - dynutils\n    - type: docker\n      run: \n        - \u0026quot;git clone https://github.com/data-intuitive/randpy.git\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="id-string"\u003eid [string]\u003c/h2\u003e\n\u003cp\u003eAs with all platforms, you can give a platform a different name. By\nspecifying \u003ccode\u003eid: foo\u003c/code\u003e, you can target this platform (only) by specifying\n\u003ccode\u003e-p foo\u003c/code\u003e in any of the Viash commands.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eid: foo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="version-string"\u003eversion [string]\u003c/h2\u003e\n\u003cp\u003eThe version of the platform specifications. This will automatically be\nused as a tag for the target docker image name.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eversion: \u0026quot;0.1.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="image-string"\u003eimage [string]\u003c/h2\u003e\n\u003cp\u003eThe base container to start from.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eimage: \u0026quot;bash:4.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="target_image-string"\u003etarget_image [string]\u003c/h2\u003e\n\u003cp\u003eIf anything is specified in the \u003ccode\u003esetup\u003c/code\u003e section, running the \u003ccode\u003e---setup\u003c/code\u003e\nwill result in a container with the name of \u003ccode\u003e\u0026lt;target_image\u0026gt;:\u0026lt;version\u0026gt;\u003c/code\u003e.\nIf nothing is specified in the \u003ccode\u003esetup\u003c/code\u003e section, simply \u003ccode\u003eimage\u003c/code\u003e will be\nused.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003etarget_image: myfoo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="chown-boolean"\u003echown [boolean]\u003c/h2\u003e\n\u003cp\u003eIn Linux, files created by a Docker container will be owned by \u003ccode\u003eroot\u003c/code\u003e.\nWith \u003ccode\u003echown: true\u003c/code\u003e, Viash will automatically change the ownership of\noutput files (arguments with \u003ccode\u003etype: file\u003c/code\u003e and \u003ccode\u003edirection: output\u003c/code\u003e) to\nthe user running the Viash command after execution of the component.\nDefault value: \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003echown: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="port-list-of-strings"\u003eport [list of strings]\u003c/h2\u003e\n\u003cp\u003eA list of enabled ports. This doesn’t change the Dockerfile but gets\nadded as a command-line argument at runtime.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eport:\n  - 80\n  - 8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="workdir-string"\u003eworkdir [string]\u003c/h2\u003e\n\u003cp\u003eThe working directory when starting the container. This doesn’t change\nthe Dockerfile but gets added as a command-line argument at runtime.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eworkdir: /home/user\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="setup-list"\u003esetup [list]\u003c/h2\u003e\n\u003cp\u003eA list of requirements for installing apt, apk, R, Python, JavaScript\npackages or specifying other Docker setup instructions. The order in\nwhich these dependencies are specified determines the order in which\nthey will be installed.\u003c/p\u003e\n\u003ch3 id="r-requirements-list"\u003eR requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which R packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ \'devtools::install(\u0026quot;.\u0026quot;)\' ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="python-requirements-list"\u003ePython requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which Python packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="javascript-requirements-list"\u003eJavaScript requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which JavaScript packages should be available in order to run\nthe component.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: javascript\n    npm: [ packagename ]\n    git: [ https://... ]\n    github: [ owner/repository ]\n    url: [ https://... ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="aptitude-requirements-list"\u003eAptitude requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which apt packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: apt\n    packages: [ sl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="alpine-requirements-list"\u003eAlpine requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which apk packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: apk\n    packages: [ sl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="docker-requirements-list"\u003eDocker requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which Docker commands should be run during setup.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    resources: \n      - resource.txt /path/to/resource.txt\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:22,href:"/docs/reference_config/platform-nextflow/",title:"Nextflow Platform",description:"Run a Viash component as a Nextflow module.",content:'\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eThis is an example of a NextFlow platform definition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e...\nplatforms:\n  ...\n  - type: nextflow\n    publish: true       # default = false\n    per_id: false       # default = true\n    label: highmem\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="id-string"\u003eid [string]\u003c/h2\u003e\n\u003cp\u003eEvery platform can be given a specific \u003ccode\u003eid\u003c/code\u003e that can later be referred\nto explicitly when running or building the Viash component.\u003c/p\u003e\n\u003ch2 id="image-string-tagversion-string-and-registry-string"\u003eimage [string], tag/version [string] and registry [string]\u003c/h2\u003e\n\u003cp\u003eIf no image attributes are configured, Viash will use the auto-generated\nimage name from the Docker platform:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[\u0026lt;namespace\u0026gt;/]\u0026lt;name\u0026gt;:\u0026lt;version\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s possible to specify the container image explicitly with which to\nrun the module in different ways:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eimage: dataintuitive/viash:0.4.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExactly the same can be obtained with\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eimage: dataintuitive/viash\nregistry: index.docker.io/v1/\ntag: 0.4.0      # or alternatively: version: 0.4.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSpecifying the attribute(s) like this will use the container\n\u003ccode\u003edataintuitive/viash:0.4.0\u003c/code\u003e from Docker hub (registry).\u003c/p\u003e\n\u003cp\u003eIf no tag/version is specified Viash will use \u003ccode\u003efunctionality.version\u003c/code\u003e as\nthe version/tag.\u003c/p\u003e\n\u003cp\u003eIf no registry is specified, Viash (and NextFlow) will assume the image\nis available locally or on Docker Hub. In other words, the\n\u003ccode\u003eregistry: ...\u003c/code\u003e attribute above is superfluous. No other registry is\nchecked automatically due to a limitation from Docker itself.\u003c/p\u003e\n\u003ch2 id="publish-boolean"\u003epublish [boolean]\u003c/h2\u003e\n\u003cp\u003eNextFlow uses the autogenerated \u003ccode\u003ework\u003c/code\u003e dirs to manage process IO under\nthe hood. In order effectively \u003cem\u003eoutput\u003c/em\u003e something one can \u003cem\u003epublish\u003c/em\u003e the\nresults a module or step in the pipeline. In order to do this, add\n\u003ccode\u003epublish: true\u003c/code\u003e to the config:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epublish\u003c/code\u003e is optional\u003c/li\u003e\n\u003cli\u003eDefault value is \u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis attribute simply defines if output of a component should be\npublished yes or no. The output location has to be provided at pipeline\nlaunch by means of the option \u003ccode\u003e--publishDir ...\u003c/code\u003e or as\n\u003ccode\u003eparams.publishDir\u003c/code\u003e in \u003ccode\u003enextflow.config\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eparams.publishDir = \u0026quot;...\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="per_id-boolean"\u003eper_id [boolean]\u003c/h2\u003e\n\u003cp\u003eBy default, a subdirectory is created corresponding to the unique ID\nthat is passed in the triplet. Let us illustrate this with an example.\nThe following code snippet uses the value of \u003ccode\u003e--input\u003c/code\u003e as an input of a\nworkflow. The input can include a wildcard so that multiple samples can\nrun in parallel. We use the parent directory name\n(\u003ccode\u003e.getParent().baseName\u003c/code\u003e) as an identifier for the sample. We pass this\nas the first entry of the triplet:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eChannel.fromPath(params.input) \\\n    | map{ it -\u0026gt; [ it.getParent().baseName , it ] } \\\n    | map{ it -\u0026gt; [ it[0] , it[1], params ] }\n    | ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSay the resulting sample names are \u003ccode\u003eSAMPLE1\u003c/code\u003e and \u003ccode\u003eSAMPLE2\u003c/code\u003e. The next\nstep in the pipeline will be published (at least by default) under:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;publishDir\u0026gt;/SAMPLE1/\n\u0026lt;publishDir\u0026gt;/SAMPLE2/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese per-ID subdirectories can be avoided by setting:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eper_id: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="path-string"\u003epath [string]\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003epublish: true\u003c/code\u003e, this attribute defines where the output is written\n\u003cem\u003erelative\u003c/em\u003e to the \u003ccode\u003eparams.publishDir\u003c/code\u003e setting. For example,\n\u003ccode\u003epath: processed\u003c/code\u003e in combination with \u003ccode\u003e--output s3://some_bucket/\u003c/code\u003e will\nstore the output of this component under\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es3://some_bucket/processed/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis attribute gives control over the directory structure of the output.\nFor example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003epath: raw_data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr even:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003epath: raw_data/bcl\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease note that \u003ccode\u003eper_id\u003c/code\u003e and \u003ccode\u003epath\u003c/code\u003e can be combined.\u003c/p\u003e\n\u003ch2 id="label-string--labels-list-of-strings"\u003elabel [string] / labels [list of strings]\u003c/h2\u003e\n\u003cp\u003eWhen running the module in a cluster context and depending on the\ncluster type, \u003ca href="https://www.nextflow.io/docs/latest/process.html#label"\u003eNextFlow allows for attaching\nlabels\u003c/a\u003e to the\nprocess that can later be used as selectors for associating resources to\nthis process.\u003c/p\u003e\n\u003cp\u003eIn order to attach one label to a process/component, one can use the\n\u003ccode\u003elabel: ...\u003c/code\u003e attribute, multiple labels can be added using\n\u003ccode\u003elabels: [ ..., ... ]\u003c/code\u003e and the two can even be mixed.\u003c/p\u003e\n\u003cp\u003eIn the main \u003ccode\u003enextflow.config\u003c/code\u003e, one can now use this label:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprocess {\n  ...\n  withLabel: bigmem {\n     maxForks = 5\n     ...\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="stageinmode-string"\u003estageInMode [string}\u003c/h2\u003e\n\u003cp\u003eBy default NextFlow will create a symbolic link to the inputs for a\nprocess/module and run the tool at hand using those symbolic links. Some\napplications do not cope well with this strategy, in that case the files\nshould effectively be copied rather than linked to. This can be achieved\nby using \u003ccode\u003estageInMode: copy\u003c/code\u003e…\u003c/p\u003e\n\u003cp\u003eThis attribute is optional, the default is \u003ccode\u003esymlink\u003c/code\u003e.\u003c/p\u003e\n'},{id:23,href:"/docs/help/frequently_asked_questions/",title:"Frequently Asked Questions",description:"Frequently Asked Questions",content:'\u003ch3 id="running-components"\u003eRunning Components\u003c/h3\u003e\n\u003ch4 id="one-or-more-of-my-output-files-are-owned-by-root-after-running-a-component-why-is-this"\u003eOne or more of my output files are owned by root after running a component. Why is this?\u003c/h4\u003e\n\u003cp\u003eIn Linux, files created by Docker are owned by root by default.\u003cbr\u003e\nYou can \u003ca href="/docs/reference_config/platform-docker/#chown-boolean"\u003eset up the chown\nattribute\u003c/a\u003e in\nyour config file to automatically transfer the ownership of files to the\nuser running the component. Any file output where an argument of the\ntype file with an output direction was used will also have their\nownership transferred.\u003c/p\u003e\n'},{id:24,href:"/docs/running/executables-docker/",title:"Executables With a Docker Backend",description:"",content:'\u003ch2 id="docker-setup-strategies"\u003eDocker setup strategies\u003c/h2\u003e\n\u003ch3 id="alwaysbuild--build"\u003ealwaysbuild / build\u003c/h3\u003e\n\u003cp\u003ebuild the image from the dockerfile (DEFAULT)\u003c/p\u003e\n\u003ch3 id="alwayscachedbuild--cachedbuild"\u003ealwayscachedbuild / cachedbuild\u003c/h3\u003e\n\u003cp\u003ebuild the image from the dockerfile, with caching\u003c/p\u003e\n\u003ch3 id="alwayspull--pull"\u003ealwayspull / pull\u003c/h3\u003e\n\u003cp\u003epull the image from a registry\u003c/p\u003e\n\u003ch3 id="alwayspullelsebuild--pullelsebuild"\u003ealwayspullelsebuild / pullelsebuild\u003c/h3\u003e\n\u003cp\u003etry to pull the image from a registry, else build it\u003c/p\u003e\n\u003ch3 id="alwayspullelsecachedbuild--pullelsecachedbuild"\u003ealwayspullelsecachedbuild / pullelsecachedbuild\u003c/h3\u003e\n\u003cp\u003etry to pull the image from a registry, else build it with caching\u003c/p\u003e\n\u003ch3 id="ifneedbebuild"\u003eifneedbebuild\u003c/h3\u003e\n\u003cp\u003eif the image does not exist locally, build the image\u003c/p\u003e\n\u003ch3 id="ifneedbecachedbuild"\u003eifneedbecachedbuild:\u003c/h3\u003e\n\u003cp\u003eif the image does not exist locally, build the image with caching\u003c/p\u003e\n\u003ch3 id="ifneedbepull"\u003eifneedbepull\u003c/h3\u003e\n\u003cp\u003eif the image does not exist locally, pull the image\u003c/p\u003e\n\u003ch3 id="ifneedbepullelsebuild"\u003eifneedbepullelsebuild\u003c/h3\u003e\n\u003cp\u003eif the image does not exist locally, pull the image else build it\u003c/p\u003e\n\u003ch3 id="ifneedbepullelsecachedbuild"\u003eifneedbepullelsecachedbuild\u003c/h3\u003e\n\u003cp\u003eif the image does not exist locally, pull the image else build it with\ncaching\u003c/p\u003e\n\u003ch3 id="donothing--meh"\u003edonothing / meh\u003c/h3\u003e\n\u003cp\u003edo not build or pull anything\u003c/p\u003e\n\u003ch3 id="build--b"\u003ebuild / b\u003c/h3\u003e\n\u003ch3 id="cachedbuild--cb"\u003ecachedbuild / cb\u003c/h3\u003e\n\u003ch3 id="pull--p"\u003epull / p\u003c/h3\u003e\n\u003ch3 id="push"\u003epush\u003c/h3\u003e\n\u003ch3 id="pushifnotpresent"\u003epushifnotpresent\u003c/h3\u003e\n'},{id:25,href:"/docs/contributing/guidelines/",title:"Contributing Guidelines",description:"Guidelines for contributing to Viash",content:'\u003cp\u003eWe welcome any contributions to this project, be it changes in\ndocumentation, bug fixes, new functionality, or even new packages if\nthey fit the scope of our project.\u003cbr\u003e\nBy participating in this project, you agree to abide by our \u003ca href="/docs/contributing/conduct/"\u003ecode of\nconduct\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="contributing-to-viash"\u003eContributing to Viash\u003c/h2\u003e\n\u003ch3 id="help-others"\u003eHelp others\u003c/h3\u003e\n\u003cp\u003eA great way of contributing is helping others by providing answers and\nsuggestions on \u003ca href="https://github.com/viash-io/viash/issues"\u003etheir issues\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="test-new-releases"\u003eTest new releases\u003c/h3\u003e\n\u003cp\u003eWe release new versions of Viash periodically that introduce\nimprovements, features and bug fixes. Before releasing a production\nrelease, we have beta and release candidates available.\u003cbr\u003e\nYou can contribute by using one of the aforementioned releases and\nreporting (and fixing) any bugs you encounter.\u003c/p\u003e\n\u003ch3 id="report-bugs"\u003eReport bugs\u003c/h3\u003e\n\u003cp\u003eIdeally, bug reports are accompanied by a proposed code change to fix\nthe bug. This isn’t always possible, as those who discover a bug may not\nhave the experience to fix it.\u003cbr\u003e\nBug reports are only useful however if they include enough information\nto understand, isolate and ideally reproduce the bug.\u003c/p\u003e\n\u003cp\u003eWhen submitting a bug report, add the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA clear description of the bug.\u003c/li\u003e\n\u003cli\u003eThe exact steps needed to reproduce the bug.\u003c/li\u003e\n\u003cli\u003eInclude a file or an example if needed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="review-changes"\u003eReview changes\u003c/h3\u003e\n\u003cp\u003eChanges proposed via pull requests are public, so anyone can see and\ncomment on the changes.\u003cbr\u003e\nYou can make suggestions here and point out problems, as small as typos\nor issues of style.\u003c/p\u003e\n\u003ch3 id="report-documentation-issues-and-suggestions"\u003eReport documentation issues and suggestions\u003c/h3\u003e\n\u003cp\u003eThe documentation you are reading now is hosted on our \u003ca href="https://github.com/viash-io/viash_web"\u003eViash web\nrepository\u003c/a\u003e. If you encounter any\ngaps in our documentation or you have spotted a mistake, you can help us\nout by \u003ca href="https://github.com/viash-io/viash_web/issues/"\u003ecreating an\nissue\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="contributing-code-changes-to-viash"\u003eContributing code changes to Viash\u003c/h2\u003e\n\u003cp\u003eIf you’re familiar with Scala and have learned how Viash works, you can\nhelp with the development of Viash by improving its code.\u003c/p\u003e\n\u003ch3 id="getting-started"\u003eGetting started\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMake sure you have a \u003ca href="https://github.com/signup/free"\u003eGitHub\naccount\u003c/a\u003e. If you are not familar\nwith git and GitHub, take a look at \u003ca href="https://guides.github.com/introduction/git-handbook/"\u003ethe Git\nHandbook\u003c/a\u003e to\nget started.\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://github.com/viash-io/viash/issues"\u003eSubmit an issue\u003c/a\u003e for your\nproblem or suggestion, assuming one does not already exist.\u003c/li\u003e\n\u003cli\u003eClearly describe your issue, including steps to reproduce when it is\na bug, or some justification for a proposed improvement.\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://github.com/viash-io/viash/network/members"\u003eFork the\nrepository\u003c/a\u003e on\nGitHub to make a copy of the repository on your account.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="making-changes"\u003eMaking changes\u003c/h3\u003e\n\u003cp\u003eHere are some helpful tips to make the development cycle easier:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eViash is written primarily in \u003ca href="https://www.scala-lang.org/"\u003eScala\u003c/a\u003e.\nYou’re free to choose what IDE to use for development. \u003ca href="https://www.jetbrains.com/idea/"\u003eIntelliJ\nIdea\u003c/a\u003e is a good choice.\u003c/li\u003e\n\u003cli\u003eWhile editing the files, save often and make commits of logical\nunits where every commits indicates a single concept.\u003c/li\u003e\n\u003cli\u003eMake sure to \u003ca href="https://chris.beams.io/posts/git-commit/"\u003ewrite good commit\nmessages\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eIf you need help or guidance, post an update on \u003ca href="https://github.com/viash-io/viash/issues"\u003eyour\nissue\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="submit-your-changes"\u003eSubmit your changes\u003c/h3\u003e\n\u003cp\u003eBefore opening a pull request, make sure you review and agree with the\nguidelines below:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs the change important and ready enough to ask the community to\nspend time reviewing?\u003c/li\u003e\n\u003cli\u003eHave you searched for \u003ca href="https://github.com/viash-io/viash/pulls"\u003eexisting, related pull\nrequests\u003c/a\u003e?\u003c/li\u003e\n\u003cli\u003eIs the change being proposed clearly explained and motivated?\u003c/li\u003e\n\u003cli\u003eWhen you contribute code, you affirm that the contribution is your\noriginal work and that you license the work to the project under the\nproject’s open source license. Whether or not you state this\nexplicitly, by submitting any copyrighted material via pull request,\nemail, or other means you agree to license the material under the\nproject’s open source license and warrant that you have the legal\nauthority to do so.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo submit your changes, push to your fork and \u003ca href="https://github.com/viash-io/viash/pulls"\u003esubmit a pull\nrequest\u003c/a\u003e.\u003cbr\u003e\nFrom this point on, you are waiting for us to review and comment on your\npull request. We try to do this within a few days and may suggest\nimprovements or ask for clarification.\u003c/p\u003e\n'},{id:26,href:"/docs/contributing/conduct/",title:"Code of Conduct",description:"Contributor Covenant Code of Conduct",content:'\u003ch2 id="our-pledge"\u003eOur Pledge\u003c/h2\u003e\n\u003cp\u003eWe as members, contributors, and leaders pledge to make participation in\nour community a harassment-free experience for everyone, regardless of\nage, body size, visible or invisible disability, ethnicity, sex\ncharacteristics, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance,\nrace, religion, or sexual identity and orientation.\u003c/p\u003e\n\u003cp\u003eWe pledge to act and interact in ways that contribute to an open,\nwelcoming, diverse, inclusive, and healthy community.\u003c/p\u003e\n\u003ch2 id="our-standards"\u003eOur Standards\u003c/h2\u003e\n\u003cp\u003eExamples of behavior that contributes to a positive environment for our\ncommunity include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDemonstrating empathy and kindness toward other people\u003c/li\u003e\n\u003cli\u003eBeing respectful of differing opinions, viewpoints, and experiences\u003c/li\u003e\n\u003cli\u003eGiving and gracefully accepting constructive feedback\u003c/li\u003e\n\u003cli\u003eAccepting responsibility and apologizing to those affected by our\nmistakes, and learning from the experience\u003c/li\u003e\n\u003cli\u003eFocusing on what is best not just for us as individuals, but for the\noverall community\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExamples of unacceptable behavior include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe use of sexualized language or imagery, and sexual attention or\nadvances of any kind\u003c/li\u003e\n\u003cli\u003eTrolling, insulting or derogatory comments, and personal or\npolitical attacks\u003c/li\u003e\n\u003cli\u003ePublic or private harassment\u003c/li\u003e\n\u003cli\u003ePublishing others’ private information, such as a physical or email\naddress, without their explicit permission\u003c/li\u003e\n\u003cli\u003eOther conduct which could reasonably be considered inappropriate in\na professional setting\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="enforcement-responsibilities"\u003eEnforcement Responsibilities\u003c/h2\u003e\n\u003cp\u003eCommunity leaders are responsible for clarifying and enforcing our\nstandards of acceptable behavior and will take appropriate and fair\ncorrective action in response to any behavior that they deem\ninappropriate, threatening, offensive, or harmful.\u003c/p\u003e\n\u003cp\u003eCommunity leaders have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other\ncontributions that are not aligned to this Code of Conduct, and will\ncommunicate reasons for moderation decisions when appropriate.\u003c/p\u003e\n\u003ch2 id="scope"\u003eScope\u003c/h2\u003e\n\u003cp\u003eThis Code of Conduct applies within all community spaces, and also\napplies when an individual is officially representing the community in\npublic spaces. Examples of representing our community include using an\nofficial e-mail address, posting via an official social media account,\nor acting as an appointed representative at an online or offline event.\u003c/p\u003e\n\u003ch2 id="enforcement"\u003eEnforcement\u003c/h2\u003e\n\u003cp\u003eInstances of abusive, harassing, or otherwise unacceptable behavior may\nbe reported to the community leaders responsible for enforcement at\n[\u003ca href="mailto:info@viash.io"\u003einfo@viash.io\u003c/a\u003e]. All complaints will be reviewed and investigated\npromptly and fairly.\u003c/p\u003e\n\u003cp\u003eAll community leaders are obligated to respect the privacy and security\nof the reporter of any incident.\u003c/p\u003e\n\u003ch2 id="enforcement-guidelines"\u003eEnforcement Guidelines\u003c/h2\u003e\n\u003cp\u003eCommunity leaders will follow these Community Impact Guidelines in\ndetermining the consequences for any action they deem in violation of\nthis Code of Conduct:\u003c/p\u003e\n\u003ch3 id="1-correction"\u003e1. Correction\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: Use of inappropriate language or other behavior\ndeemed unprofessional or unwelcome in the community.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A private, written warning from community leaders,\nproviding clarity around the nature of the violation and an explanation\nof why the behavior was inappropriate. A public apology may be\nrequested.\u003c/p\u003e\n\u003ch3 id="2-warning"\u003e2. Warning\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: A violation through a single incident or series of\nactions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, for a specified period of\ntime. This includes avoiding interactions in community spaces as well as\nexternal channels like social media. Violating these terms may lead to a\ntemporary or permanent ban.\u003c/p\u003e\n\u003ch3 id="3-temporary-ban"\u003e3. Temporary Ban\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: A serious violation of community standards,\nincluding sustained inappropriate behavior.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No\npublic or private interaction with the people involved, including\nunsolicited interaction with those enforcing the Code of Conduct, is\nallowed during this period. Violating these terms may lead to a\npermanent ban.\u003c/p\u003e\n\u003ch3 id="4-permanent-ban"\u003e4. Permanent Ban\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior, harassment of an\nindividual, or aggression toward or disparagement of classes of\nindividuals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A permanent ban from any sort of public interaction\nwithin the community.\u003c/p\u003e\n\u003ch2 id="attribution"\u003eAttribution\u003c/h2\u003e\n\u003cp\u003eThis Code of Conduct is adapted from the \u003ca href="https://www.contributor-covenant.org"\u003eContributor\nCovenant\u003c/a\u003e, version 2.0, available\nat\n\u003ca href="https://www.contributor-covenant.org/version/2/0/code_of_conduct.html"\u003ehttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCommunity Impact Guidelines were inspired by \u003ca href="https://github.com/mozilla/diversity"\u003eMozilla’s code of conduct\nenforcement ladder\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor answers to common questions about this code of conduct, see the FAQ\nat \u003ca href="https://www.contributor-covenant.org/faq"\u003ehttps://www.contributor-covenant.org/faq\u003c/a\u003e. Translations are\navailable at \u003ca href="https://www.contributor-covenant.org/translations"\u003ehttps://www.contributor-covenant.org/translations\u003c/a\u003e.\u003c/p\u003e\n'},{id:27,href:"/docs/advanced/",title:"Advanced Topics",description:"Advanced topics",content:""},{id:28,href:"/docs/running/",title:"Running Components",description:"Running Components",content:""},{id:29,href:"/docs/showcases/",title:"Showcases",description:"Showcases",content:""},{id:30,href:"/docs/contributing/",title:"Contributing",description:"Contributing",content:""},{id:31,href:"/docs/creating_components/",title:"Creating Components",description:"Creating Components",content:""},{id:32,href:"/docs/creating_pipelines/",title:"Creating Pipelines",description:"Creating Pipelines",content:""},{id:33,href:"/docs/getting_started/",title:"Getting Started",description:"Getting Started",content:"\u003cp\u003eContent\u003c/p\u003e\n"},{id:34,href:"/docs/help/",title:"Help",description:"Help",content:""},{id:35,href:"/docs/reference_commands/",title:"Reference: Commands",description:"Reference: Commands",content:""},{id:36,href:"/docs/reference_config/",title:"Reference: Config",description:"Reference: Config",content:""},{id:37,href:"/docs/",title:"Docs",description:"viash documentation",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()