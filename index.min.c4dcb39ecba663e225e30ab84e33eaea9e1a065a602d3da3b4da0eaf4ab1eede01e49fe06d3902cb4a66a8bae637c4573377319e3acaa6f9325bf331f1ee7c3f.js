var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/docs/contributing/contributing_guidelines/",title:"Contributing Guidelines",description:"Contributing Guidelines",content:'\u003ch2 id="to-do"\u003eto do.\u003c/h2\u003e\n'},{id:1,href:"/docs/prologue/introduction/",title:"Introduction",description:"viash helps you turn a script (Bash/R/Python/Scala/JavaScript) into a reusable component.",content:'\u003c!-- TODO: What is viash if you would describe it in one or two sentences?\nviash is a ... --\u003e\n\u003cp\u003eBy providing some meta-data regarding its functionality and the platform\non which you want to run the software, viash can help you:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWrap your script in an executable with a CLI and \u003ccode\u003e--help\u003c/code\u003e\nfunctionality.\u003c/li\u003e\n\u003cli\u003eSeamlessly execute your component natively on the host platform or\nin a \u003cstrong\u003eDocker\u003c/strong\u003e container.\u003c/li\u003e\n\u003cli\u003eCombine multiple components in a \u003cstrong\u003eNextflow\u003c/strong\u003e pipeline.\u003c/li\u003e\n\u003cli\u003eUnit-test your component to ensure that it works at all times.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="example-use-cases"\u003eExample use cases\u003c/h2\u003e\n\u003cp\u003eHere are a few use cases which serve as motivation for viash:\u003c/p\u003e\n\u003c!-- TODO: Rewrite use cases, the reason why viash helps in those situations should be crystal clear to someone that has never seen viash before, this part of the docs is presented before the installation after all. Ideally each of these should have "viash can help here by../In this case, viash can.../etc." --\u003e\n\u003cul\u003e\n\u003cli\u003eYou want to combine several tools in a pipeline and every tool has\nspecific requirements on how they should be run. Even worse: some\nrequirements might directly conflict with each other.\u003c/li\u003e\n\u003cli\u003eYour next data analysis project is very similar to the previous\nproject, so you copy and paste the source code. Unfortunately, you\ndetect a bug in some of your code, so now you need to go back and\nfix the same bug in all the different projects.\u003c/li\u003e\n\u003cli\u003eYou want to look back at a data analysis you performed two years\nago. Unfortunately, the software you used back then is not supported\nanymore, or the newest version produces totally different results.\nWith viash you can package the older version together with its\ndependencies in an executable so you don’t have to worry about\nconflicts or deprecated versions\u003c/li\u003e\n\u003cli\u003eYou developed a \u003ca href="https://jupyter.org/"\u003eJupyter\u003c/a\u003e notebook report for\na data analysis. You wish to share it with your colleague, only to\nspend two hours installing your \u003ca href="https://docs.conda.io/"\u003eConda\u003c/a\u003e\nstack on their laptop.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="getting-started"\u003eGetting started\u003c/h2\u003e\n\u003cp\u003eHere are some links to get you started with viash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/installation"\u003eInstalling viash\u003c/a\u003e: This guide walks\nyou through the steps to install viash on your machine.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/hello_world_bash"\u003eRunning your first component\n(Bash)\u003c/a\u003e: Get a feel for viash with\na classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial, written in Bash.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/hello_world_python"\u003eRunning your first component\n(Python)\u003c/a\u003e: Get a feel for viash\nwith a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial, written in Python.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/hello_world_r"\u003eRunning your first component (R)\u003c/a\u003e:\nGet a feel for viash with a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial,\nwritten in R.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="documentation"\u003eDocumentation\u003c/h2\u003e\n\u003cp\u003eOnce you understand how viash works and what it could do for you, take a\nlook at our docs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/reference_commands/run/"\u003eviash run command\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/reference_config/config/"\u003eConfig files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/help/frequently_asked_questions/"\u003eFrequently asked questions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCheck out the navigation menu on the left for more in-depth information\nabout each topic.\u003c/p\u003e\n'},{id:2,href:"/docs/prologue/installation/",title:"Installation",description:"Installation requirements and instructions.",content:'\u003ch2 id="supported-operating-systems"\u003eSupported Operating Systems\u003c/h2\u003e\n\u003cp\u003eYou can run viash on the following operating systems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003emacOS\u003c/li\u003e\n\u003cli\u003eWindows using \u003ca href="https://docs.microsoft.com/en-us/windows/wsl/install-win10"\u003eWindows Subsystem for\nLinux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eviash is developed in \u003ca href="https://www.scala-lang.org/"\u003eScala 2.12\u003c/a\u003e, so\nyou’ll need an \u003ca href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html"\u003eOracle Java SE Runtime Environment 8\ninstallation\u003c/a\u003e\nor OpenJDK in order to use it.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="installing-viash"\u003eInstalling viash\u003c/h2\u003e\n\u003ch3 id="packaged-release"\u003ePackaged release\u003c/h3\u003e\n\u003cp\u003eTo install viash, download the \u003ca href="https://github.com/viash-io/viash/releases/latest"\u003elatest\nrelease\u003c/a\u003e and save it\nto the \u003ccode\u003e~/bin\u003c/code\u003e folder or any other directory that is specified your\n\u003ccode\u003e$PATH\u003c/code\u003e variable. To verify what directories are included, run this\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eecho $PATH\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="installing-viash-to-bin"\u003eInstalling viash to ~/bin\u003c/h4\u003e\n\u003cp\u003eIn order to add \u003ccode\u003e~/bin\u003c/code\u003e to your $PATH, you need to edit \u003ccode\u003e~/.bashrc\u003c/code\u003e and\nadd the following line to the end of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eexport PATH=\u0026quot;$HOME/bin:$PATH\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can use nano for this for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003enano ~/.bashrc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, create a \u003ccode\u003e~/bin\u003c/code\u003e folder, reload $PATH, download the latest release\nof viash to \u003ccode\u003e~/bin\u003c/code\u003e and add executable permissions to viash. Here’s a\none-liner command that does this for you:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emkdir ~/bin ; source ~/.bashrc \u0026amp;\u0026amp;\nwget \u0026quot;https://github.com/viash-io/viash/releases/latest/download/viash\u0026quot; -O ~/bin/viash \u0026amp;\u0026amp;\nchmod +x ~/bin/viash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="installing-viash-to-usrbin"\u003eInstalling viash to /usr/bin\u003c/h4\u003e\n\u003cp\u003eIf you wish to install viash to your usr/bin folder instead, run the\nfollowing command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003esudo wget \u0026quot;https://github.com/viash-io/viash/releases/latest/download/viash\u0026quot; -O /usr/bin/viash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:3,href:"/docs/prologue/supported_languages/",title:"Supported languages",description:"You can use several programming languages with viash to write your own components.",content:'\u003cp\u003eTo get started with your preferred language, take a look at the language\nspecific examples below.\u003c/p\u003e\n\u003ch2 id="bash"\u003eBash\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/hello_world_bash"\u003eBash Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for Bash.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e: This\ntutorial explains how to create your own viash component from\nscratch using a Bash script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="python"\u003ePython\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/hello_world_python"\u003ePython Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for Python.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/python"\u003eCreating a Python component\u003c/a\u003e:\nThis tutorial explains how to create your own viash component from\nscratch using a Python script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="r"\u003eR\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/prologue/hello_world_r"\u003eR Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for R.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/r"\u003eCreating an R component\u003c/a\u003e: This\ntutorial explains how to create your own viash component from\nscratch using an R script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="scala"\u003eScala\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="javascript"\u003eJavascript\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="c"\u003eC\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n'},{id:4,href:"/docs/prologue/hello_world_bash/",title:"Hello World (Bash)",description:"We have provided a simple **Hello World** component as an introduction to viash. Follow the steps below to learn how to run a component and get a result back from it.",content:'\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/prologue/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="https://viash.io/examples/hello_world/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: bash_script\n    path: script.sh\n  tests:\n  - type: bash_script\n    path: test.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world/script.sh"\u003e\u003ccode\u003escript.sh\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small Bash script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e## VIASH START\npar_input=\u0026quot;I am debug!\u0026quot;\npar_greeter=\u0026quot;Hello world!\u0026quot;\n## VIASH END\n\necho $par_greeter $par_input\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nand adding the \u003ccode\u003epar_\u003c/code\u003e prefix, their values will automatically be\nreplaced at runtime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. The component creating tutorials on the\nleft include an example.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/docs/reference_config/platform-native/"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:5,href:"/docs/prologue/hello_world_python/",title:"Hello World (Python)",description:"We have provided a simple **Hello World** component as an introduction to viash. Follow the steps below to learn how to run a component and get a result back from it.",content:'\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/prologue/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://www.python.org/downloads"\u003einstallation of python 3\u003c/a\u003e. You\nmay have to install the \u003ccode\u003epython-is-python3\u003c/code\u003e package on Ubuntu and\nits derivatives to make Python 3 the default version.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world_py/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="https://viash.io/examples/hello_world_py/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world_py\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: python_script\n    path: script.py\n  tests:\n  - type: python_script\n    path: test.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;python:3.8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world_py/script.py"\u003e\u003ccode\u003escript.py\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small Python script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003e## VIASH START\npar = {\n  \u0026quot;input\u0026quot;: [\u0026quot;I am debug!\u0026quot;],\n  \u0026quot;greeter\u0026quot;: \u0026quot;Hello world!\u0026quot;\n}\n\n## VIASH END\n\nif par[\u0026quot;input\u0026quot;] is None:\n  par[\u0026quot;input\u0026quot;] = []\n\nprint(par[\u0026quot;greeter\u0026quot;], *par[\u0026quot;input\u0026quot;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nin a \u003ccode\u003epar\u003c/code\u003e dictionary. Their values will automatically be replaced at\nruntime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. The component creating tutorials on the\nleft include an example.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/docs/reference_config/platform-native/"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- Mike. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, Mike.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world_py\u003c/strong\u003e in a (new)\nfolder named \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world_py NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:6,href:"/docs/prologue/hello_world_r/",title:"Hello World (R)",description:"We have provided a simple **Hello World** component as an introduction to viash. Follow the steps below to learn how to run a component and get a result back from it.",content:'\u003ch1 id="hello-world"\u003eHello world\u003c/h1\u003e\n\u003cp\u003eWe have provided a simple \u003cstrong\u003eHello World\u003c/strong\u003e component as an introduction\nto viash. Follow the steps below to learn how to run a component and get\na result back from it.\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/prologue/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://cran.r-project.org/mirrors.html"\u003einstallation of the R software\nenvironment\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world_r/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world! \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow Does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="https://viash.io/examples/hello_world_r/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world_r\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: r_script\n    path: script.R\n  tests:\n  - type: r_script\n    path: test.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;rocker/tidyverse:4.0.4\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world_r/script.R"\u003e\u003ccode\u003escript.R\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small R script which prints\nout two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-r"\u003e## VIASH START\npar \u0026lt;- list(\n  input = \u0026quot;I am debug!\u0026quot;,\n  greeter = \u0026quot;Hello world!\u0026quot;\n)\n\n## VIASH END\n\ncat(par$greeter, \u0026quot; \u0026quot;, paste(par$input, collapse = \u0026quot; \u0026quot;), \u0026quot;\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nin a \u003ccode\u003epar\u003c/code\u003e list. Their values will automatically be replaced at runtime\nwith parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. The component creating tutorials on the\nleft include an example.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/docs/reference_config/platform-native/"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- Mike. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, Mike.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world_r\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world_r NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:7,href:"/docs/creating_components/bash/",title:"Creating a Bash component",description:"Developing a new viash component.",content:'\u003cp\u003eIn this tutorial, you’ll create a component that does the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtract all hyperlinks from a markdown file\u003c/li\u003e\n\u003cli\u003eCheck if every URL is reachable\u003c/li\u003e\n\u003cli\u003eCreate a text report with the results\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe component will be able to run locally and as a docker container. In\norder to create a component you need two files: a script for the\nfunctionality and a config file that describes the component.\u003c/p\u003e\n\u003cp\u003eThe files used in this tutorial can be found here:\u003c/p\u003e\n\u003cp\u003e\u003ca href="https://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker"\u003ehttps://github.com/viash-io/viash_web/tree/main/static/examples/md_url_checker\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/docs/prologue/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://www.docker.com/"\u003eDocker\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://curl.se/"\u003ecURL\u003c/a\u003e. Install this via your\npackage manager if you don’t have it installed yet.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe recommend you take a look at the \u003ca href="/docs/prologue/hello_world_bash"\u003ehello world\nexample\u003c/a\u003e first to understand how\ncomponents work.\u003c/p\u003e\n\u003ch2 id="write-a-script-in-bash"\u003eWrite a script in bash\u003c/h2\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case a bash script.\u003cbr\u003e\nCreate a new folder named \u003cstrong\u003emy_viash_component\u003c/strong\u003e and open it. Now\ncreate a new file named \u003cstrong\u003escript.sh\u003c/strong\u003e in there and add this code as its\ncontent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/usr/bin/env bash\n\n### 1 ###\n\n## VIASH START\n\npar_inputfile=\u0026quot;Testfile.md\u0026quot;\npar_domain=\u0026quot;https://viash.io\u0026quot;\npar_output=\u0026quot;output.txt\u0026quot;\n\n## VIASH END\n\namount_of_errors=0\n\necho \u0026quot;Extracting URLs\u0026quot;\n\n### 2 ###\n\n# Extract the titles and URLs from the markdown file with sed and put them into arrays\nreadarray -t title_array \u0026lt;\u0026lt;\u0026lt;$(sed -rn \'s@^.*\\[(.*)\\]\\((.*)\\).*$@\\1@p\' $par_inputfile)\nreadarray -t url_array \u0026lt;\u0026lt;\u0026lt;$(sed -rn \'s@^.*\\[(.*)\\]\\((.*)\\).*$@\\2@p\' $par_inputfile)\n\n# Get length of array\namount_of_urls=$(echo \u0026quot;${#url_array[@]}\u0026quot;)\n\necho \u0026quot;Checking $amount_of_urls URLs\u0026quot;\n\n# Clear file\n\u0026gt;$par_output\n\n### 3 ###\n\n# Iterate over the array of titles and check each URL\nfor ((n = 0; n \u0026lt; ${#title_array[*]}; n++)); do\n    title=\u0026quot;${title_array[n]}\u0026quot;\n    url=\u0026quot;${url_array[n]}\u0026quot;\n\n    ### 4 ###\n\n    # If an URL doesn\'t start with \'http\', add the domain before it\n    if [[ $url != http* ]]; then\n        url=\u0026quot;$par_domain${url_array[n]}\u0026quot;\n    fi\n\n    echo \u0026quot;$(($n + 1)): $url\u0026quot;\n\n    echo -e \u0026quot;Link name: $title\u0026quot; \u0026gt;\u0026gt;$par_output\n    echo -e \u0026quot;URL: $url\u0026quot; \u0026gt;\u0026gt;$par_output\n\n    ### 5 ###\n\n    # Do a cURL and get the status code from the last response after following any redirects\n    status_code=$(curl -ILs --max-redirs 5 $url | tac | grep -m1 HTTP)\n    expected_code=\u0026quot;200\u0026quot;\n\n    # Check if status code obtained via cURL contains the expected code\n    if [[ $status_code == *$expected_code* ]]; then\n        echo \u0026quot;OK\u0026quot;\n        echo -e \u0026quot;Status: OK, can be reached.\u0026quot; \u0026gt;\u0026gt;$par_output\n    else\n        echo $status_code\n        echo -e \u0026quot;Status: ERROR! URL cannot be reached. Status code: $status_code\u0026quot; \u0026gt;\u0026gt;$par_output\n        amount_of_errors=$(($amount_of_errors + 1))\n    fi\n\n    echo -e \u0026quot;---\u0026quot; \u0026gt;\u0026gt;$par_output\ndone\n\necho \u0026quot;\u0026quot;\necho \u0026quot;$par_inputfile has been checked and a report named $par_output has been generated.\n$amount_of_errors of $amount_of_urls URLs could not be resolved.\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the numbered comments scattered about looking like \u003ccode\u003e### x ###\u003c/code\u003e,\nhere’s a breakdown of the code:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe variables are placed between \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e\nfor debugging purposes, their final values will be dynamically\ngenerated by viash once the script is turned into a component. If\nyou want to skip the testing of your script, you can leave these out\nand viash will create variables based on the configuration file.\nThere are three variables:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epar_inputfile\u003c/code\u003e: The markdown file that needs to be parsed.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_domain\u003c/code\u003e: The domain URL that gets inserted before any\nrelative URLs. For example, “/documentation/intro” could be\nreplaced with “\u003ca href="https://my-website/documentation/intro"\u003ehttps://my-website/documentation/intro\u003c/a\u003e” to\ncreate a valid URL.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_output\u003c/code\u003e: The path of the output text file that will contain\nthe report.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe script parses the markdown file and extracts the hyperlink\ntitles and URLs using some nifty\n\u003ca href="https://www.gnu.org/software/sed/manual/sed.html"\u003esed\u003c/a\u003e regex. It\nthen puts those strings into two arrays for later use.\u003c/li\u003e\n\u003cli\u003eStart a for-loop to iterate the title array.\u003c/li\u003e\n\u003cli\u003eAny relative URLs (or those that don’t start with “http” at least)\nwill get the domain added before it.\u003c/li\u003e\n\u003cli\u003ecURL is used to check for a response from the URL. The resulting\nstatus code is stored and compared to the expected code. The results\nget written to the terminal and the report.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id="test-the-script"\u003eTest the script\u003c/h2\u003e\n\u003cp\u003eBefore turning the script into a component, it’s a good idea to test if\nit actually works as expected.\u003cbr\u003e\nAs the script expects a markdown file with hyperlinks, create a new file\nin the script folder named \u003cstrong\u003eTestfile.md\u003c/strong\u003e and paste in the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-markdown"\u003e# Test File\n\nThis is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.\nSome links to websites:\n\n- [Google](https://www.google.com)\n- [Reddit](https://www.reddit.com)\n- [A broken link](http://microsoft.com/random-link)\n\nLinks that are relative to [viash.io](http://www.viash.io):\n\n- You can [install viash here](/docs/prologue/installation).\n- It all starts with a script and a [config file](/docs/reference_config/config) for your components.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow open a terminal in the folder and execute the following command to\nmake your script executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003echmod +x ./script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, run the script by executing this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe script will now show the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExtracting URLs\nChecking 6 URLs\n1: https://www.google.com\nOK\n2: https://www.reddit.com\nOK\n3: http://microsoft.com/random-link\nHTTP/2 404 \n4: http://www.viash.io\nOK\n5: https://viash.io/docs/prologue/installation\nOK\n6: https://viash.io/docs/reference_config/config\nOK\n\nTestfile.md has been checked and a report named output.txt has been generated.\n1 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you get this same output, that means the script is working as\nintended! Feel free to take a peek at the generated \u003cstrong\u003eoutput.txt\u003c/strong\u003e file\nas well. You might have noticed you didn’t have to provide any\narguments, that’s because the values are hard-coded into the script for\ndebugging purposes.\u003c/p\u003e\n\u003cp\u003eNow the script has been tested, it’s time to create a config file to\ndescribe the component based on it.\u003c/p\u003e\n\u003ch2 id="describe-the-component-using-yaml"\u003eDescribe the component using YAML\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eviash config file\u003c/strong\u003e is a \u003ca href="https://yaml.org/"\u003eYAML\u003c/a\u003e file that\ndescribes the behavior and supported platforms of a viash component.\nCreate new file named \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e and paste the following\ntemplate inside of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: NAME\n  description: DESCRIPTION\n  arguments:                     \n  - type: string\n    name: --input\n    description: INPUT DESCRIPTION\n  resources:\n  - type: LANGUAGE_script\n    path: SCRIPT\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery config file requires these two dictionaries:\n\u003ca href="/docs/prologue/hello_world_bash/#functionality"\u003efunctionality\u003c/a\u003e and\n\u003ca href="/docs/prologue/hello_world_bash/#platforms"\u003eplatforms\u003c/a\u003e. This bare-bones\nconfig file makes it easy to “fill in the blanks” for this example. For\nmore information about config files, you can take a look at the\n\u003cstrong\u003eReference: Config\u003c/strong\u003e section on the left.\u003c/p\u003e\n\u003cp\u003eLet’s start off by defining the functionality of our component.\u003c/p\u003e\n\u003ch3 id="defining-the-functionality"\u003eDefining the functionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e dictionary describes what the component does and\nthe resources it needs to do so. The first key is \u003cstrong\u003ename\u003c/strong\u003e, this will be\nthe name of the component once it’s built. Replace the \u003cstrong\u003eNAME\u003c/strong\u003e value\nwith \u003cstrong\u003emd_url_checker\u003c/strong\u003e or any other name of your choosing.\u003c/p\u003e\n\u003cp\u003eNext up is the \u003cstrong\u003edescription\u003c/strong\u003e key, its value will be printed out at the\ntop when the \u003cstrong\u003e–help\u003c/strong\u003e command is called. Replace \u003cstrong\u003eDESCRIPTION\u003c/strong\u003e with\n“\u003cstrong\u003eCheck if URLs in a markdown are reachable and create a text report\nwith the results.\u003c/strong\u003e”. You can use multiple lines for a description by\nstarting its value with a pipe (|) and a new line, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: md_url_checker\n  description: |\n    This is the first line of my description.\n    Here\'s a second line!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003cstrong\u003earguments\u003c/strong\u003e dictionary contains all of the arguments that are\naccepted by the component. These arguments will be injected as variables\nin the script. In the case of the example script, this are the variables\nwe’re working with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epar_inputfile\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_domain\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_output\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create good arguments, you need to ask yourself a few essential\nquestions about each variable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat is the most fitting \u003ca href="/docs/reference_config/functionality/#arguments-list"\u003edata\ntype\u003c/a\u003e?\u003c/li\u003e\n\u003cli\u003eIs it an input or an output?\u003c/li\u003e\n\u003cli\u003eIs it required?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s take a closer look at \u003ccode\u003epar_inputfile\u003c/code\u003e for starters:\u003c/p\u003e\n\u003cp\u003eWe know it’s a file, as the script needs the path to a markdown \u003cstrong\u003efile\u003c/strong\u003e\nas its \u003cstrong\u003einput\u003c/strong\u003e. It’s also definitely a \u003cstrong\u003erequired\u003c/strong\u003e variable, as the\nscript would be pointless without it.\u003cbr\u003e\nWith this in mind, modify the first argument as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChange \u003cstrong\u003etype\u003c/strong\u003e’s value to \u003cstrong\u003efile\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eSet \u003cstrong\u003ename\u003c/strong\u003e’s value to \u003cstrong\u003e–inputfile\u003c/strong\u003e. The name of an argument has\nto match the variable name as the argument will be injected into the\nfinal script. In the case of \u003cstrong\u003ebash\u003c/strong\u003e scripts, the variable name\ngets a \u003cstrong\u003e‘par_’\u003c/strong\u003e prefix add to it. This is the reason why the\nscript variables all start with \u003cstrong\u003e‘par_’\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eUse “\u003cstrong\u003eThe input markdown file.\u003c/strong\u003e” for the \u003cstrong\u003edescription\u003c/strong\u003e value.\nThis description will be included when the \u003cstrong\u003e–help\u003c/strong\u003e option is\ncalled.\u003c/li\u003e\n\u003cli\u003eAdd a new key named \u003cstrong\u003erequired\u003c/strong\u003e and set its value to \u003cstrong\u003etrue\u003c/strong\u003e. This\nensures that the component will not be run without a value for this\nargument.\u003c/li\u003e\n\u003cli\u003eAdd another key, name it \u003cstrong\u003emust_exist\u003c/strong\u003e and set its value to\n\u003cstrong\u003etrue\u003c/strong\u003e. This key is unique to \u003cstrong\u003efile\u003c/strong\u003e type arguments, it adds\nextra logic to the component to check if a file exists before\nrunning the component. This saves you from having to do this check\nyourself in the script.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat’s it for the first argument! The result should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow for \u003ccode\u003epar_domain\u003c/code\u003e, this is a simple \u003cstrong\u003eoptional string\u003c/strong\u003e that gets\nadded before relative URLs. Make room for a new argument by creating a\nnew line below \u003ccode\u003emust_exist: true\u003c/code\u003e and press \u003cstrong\u003eShift + Tab\u003c/strong\u003e to back up\none tab so the cursor is aligned with the start of the first argument.\nAdd the \u003ccode\u003e--domain\u003c/code\u003e argument here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument isn’t required, you can simply omit the \u003cstrong\u003erequired\u003c/strong\u003e key.\nAgain, the variable name in the script will get the **’_par’**\nprefix added automatically in bash scripts. Here’s what the arguments\ndictionary look like up until now:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  arguments:                     \n  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe final variable to create an argument for is \u003ccode\u003epar_output\u003c/code\u003e. This is\nanother \u003cstrong\u003efile\u003c/strong\u003e and clearly an \u003cstrong\u003eoutput\u003c/strong\u003e. Its value \u003cstrong\u003eisn’t required\u003c/strong\u003e\nas we can use a \u003cstrong\u003edefault\u003c/strong\u003e path if no explicit value is given.\u003cbr\u003e\nAdd yet another new argument with the following keys and values:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a \u003cstrong\u003etype\u003c/strong\u003e key and set \u003cstrong\u003efile\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eThe next key is \u003cstrong\u003ename\u003c/strong\u003e, use \u003cstrong\u003e–output\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eFor the \u003cstrong\u003edescription\u003c/strong\u003e, use “\u003cstrong\u003eThe path of the output text file\nthat will contain the report.\u003c/strong\u003e”.\u003c/li\u003e\n\u003cli\u003eAdd a new key and name it \u003cstrong\u003edefault\u003c/strong\u003e. This will act as the default\nvalue when not specified by the user of the component. Set its value\nto \u003cstrong\u003e“output.txt”\u003c/strong\u003e, including the quotation marks.\u003c/li\u003e\n\u003cli\u003eFinally, add the \u003cstrong\u003edirection\u003c/strong\u003e key and set its value to \u003cstrong\u003eoutput\u003c/strong\u003e.\nThis specifies the direction of an argument as either \u003cstrong\u003einput\u003c/strong\u003e or\n\u003cstrong\u003eoutput\u003c/strong\u003e, with input being the default. Specifying that an\nargument is an output is important so the component can correctly\nhandle the writing of files and the passing of values in a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe finished argument should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file                           \n    name: --output\n    description: The path of the output text file that will contain the report.\n    default: \u0026quot;output.txt\u0026quot;\n    direction: output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith that, there’s just one more part of the functionality to fill in:\nthe script itself!\u003cbr\u003e\nEvery viash component has one or more resources, the most important of\nwhich is often the script. The template already contains a \u003cstrong\u003eresources\u003c/strong\u003e\ndictionary, so replace the following values to point to the script:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSet the value of \u003cstrong\u003etype\u003c/strong\u003e to \u003cstrong\u003ebash_script\u003c/strong\u003e. The script used in\nthis case was written in \u003cstrong\u003ebash\u003c/strong\u003e, so the resource type is set\naccordingly so viash knows what flavor of code to generate to create\nthe final component. You can find a full overview of the different\nresource types on the \u003ca href="/docs/reference_config/functionality/#resources-list"\u003eFunctionality\npage\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eChange the value of \u003cstrong\u003epath\u003c/strong\u003e to \u003cstrong\u003escript.sh\u003c/strong\u003e. This points to the\nresource and can be a relative path, an absolute path or even a URL.\nIn this case we keep the script in the same directory as the config\nfile to keep things simple.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat finishes up the functionality side of the component! All that’s\nleft is defining the platforms with their dependencies and then running\nand building the component.\u003c/p\u003e\n\u003ch3 id="defining-the-platforms"\u003eDefining the platforms\u003c/h3\u003e\n\u003cp\u003eThe platforms dictionary specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform is assumed. Here’s a quick overview of\nthe platforms:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003enative\u003c/strong\u003e: The platform for developers that know what they’re doing\nor for simple components without any dependencies. All dependencies\nneed to be installed on the system the component is run on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edocker\u003c/strong\u003e: This platform is recommended for most components. The\ndependencies are resolved by using \u003ca href="https://www.docker.com/"\u003edocker\u003c/a\u003e\ncontainers, either from scratch or by pulling one from a docker\nrepository. This has huge benefits as the end user doesn’t need to\nhave any of the dependencies installed locally.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enextflow\u003c/strong\u003e: This converts the component into a\n\u003ca href="https://www.nextflow.io/"\u003eNextFlow\u003c/a\u003e module that can be imported\ninto a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn this tutorial, we’ll take a look at both the native and docker\nplatforms. The platforms are also defined in the \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e\nfile at the very bottom. The native platform is actually already defined\nin the template, that one \u003cstrong\u003etype\u003c/strong\u003e key with a value of \u003cstrong\u003enative\u003c/strong\u003e is\nenough! Now for adding the docker platform, add a new line below the\nlast and add the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: docker\n    image: bash:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells viash that this component can be built to a docker container\nwith the \u003ca href="https://hub.docker.com/_/bash"\u003elatest bash image\u003c/a\u003e as its base.\nIf your script doesn’t depend on any packages, this would be all you’d\nhave to add when using a bash script. The script in our example however\nneeds \u003cstrong\u003ecurl\u003c/strong\u003e installed to work. Luckily, this isn’t a problem since\nviash \u003ca href="/docs/reference_config/platform-docker/#example"\u003esupports defining\ndependencies\u003c/a\u003e which\nthen get pulled from inside the docker container before running the\nscript. To add curl as a dependancy that needs to be installed, add\nthese lines below \u003ccode\u003eimage: bash:latest\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e    setup:\n      - type: apk\n        packages: [ curl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will prompt the\n\u003ca href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management"\u003eapk\u003c/a\u003e\npackage manager to download and install curl inside of the container.\nThat’s it for the config! Be sure to save it and let’s move on to\nactually running the component you’ve created. For reference, you can\ntake a look at the completed \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file in \u003ca href="https://github.com/viash-io/viash_web/blob/main/static/examples/md_url_checker/config.vsh.yaml"\u003eour Github\nrepository\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="run-the-component"\u003eRun the component\u003c/h2\u003e\n\u003cp\u003eTime to run the component! First off, let’s see what the output of\n\u003ccode\u003e--help\u003c/code\u003e is. To do that, open a terminal in the \u003cstrong\u003emy_viash_component\u003c/strong\u003e\nfolder and execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will show the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCheck if URLs in a markdown are reachable and create a text report with the results.\n\nOptions:\n    --inputfile=file\n        type: file, required parameter\n        The input markdown file.\n\n    --domain=string\n        type: string\n        The domain URL that gets inserted before any relative URLs. For example, /documentation/intro could be replaced with https://my-website/documentation/intro to create a valid URL.\n\n    --output=file\n        type: file, default: output.txt\n        The path of the output text file that will contain the report.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the values you entered into the config file are all\nhere.\u003cbr\u003e\nNext, let’s run the component natively with some arguments. You can use\none of your own markdown files as the input if you desire. In that case,\nreplace \u003cstrong\u003eTestfile.md\u003c/strong\u003e in the command with the path to your file.\u003cbr\u003e\nExecute the following command to run the component with the default\nplatform, in this case \u003cstrong\u003enative\u003c/strong\u003e as it’s the first in the \u003cstrong\u003eplatforms\u003c/strong\u003e\ndictionary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all goes well, you’ll see something like this output in the terminal\nand a file named \u003cstrong\u003emy_report.txt\u003c/strong\u003e will have appeared:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExtracting URLs\nChecking 6 URLs\n1: https://www.google.com\nOK\n2: https://www.reddit.com\nOK\n3: http://microsoft.com/random-link\nHTTP/2 404 \n4: http://www.viash.io\nOK\n5: https://viash.io//docs/prologue/installation\nOK\n6: https://viash.io//docs/reference_config/config\nOK\n\nTestfile.md has been checked and a report named my_report.txt has been generated.\n1 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor more information on the run command, take a look at \u003ca href="/docs/reference_commands/run/"\u003ethe viash run\ncommand page\u003c/a\u003e. Great! With that working,\nthe next step is building an executable.\u003c/p\u003e\n\u003ch2 id="building-an-executable"\u003eBuilding an executable\u003c/h2\u003e\n\u003cp\u003eYou can generate an executable using either the native or the docker\nplatform. The former will generate a file that can be run locally, but\ndepends on your locally installed software packages to work. A docker\nexecutable on the other hand can build and start up a docker container\nthat handles the dependencies for you.\u003cbr\u003e\nTo create a native build, execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA new folder named \u003cstrong\u003eoutput\u003c/strong\u003e will have been created with an executable\ninside named \u003cstrong\u003emd_url_checker\u003c/strong\u003e. To test it out, execute the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eoutput/md_url_checker --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is the same as by running the component, but the executable\ncan be easily shared and now includes the ability to feed arguments to\nit and an included \u003ccode\u003e--help\u003c/code\u003e command. Not bad!\u003cbr\u003e\nNext up is the docker executable. You can specify the platform with the\n\u003ccode\u003e-p\u003c/code\u003e argument and choose an output folder using \u003ccode\u003e-o\u003c/code\u003e, apart from that\nit’s the same as the previous build command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build -p docker -o docker_output config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll now have a \u003cstrong\u003edocker_ouput\u003c/strong\u003e folder alongside the \u003cstrong\u003eoutput\u003c/strong\u003e one.\nThis folder also contains a file named \u003cstrong\u003emd_url_checker\u003c/strong\u003e, but its\ninner workings are slightly different than before. Run\n\u003cstrong\u003emd_url_checker\u003c/strong\u003e with the full arguments list to test what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003edocker_output/md_url_checker --inputfile=Testfile.md --domain=https://viash.io/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s what just happened:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the docker image wasn’t found, viash will download it.\u003c/li\u003e\n\u003cli\u003eA check is made to see if a container named “md_url_checker”\nexists. If not, one will be built with the image defined in the\nconfig as its base.\u003c/li\u003e\n\u003cli\u003eAll dependencies defined in the config are taken care of.\u003c/li\u003e\n\u003cli\u003eThe script is run with the passed arguments and the output is passed\nto your shell. The \u003cstrong\u003emy_report.txt\u003c/strong\u003e file is written to your\nworking directory.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor more information about the \u003ccode\u003eviash build\u003c/code\u003e command, take a look at\n\u003ca href="/docs/reference_commands/build/"\u003eits command page\u003c/a\u003e. That concludes the\nbuilding of executables based on components using viash!\u003c/p\u003e\n\u003ch2 id="writing-and-running-a-unit-test"\u003eWriting and running a unit test\u003c/h2\u003e\n\u003cp\u003eTo finish off this tutorial, it’s important to talk about unit tests. To\nensure that your component works as expected during its development\ncycle, writing one or more tests is essential. Luckily, writing a unit\ntest for a viash component is straightforward.\u003c/p\u003e\n\u003cp\u003eYou just need to add test parameters in the config file and write a\nscript which runs the executable and verifies the output. When running\ntests, viash will automatically build an executable and place it\nalongside the other defined resources in a temporary working directory.\nTo get started, open up \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file again and add this at\nthe end of the functionality dictionary, between the \u003ccode\u003epath: script.sh\u003c/code\u003e\nand \u003ccode\u003eplatforms:\u003c/code\u003e lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  tests:\n  - type: bash_script\n    path: test.sh\n  - path: Testfile.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis test dictionary contains a reference to the test script and all of\nthe files that need to be copied over in order to complete a test. In\nthe case of our example, \u003cstrong\u003etest.sh\u003c/strong\u003e will be the test script and\n\u003cstrong\u003eTestfile.md\u003c/strong\u003e is necessary as an input markdown file is required for\nthe script to function. Now create a new file named \u003cstrong\u003etest.sh\u003c/strong\u003e in the\n\u003cstrong\u003emy_viash_component\u003c/strong\u003e folder and add this as its content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eset -ex # exit the script when one of the checks fail and output all commands.\n\n# check 1\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\u0026quot;\n\n# run compononent with required input(s)\n./md_url_checker --inputfile Testfile.md \u0026gt; test-output.txt\n\n[[ ! -f test-output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Test output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\ngrep -q \'1: https://www.google.com\' test-output.txt # Did the script find the URL?\ngrep -q \'HTTP/2 404\' test-output.txt  # Did the web request return a 404 for the page that doesn\'t exist?\n\n# check 2\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\u0026quot;\n\n[[ ! -f output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\ngrep -q \'URL: https://www.google.com\' output.txt # Was the URL written correctly in the report?\ngrep -q \'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404\' output.txt # Was the error written correctly in the report?\ngrep -q \'Link name: install viash here\' output.txt # Was link name written correctly in the report?\n\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\u0026quot;\nexit 0 # don\'t forget to put this at the end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis bash script will run the component and perform several checks to\nits output. A successful test runs all the way down and exits with a \u003cstrong\u003e0\nexit code\u003c/strong\u003e, any other code means a failure:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eset -ex\u003c/code\u003e will stop the script once any of the lines fail and will\noutput all commands to the shell with a ‘+’ before it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./md_url_checker --inputfile Testfile.md \u0026gt; test-output.txt\u003c/code\u003e runs\nthe component and writes its output to a file.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e[[ ! -f test-output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Test output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\u003c/code\u003e\nchecks is the output file exists, if it doesn’t exit with a 1 code.\u003c/li\u003e\n\u003cli\u003eAll of the \u003ccode\u003egrep\u003c/code\u003e calls check if a certain piece of text could be\nfound. Each of these calls can exit the script if the text wasn’t\nfound.\u003c/li\u003e\n\u003cli\u003eIf everything succeeded, exit with a 0 code. Make sure not to forget\nthis final line in your own tests.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMake sure both the config and test files are saved, then run a test by\nrunning this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRunning tests in temporary directory: \'/tmp/viash_test_md_url_checker159892277392401116\'\n====================================================================\n+/tmp/viash_test_md_url_checker159892277392401116/build_executable/md_url_checker ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker159892277392401116/test_test.sh/test.sh\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\'\n\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\n+ ./md_url_checker --inputfile Testfile.md\n+ [[ ! -f test-output.txt ]]\n+ grep -q \'1: https://www.google.com\' test-output.txt\n+ grep -q \'HTTP/2 404\' test-output.txt\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\'\n\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\n+ [[ ! -f output.txt ]]\n+ grep -q \'URL: https://www.google.com\' output.txt\n+ grep -q \'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404\' output.txt\n+ grep -q \'Link name: install viash here\' output.txt\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\'\n\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\n+ exit 0\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the test succeeds it simply writes the full output to the shell. If\nthere’s any issues, the script stops and an error message will appear in\nred. For more information on tests take a look at the \u003ca href="/docs/reference_commands/test/"\u003eviash test\ncommand page\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow you’re ready to use viash to creating components from your own\nscripts, check out the rest of our documentation on the left. Here are\nsome good starting points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eReference: Commands\u003c/strong\u003e section on the left\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="/docs/reference_config/functionality/"\u003eoverview of the functionality\ndictionary\u003c/a\u003e of the config\nfile\u003c/li\u003e\n\u003cli\u003eMore details about \u003ca href="/docs/reference_config/platform-docker/"\u003ethe docker\nplatform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:8,href:"/docs/creating_components/python/",title:"Creating a Python component",description:"Developing a new viash component.",content:'\u003cp\u003eNOTICE: This documentation might be outdated. Please be patient while\nthe tutorial is being rewritten.\u003c/p\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case a Python script.\u003c/p\u003e\n\u003ch4 id="write-a-script-in-python"\u003eWrite a script in Python\u003c/h4\u003e\n\u003cp\u003eThis is a simple script which prints a simple message, along with any\ninput provided to it through the \u003ccode\u003epar[\u0026quot;input\u0026quot;]\u003c/code\u003e parameter. Optionally,\nyou can override the greeter with \u003ccode\u003epar[\u0026quot;greeter\u0026quot;]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="script.py"\u003e\u003ccode\u003escript.py\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003e## VIASH START\npar = {\n  \u0026quot;input\u0026quot;: [\u0026quot;I am debug!\u0026quot;],\n  \u0026quot;greeter\u0026quot;: \u0026quot;Hello world!\u0026quot;\n}\n\n## VIASH END\n\nif par[\u0026quot;input\u0026quot;] is None:\n  par[\u0026quot;input\u0026quot;] = []\n\nprint(par[\u0026quot;greeter\u0026quot;], *par[\u0026quot;input\u0026quot;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnything between the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines will\nautomatically be replaced at runtime with parameter values from the CLI.\nAnything between these two lines can be used to test the script without\nviash:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003epython script.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world! I am debug!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we write a meta-file describing the functionality of this\ncomponent in YAML format.\u003c/p\u003e\n\u003ch4 id="describe-the-component-with-as-a-yaml"\u003eDescribe the component with as a YAML\u003c/h4\u003e\n\u003cp\u003eA \u003ca href="config"\u003eviash config\u003c/a\u003e file describes the behaviour of a script and\nthe platform it runs on. It consists of two main sections:\n\u003ccode\u003efunctionality\u003c/code\u003e and \u003ccode\u003eplatforms\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="config.vsh.yaml"\u003e\u003ccode\u003eyaml\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003efunctionality:\n  name: hello_world_py\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: python_script\n    path: script.py\n  tests:\n  - type: python_script\n    path: test.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;python:3.8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href="/docs/reference_config/functionality"\u003efunctionality\u003c/a\u003e section\ndescribes the core functionality of the component, such as its inputs,\noutputs, arguments, and extra resources. For each of the arguments,\nspecifying a description and a set of argument restrictions help create\na useful command-line interface. To ensure that your component works as\nexpected, writing one or more tests is essential.\u003c/p\u003e\n\u003cp\u003eThe platforms section specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-native"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003ch3 id="writing-a-first-unit-test"\u003eWriting a first unit test\u003c/h3\u003e\n\u003cp\u003eWriting a unit test for a viash component is relatively simple. You just\nneed to write a Bash script (or R, or Python) which runs the executable\nmultiple times, and verifies the output. Take note that the test needs\nto produce an error code not equal to 0 when a mistake is found.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="test.py"\u003e\u003ccode\u003etest.py\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eimport unittest\nimport os\nfrom os import path\nimport subprocess\n\nclass Tester(unittest.TestCase):\n    def simple_test(self):\n        out = subprocess.check_output([\u0026quot;./hello_world_py\u0026quot;, \u0026quot;I\u0026quot;, \u0026quot;am\u0026quot;, \u0026quot;viash\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertEqual(out, \u0026quot;Hello world! I am viash\\n\u0026quot;)\n        \n    def less_params(self):\n        out = subprocess.check_output([\u0026quot;./hello_world_py\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertEqual(out, \u0026quot;Hello world!\\n\u0026quot;)\n        \n    def simple_test(self):\n        out = subprocess.check_output([\u0026quot;./hello_world_py\u0026quot;, \u0026quot;General\u0026quot;, \u0026quot;Kenobi\u0026quot;, \u0026quot;--greeter=Hello there.\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertEqual(out, \u0026quot;Hello there. General Kenobi.\\n\u0026quot;)\n\nunittest.main()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen running the test, viash will automatically build an executable and\nplace it – along with other resources and test resources – in a\ntemporary working directory.\u003c/p\u003e\n'},{id:9,href:"/docs/creating_components/r/",title:"Creating an R component",description:"Developing a new viash component.",content:'\u003cp\u003eNOTICE: This documentation might be outdated. Please be patient while\nthe tutorial is being rewritten.\u003c/p\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case an R script.\u003c/p\u003e\n\u003ch4 id="write-a-script-in-r"\u003eWrite a script in R\u003c/h4\u003e\n\u003cp\u003eThis is a simple script which prints a simple message, along with any\ninput provided to it through the \u003ccode\u003epar[\u0026quot;input\u0026quot;]\u003c/code\u003e parameter. Optionally,\nyou can override the greeter with \u003ccode\u003epar[\u0026quot;greeter\u0026quot;]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="script.R"\u003e\u003ccode\u003escript.R\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e## VIASH START\npar \u0026lt;- list(\n  input = \u0026quot;I am debug!\u0026quot;,\n  greeter = \u0026quot;Hello world!\u0026quot;\n)\n\n## VIASH END\n\ncat(par$greeter, \u0026quot; \u0026quot;, paste(par$input, collapse = \u0026quot; \u0026quot;), \u0026quot;\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnything between the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines will\nautomatically be replaced at runtime with parameter values from the CLI.\nAnything between these two lines can be used to test the script without\nviash:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eRscript script.R\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e## Hello world! I am debug!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we write a meta-file describing the functionality of this\ncomponent in YAML format.\u003c/p\u003e\n\u003ch4 id="describe-the-component-with-as-a-yaml"\u003eDescribe the component with as a YAML\u003c/h4\u003e\n\u003cp\u003eA \u003ca href="/docs/reference_config/config"\u003eviash config\u003c/a\u003e file describes the\nbehaviour of a script and the platform it runs on. It consists of two\nmain sections: \u003ccode\u003efunctionality\u003c/code\u003e and \u003ccode\u003eplatforms\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="config.vsh.yaml"\u003e\u003ccode\u003eyaml\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003efunctionality:\n  name: hello_world_r\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: r_script\n    path: script.R\n  tests:\n  - type: r_script\n    path: test.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;rocker/tidyverse:4.0.4\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href="/docs/reference_config/functionality"\u003efunctionality\u003c/a\u003e section\ndescribes the core functionality of the component, such as its inputs,\noutputs, arguments, and extra resources. For each of the arguments,\nspecifying a description and a set of argument restrictions help create\na useful command-line interface. To ensure that your component works as\nexpected, writing one or more tests is essential.\u003c/p\u003e\n\u003cp\u003eThe platforms section specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-native"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003ch3 id="writing-a-first-unit-test"\u003eWriting a first unit test\u003c/h3\u003e\n\u003cp\u003eWriting a unit test for a viash component is relatively simple. You just\nneed to write a Bash script (or R, or Python) which runs the executable\nmultiple times, and verifies the output. Take note that the test needs\nto produce an error code not equal to 0 when a mistake is found.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="test.R"\u003e\u003ccode\u003etest.R\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003elibrary(testthat)\nlibrary(processx)\n\n# check 1\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./hello_world_r\u0026quot;, c(\u0026quot;I\u0026quot;, \u0026quot;am\u0026quot;, \u0026quot;viash!\u0026quot;))\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;Hello world! I am viash!\u0026quot;)\n\n# check 2\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct when no parameters are given\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./hello_world_r\u0026quot;)\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;Hello world!\u0026quot;)\n\n# check 3\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct when more parameters are given\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./hello_world_r\u0026quot;, args = c(\u0026quot;General\u0026quot;, \u0026quot;Kenobi.\u0026quot;, \u0026quot;--greeter=Hello there.\u0026quot;))\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;Hello there. General Kenobi.\u0026quot;)\n\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\\n\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen running the test, viash will automatically build an executable and\nplace it – along with other resources and test resources – in a\ntemporary working directory.\u003c/p\u003e\n'},{id:10,href:"/docs/creating_pipelines/platform-nextflow/",title:"Creating a Nextflow Pipeline",description:"Developing a Pipeline in Nextflow with viash.",content:'\u003ch2 id="introduction"\u003eIntroduction\u003c/h2\u003e\n\u003ch3 id="pipelines--workflows"\u003ePipelines / Workflows\u003c/h3\u003e\n\u003cp\u003eIt’s possible to \u003cem\u003econvert\u003c/em\u003e a viash component into a NextFlow module.\nViash uses NextFlow’s DSL2 for this, effectively creating \u003cem\u003emodules\u003c/em\u003e that\ncan be imported in a \u003ccode\u003emain.nf\u003c/code\u003e pipeline definition that deals with the\n\u003cem\u003elogic\u003c/em\u003e of the pipeline rather than the low-level machinery.\u003c/p\u003e\n\u003cp\u003eWhen it comes to this low-level machinery and the way viash creates a\nmodule, we refer to \u003ca href="https://www.data-intuitive.com/diflow"\u003ethe step-by-step introduction about\nDiFlow\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="parallelization"\u003eParallelization\u003c/h3\u003e\n\u003cp\u003eNextFlow, as any other pipeline platform is able to run tasks in\nparallel if the pipeline logic allows for that. In order to keep\ndifferent parallel branch unique, we add a unique identifier \u003ccode\u003eid\u003c/code\u003e. This\nidentifier can be a sample identifier, or a plate id (sequencing),\nversions of reference files to consider, etc.\u003c/p\u003e\n\u003cp\u003eIn a pipeline, one is often interested in running some computation on\ndifferent datasets, inputs or parts of an input. This means that\nobviously we need to keep track of where the input chunks are located.\nBut more importantly, we can not just simply name an output file because\nmultiple parallel processes might just overwrite each other’s output\nfiles.\u003c/p\u003e\n\u003ch3 id="output-filenames"\u003eOutput Filenames\u003c/h3\u003e\n\u003cp\u003eTherefore, it’s important to keep output files distinct across different\nsteps of the pipeline but also between different parallel runs. In order\nto assure this, a module will define its own output file name. It is\nconstructed from 3 ingredients:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe unique \u003ccode\u003eid\u003c/code\u003e of the data going into the process\u003c/li\u003e\n\u003cli\u003eThe name of the current component/task\u003c/li\u003e\n\u003cli\u003eAn extension\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe extension is derived from the component configuration if a\n\u003ccode\u003edefault: ...\u003c/code\u003e attribute is present for the corresponding output\nargument. If no such default value is provided, the \u003cem\u003ename\u003c/em\u003e of the option\nis used.\u003c/p\u003e\n\u003cp\u003eAs an example, the following argument for a component \u003ccode\u003ecomp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003ename: --log\ntype: file\ndirection: Output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewill result in \u003ccode\u003e\u0026lt;id\u0026gt;.comp.log\u003c/code\u003e, while the following\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003ename: --log\ntype: file\ndirection: Output\ndefault: log.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewill become in \u003ccode\u003e\u0026lt;id\u0026gt;.comp.txt\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe config can define a directory as output as well, it will be named\naccordingly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRemark\u003c/strong\u003e: If the output is a directory, \u003ccode\u003etype: file\u003c/code\u003e should still be\nused, but the corresponding script/code should take care of writing the\ncontent to that directory.\u003c/p\u003e\n\u003ch2 id="configuration-settings"\u003eConfiguration Settings\u003c/h2\u003e\n\u003cp\u003eThis is an example of a NextFlow platform definition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e...\nplatforms:\n  ...\n  - type: nextflow\n    publish: true\n    per_id: true\n    label: highmem\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="id"\u003e\u003ccode\u003eid\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eThe platform definition can be given a unique identifier, which is\nespecially useful when multiple \u003ccode\u003etype: nextflow\u003c/code\u003e platform definitions\nare present for the same component/module:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e is optional\u003c/li\u003e\n\u003cli\u003eNo default value if used\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="image-tagversion-and-registry"\u003e\u003ccode\u003eimage\u003c/code\u003e, \u003ccode\u003etag\u003c/code\u003e/\u003ccode\u003eversion\u003c/code\u003e and \u003ccode\u003eregistry\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eIf no image attributes are configured, viash will use an auto-generated\nimage name:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[\u0026lt;namespace\u0026gt;/]\u0026lt;name\u0026gt;:\u0026lt;version\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis name corresponds to the one given by the Docker platform when a\ncustom build is required. This means that it will only work when a\ndocker platform definition is used that applies customizations.\u003c/p\u003e\n\u003cp\u003eIf no customizations are applied to the docker platform, it means that\nit uses a simple base image and the auto-generated name above will not\nbe used. It’s possible to manually configure an image to be used to run\nthe module in mainly two ways:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eBy simply adding a \u003ccode\u003eimage: \u0026lt;name\u0026gt;:\u0026lt;tag\u0026gt;\u003c/code\u003e as an attribute.\u003c/li\u003e\n\u003cli\u003eBy specifying the different parts of the container name explicitly:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eimage\u003c/code\u003e for the image name\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etag\u003c/code\u003e or \u003ccode\u003eversion\u003c/code\u003e: a tag for the container is fetched from the\nfollowing (in order):\n\u003col\u003e\n\u003cli\u003eIf a platform \u003ccode\u003eversion\u003c/code\u003e is configured, use this\u003c/li\u003e\n\u003cli\u003eIf a platform \u003ccode\u003etag\u003c/code\u003e is configured, use it\u003c/li\u003e\n\u003cli\u003eUse the global \u003ccode\u003eversion\u003c/code\u003e for this viash config\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eregistry\u003c/code\u003e if the image should be fetched from a remote registry\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTo repeat: The auto-generated image name is ideal in cases where a\ncustom container is built for the Docker platform, this container is\nbuilt (or can be fetched from a registry) and used in the NextFlow\nplatform. If no customizations are applied, one should add the correct\n\u003ccode\u003eimage: ...\u003c/code\u003e to both the \u003ccode\u003edocker\u003c/code\u003e and \u003ccode\u003enextflow\u003c/code\u003e platform\nconfigurations.\u003c/p\u003e\n\u003ch3 id="publish"\u003e\u003ccode\u003epublish\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eNextFlow uses the autogenerated \u003ccode\u003ework\u003c/code\u003e dirs to manage process IO under\nthe hood. In order effectively \u003cem\u003eoutput\u003c/em\u003e something one can \u003cem\u003epublish\u003c/em\u003e the\nresults a module or step in the pipeline. In order to do this, add\n\u003ccode\u003epublish: true\u003c/code\u003e to the config:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epublish\u003c/code\u003e is optional\u003c/li\u003e\n\u003cli\u003eDefault value is \u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis attribute simply defines if output of a component should be\npublished yes or no. The output location has to be provided at pipeline\nlaunch by means of the option \u003ccode\u003e--output ...\u003c/code\u003e or in \u003ccode\u003enextflow.config\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eparams.output = \u0026quot;...\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy default, a subdirectory is created corresponding to the unique ID\nthat is passed in the triplet. Let us illustrate this with an example.\nThe following code snippet uses the value of \u003ccode\u003e--input\u003c/code\u003e as an input of a\nworkflow. The input can include a wildcard so that multiple samples can\nrun in parallel. We use the parent directory name\n(\u003ccode\u003e.getParent().baseName\u003c/code\u003e) as an identifier for the sample. We pass this\nas the first entry of the triplet:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eChannel.fromPath(params.input) \\\n    | map{ it -\u0026gt; [ it.getParent().baseName , it ] } \\\n    | map{ it -\u0026gt; [ it[0] , it[1], params ] }\n    | ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSay the resulting sample names are \u003ccode\u003eSAMPLE1\u003c/code\u003e and \u003ccode\u003eSAMPLE2\u003c/code\u003e. The next\nstep in the pipeline will be published (at least by default) under:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;output\u0026gt;/SAMPLE1/\n\u0026lt;output\u0026gt;/SAMPLE2/\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="path"\u003e\u003ccode\u003epath\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eWhen \u003ccode\u003epublish: true\u003c/code\u003e, this attribute defines where the output is written\n\u003cem\u003erelative\u003c/em\u003e to the \u003ccode\u003eparams.output\u003c/code\u003e setting. For example,\n\u003ccode\u003epath: processed\u003c/code\u003e in combination with \u003ccode\u003e--output s3://some_bucket/\u003c/code\u003e will\nstore the output of this component under\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es3://some_bucket/processed/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis attribute gives control over the directory structure of the output.\nFor example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003epath: raw_data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr even:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003epath: raw_data/bcl\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease note that \u003ccode\u003eper_id\u003c/code\u003e and \u003ccode\u003epath\u003c/code\u003e can be combined.\u003c/p\u003e\n\u003ch3 id="per_id"\u003e\u003ccode\u003eper_id\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eWhen \u003ccode\u003epublish: true\u003c/code\u003e, we already noted that a subdirectory is created\nautomatically per unique \u003ccode\u003eid\u003c/code\u003e. In order to avoid the creation of this\nsubdirectory, \u003ccode\u003eper_id: false\u003c/code\u003e can be added to the platform\nconfiguration.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epath\u003c/code\u003e (see above) is used, but if needed an additional subdirectory can\nbe automatically\u003c/p\u003e\n\u003cp\u003eIn the previous example, given two \u003cem\u003esamples\u003c/em\u003e \u003ccode\u003eSAMPLE1\u003c/code\u003e and \u003ccode\u003eSAMPLE2\u003c/code\u003e\nrunning in parallel jobs the output would be stored under:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es3://some_bucket/processed/SAMPLE1/\u0026lt;outputfiles for sample1\u0026gt;\ns3://some_bucket/processed/SAMPLE2/\u0026lt;outputfiles for sample2\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewith the attribute \u003ccode\u003eper_id: false\u003c/code\u003e this will become:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es3://some_bucket/processed/\u0026lt;outputfiles for samples 1 and 2\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease note that all output files automatically have a unique name\nattached to them (see earlier) and so not creating the unique\nsubdirectory is strictly speaking not necessary to avoid collisions.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe attribute is optional\u003c/li\u003e\n\u003cli\u003eThe default value is \u003ccode\u003etrue\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="label--labels"\u003e\u003ccode\u003elabel\u003c/code\u003e / \u003ccode\u003elabels\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eWhen running the module in a cluster context and depending on the\ncluster type, \u003ca href="https://www.nextflow.io/docs/latest/process.html#label"\u003eNextFlow allows for attaching\nlabels\u003c/a\u003e to the\nprocess that can later be used as selectors for associating resources to\nthis process.\u003c/p\u003e\n\u003cp\u003eIn order to attach one label to a process/component, one can use the\n\u003ccode\u003elabel: ...\u003c/code\u003e attribute, multiple labels can be added using\n\u003ccode\u003elabels: [ ..., ... ]\u003c/code\u003e and the two can even be mixed.\u003c/p\u003e\n\u003cp\u003eIn the main \u003ccode\u003enextflow.config\u003c/code\u003e, one can now use this label:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprocess {\n  ...\n  withLabel: bigmem {\n     maxForks = 5\n     ...\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="stageinmode"\u003e\u003ccode\u003estageInMode\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eBy default Nextflow will create a symbolic link to the inputs for a\nprocess/module and run the tool at hand using those symbolic links. Some\napplications do not cope well with this strategy, in that case the files\nshould effectively be copied rather than linked to. This can be achieved\nby using \u003ccode\u003estageInMode: copy\u003c/code\u003e…\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe attribute is optional\u003c/li\u003e\n\u003cli\u003eThe default value is \u003ccode\u003esymlink\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="tips"\u003eTips\u003c/h2\u003e\n\u003ch3 id="how-to-specify-multiple-inputs"\u003eHow to specify multiple inputs?\u003c/h3\u003e\n\u003cp\u003eIf a component deals with just one input file, that input file should be\nprovided as the second element in the\n\u003ca href="https://www.data-intuitive.com/diflow/"\u003eDiFlow\u003c/a\u003e triplet. In other\nwords, if this is the first component in a (sub)workflow, two options\nare available:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eChannel.fromPath(\u0026lt;...\u0026gt;).map{ file -\u0026gt; [ \u0026lt;id\u0026gt;, file, params ] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eChannel.from(\u0026lt;...\u0026gt;).map{ filename -\u0026gt; [ \u0026lt;id\u0026gt;, file(filename), params ] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is crucial that this second element in the triplet is of type \u003ccode\u003ePath\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf multiple inputs are to be provided corresponding to the same option\nfor the underlying process or tool a \u003ccode\u003eList\u003c/code\u003e of \u003ccode\u003ePath\u003c/code\u003e objects can be\nprovided.\u003c/p\u003e\n\u003cp\u003eFor example, say we ran multiple parallel workflows for a single sample\nand want to join the result of that. The way to express this in NextFlow\nwould be something like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003econcatenate_ = singleSample_ \\\n    | toList \\\n    | map{ it -\u0026gt; [ it.collect{ b -\u0026gt; b[0]}, it.collect{ a -\u0026gt; a[1] }, params ]} \\\n    | concatenate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn other words, we pass a \u003ccode\u003eList\u003c/code\u003e of Path objects to the concatenate\nmodule.\u003c/p\u003e\n\u003cp\u003eIn some cases, multiple input arguments deal with different input files,\nfor instance \u003ccode\u003efastq\u003c/code\u003e files and a reference file for mapping and\ncounting. One can pass this to the concatenation module by means of a\n\u003ccode\u003eMap\u003c/code\u003e. This approach, for instance can be used to merge meta information\n(from a file) to an \u003ccode\u003eh5ad\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003e    singleSample_ = input_ \\\n        ...\n        | combine(meta_) \\\n        | map{ id, output, params, meta -\u0026gt;\n            [ id, [ \u0026quot;input\u0026quot; : output, \u0026quot;meta\u0026quot; : meta ], params ]\n        } \\\n        | annotate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere the \u003ccode\u003emeta_\u003c/code\u003e \u003ccode\u003eChannel\u003c/code\u003e points to the meta file to be used.\u003c/p\u003e\n\u003cp\u003eIn other words, we either provide a \u003ccode\u003eList\u003c/code\u003e of Path values or in the case\nmultiple options take different files we use a \u003ccode\u003eHashMap\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRemark: Be sure to mark the arguments at hand as being of \u003ccode\u003etype: file\u003c/code\u003e\nand \u003ccode\u003edirection: input\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="multiple-outputs"\u003eMultiple outputs\u003c/h2\u003e\n\u003cp\u003eInternally, DiFlow uses a similar approach to keeping track of outputs\nas discussed for inputs. What comes out of a module, however, is\nslightly different. Since a \u003ccode\u003eworkflow\u003c/code\u003e can not emit a multi-channel\nobject, we are forced to put all outputs on the same \u003ccode\u003eChannel\u003c/code\u003e and so we\nuse a \u003ccode\u003eMap\u003c/code\u003e again to distinguish both. This is only done for multiple\noutputs, though.\u003c/p\u003e\n\u003cp\u003eBy means of an example: Say a module outputs one file, then the triplet\nthat is returned from the module looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[ \u0026lt;id\u0026gt;, file, params ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf our tools has two output files, say for instance \u003ccode\u003eoutputfile.txt\u003c/code\u003e and\n\u003ccode\u003elogfile.txt\u003c/code\u003e (as indicated by the command line for the tool that looks\nfor instance like this:\n\u003ccode\u003e.... --output outputfile.txt --log logfile.txt\u003c/code\u003e), we still get one\n\u003ccode\u003eChannel\u003c/code\u003e back, but on that \u003ccode\u003eChannel\u003c/code\u003e there are now two \u003cem\u003eevents\u003c/em\u003e and\nthose look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[ \u0026lt;id\u0026gt;, [ output: outputfile.txt ], params ]\n[ \u0026lt;id\u0026gt;, [ log: logfile.txt ], params ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s up to the receiving end of the module to split this downstream. The\nimplicit workflow defined in all the generated module contains some\nexample code to that, for instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-groovy"\u003eresult \\\n  | filterOutput \\\n  | view{ \u0026quot;Output for output: \u0026quot; + it[1] }\n\nresult \\\n  | filterLog \\\n  | view{ \u0026quot;Output for log: \u0026quot; + it[1] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere the \u003ccode\u003efilterLog\u003c/code\u003e process for instance is defined like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// A process that filters out output from the output Map\nprocess filterOutput {\n\n  input:\n    tuple val(id), val(input), val(_params)\n  output:\n    tuple val(id), val(output), val(_params)\n  when:\n    input.keySet().contains(\u0026quot;output\u0026quot;)\n  exec:\n    output = input[\u0026quot;output\u0026quot;]\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively, one could also use methods on the \u003ccode\u003eChannel\u003c/code\u003e itself:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eresult \\\n  | filter{ it[1].keySet().contains(\u0026quot;output\u0026quot;) }\n  | map{ [ it[0], it[1][\u0026quot;output\u0026quot;], it[2] ] }\n  | view{ \u0026quot;Output for log: \u0026quot; + it[1] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne more option is to use the \u003ccode\u003ebranch\u003c/code\u003e or \u003ccode\u003emultiMap\u003c/code\u003e \u003ccode\u003eChannel\u003c/code\u003e forking\noperators in NextFlow.\u003c/p\u003e\n\u003ch2 id="access-arguments-from-the-nextflow-cli-v041"\u003eAccess arguments from the \u003ccode\u003enextflow\u003c/code\u003e CLI (\u003ccode\u003ev0.4.1+\u003c/code\u003e)\u003c/h2\u003e\n\u003cp\u003eWe provide a way to access the argument values for all the arguments for\nevery component from the NextFlow CLI. All components store their\nrespective arguments under a component-specific key that corresponds to\nthe component name.\u003c/p\u003e\n\u003cp\u003eFurthermore, the value that will effectively be passed to the process\ndepends on the following attributes for an argument:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003erequired: true/false\ndefault: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument is \u003ccode\u003erequired: true\u003c/code\u003e, it can have\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea \u003ccode\u003edefault: ...\u003c/code\u003e value: It will use this default value on the CLI\nunless you override it on the CLI\u003c/li\u003e\n\u003cli\u003eno default value: In this case, one has to provide a value when\nstarting a NextFlow pipeline. Otherwise viash will give a warning\nand NXF will throw an error.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf an argument is \u003ccode\u003erequired: false\u003c/code\u003e, it can have\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea default: ...\u003c/code\u003e value: It will use this default value unless you\noverride it from the CLI\u003c/li\u003e\n\u003cli\u003eno default value: In this case, this argument will not be present on\nthe CLI, but it can still be overridden from the CLI\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePlease refer to \u003ca href="https://github.com/viash-io/viash/issues/46"\u003ethis\nissue\u003c/a\u003e for more\ninformation.\u003c/p\u003e\n\u003cp\u003eGiven the above, its possible to override any of these using the\nfollowing scheme:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e--\u0026lt;component_name\u0026gt;__\u0026lt;argument_name\u0026gt; \u0026lt;value\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enextflow run main.nf --filter__threshold 0.2\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:11,href:"/docs/reference_commands/run/",title:"viash run",description:"",content:'\u003cp\u003eExecutes a viash component from the provided \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e file. viash generates a temporary\nexecutable and immediately executes it with the given parameters.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash run config.vsh.yaml [-p docker] [-k true/false]  -- [arguments for script]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation. (default =\nList())\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:12,href:"/docs/reference_commands/build/",title:"viash build",description:"",content:'\u003cp\u003eBuild an executable from the provided \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e file.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash build config.vsh.yaml -o output [-p docker] [-m] [-s]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation. (default =\nList())\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-m, --meta\u003c/code\u003e: Print out some meta information at the end.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-o, --output  \u0026lt;arg\u0026gt;\u003c/code\u003e: Path to directory in which the executable and\nany resources is built to. Default: “output/”. (default = output/)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified. –push Whether or not to\npush the container to a Docker registry [Docker Platform only].\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --setup\u003c/code\u003e: Whether or not to set up the platform environment\nafter building the executable.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-w, --write_meta\u003c/code\u003e: Write out some meta information to\nRESOURCES_DIR/viash.yaml at the end.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:13,href:"/docs/reference_commands/test/",title:"viash test",description:"",content:'\u003cp\u003eTest the component using the tests defined in the \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e file.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash test config.vsh.yaml [-p docker] [-k true/false]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation. (default =\nList())\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:14,href:"/docs/reference_commands/config-view/",title:"viash config view",description:"",content:'\u003cp\u003eView the config file after parsing.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash config view config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:15,href:"/docs/reference_commands/ns-build/",title:"viash ns build",description:"",content:'\u003cp\u003eBuild a namespace from many \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash ns build [-n nmspc] [-s src] [-t target] [-p docker] [--setup] [---push] [--parallel] [--flatten]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-f, --flatten\u003c/code\u003e: Flatten the target builds, handy for building one\nplatform to a bin directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-l, --parallel\u003c/code\u003e: Whether or not to run the process in parallel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Acts as a regular expression to filter the\nplatform ids specified in the found config files. If this is not\nprovided, all platforms will be used. If no platforms are defined in\na config, the native platform will be used. In addition, the path to\na platform yaml file can also be specified. –push Whether or not to\npush the container to a Docker registry [Docker Platform only].\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-q, --query  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which components get selected by name\nand namespace. Can be a regex. Example: “^mynamespace/component1$”.\n–query_name \u003carg\u003e Filter which components get selected by name. Can\nbe a regex. Example: “^component1”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-n, --query_namespace  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which namespaces get selected\nby namespace. Can be a regex. Example: “^mynamespace$”. –setup\nWhether or not to set up the platform environment after building the\nexecutable.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --src  \u0026lt;arg\u0026gt;\u003c/code\u003e: A source directory containing \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e files, possibly structured in\na hierarchical folder structure. Default: src/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-t, --target  \u0026lt;arg\u0026gt;\u003c/code\u003e: A target directory to build the executables\ninto. Default: target/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-w, --write_meta\u003c/code\u003e: Write out some meta information to\nRESOURCES_DIR/viash.yaml at the end.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:16,href:"/docs/reference_commands/ns-test/",title:"viash ns test",description:"",content:'\u003cp\u003eTest a namespace containing many \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash ns test [-n nmspc] [-s src] [-p docker] [--parallel] [--tsv file.tsv] [--append]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-a, --append\u003c/code\u003e: Append to tsv instead of overwrite\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-l, --parallel\u003c/code\u003e: Whether or not to run the process in parallel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Acts as a regular expression to filter the\nplatform ids specified in the found config files. If this is not\nprovided, all platforms will be used. If no platforms are defined in\na config, the native platform will be used. In addition, the path to\na platform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-q, --query  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which components get selected by name\nand namespace. Can be a regex. Example: “^mynamespace/component1$”.\n–query_name \u003carg\u003e Filter which components get selected by name. Can\nbe a regex. Example: “^component1”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-n, --query_namespace  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which namespaces get selected\nby namespace. Can be a regex. Example: “^mynamespace$”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --src  \u0026lt;arg\u0026gt;\u003c/code\u003e: A source directory containing \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e files, possibly structured in\na hierarchical folder structure. Default: src/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-t, --tsv  \u0026lt;arg\u0026gt;\u003c/code\u003e: Path to write a summary of the test results to.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:17,href:"/docs/reference_commands/ns-list/",title:"viash ns list",description:"",content:'\u003cp\u003eList a namespace containing many \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash ns list [-n nmspc] [-s src] [-p docker] [--tsv file.tsv]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e at runtime using a custom\nDSL. For more information, see the online documentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-l, --parallel\u003c/code\u003e: Whether or not to run the process in parallel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Acts as a regular expression to filter the\nplatform ids specified in the found config files. If this is not\nprovided, all platforms will be used. If no platforms are defined in\na config, the native platform will be used. In addition, the path to\na platform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-q, --query  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which components get selected by name\nand namespace. Can be a regex. Example: “^mynamespace/component1$”.\n–query_name \u003carg\u003e Filter which components get selected by name. Can\nbe a regex. Example: “^component1”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-n, --query_namespace  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which namespaces get selected\nby namespace. Can be a regex. Example: “^mynamespace$”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --src  \u0026lt;arg\u0026gt;\u003c/code\u003e: A source directory containing \u003ca href="/docs/reference_config/config"\u003eviash\nconfig\u003c/a\u003e files, possibly structured in\na hierarchical folder structure. Default: src/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-t, --tsv  \u0026lt;arg\u0026gt;\u003c/code\u003e: Path to write a summary of the list results to.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:18,href:"/docs/reference_config/config/",title:"Config file",description:"",content:'\u003ch1 id="the-viash-config-file"\u003eThe viash config file\u003c/h1\u003e\n\u003cp\u003eA viash config file describes the behaviour of a script and the platform\nit runs on. It consists of two main sections: \u003ccode\u003efunctionality\u003c/code\u003e and\n\u003ccode\u003eplatforms\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href="/docs/reference_config/functionality/"\u003efunctionality\u003c/a\u003e section\ndescribes the core functionality of the component, such as its inputs,\noutputs, arguments, and extra resources. For each of the arguments,\nspecifying a description and a set of argument restrictions help create\na useful command-line interface. To ensure that your component works as\nexpected, writing one or more tests is essential.\u003c/p\u003e\n\u003cp\u003eThe platforms section specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/docs/reference_config/platform-native/"\u003eNative\u003c/a\u003e,\n\u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms\nare specified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eUsually, the config file is accompanied by a script which contains the\nactual code for the component.\u003c/p\u003e\n\u003cp\u003eOnly a small example of a viash config file is shown below, but check\nout the more detailed documentation regarding the\n\u003ca href="/docs/reference_config/functionality/"\u003efunctionality\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-native/"\u003eNative\nplatform\u003c/a\u003e, the \u003ca href="/docs/reference_config/platform-docker/"\u003eDocker\nplatform\u003c/a\u003e, and the \u003ca href="/docs/reference_config/platform-nextflow/"\u003eNextflow\nplatform\u003c/a\u003e for the full\nspecifications for each of these subsections.\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: addrowlines\n  description: Add rowlines to a text file.\n  arguments:\n  - name: input                           \n    type: file\n    description: The input file.\n  resources:\n  - type: bash_script\n    path: script.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: nextflow\n    image: bash:4.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003ecat -n $par_input\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe component can be executed as follows.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- config.vsh.yaml | head -5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e     1  functionality:\n     2    name: addrowlines\n     3    description: Add rowlines to a text file.\n     4    arguments:\n     5    - name: input                           \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWould you rather use Docker as a backend? Easy as pie!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -P docker config.vsh.yaml -- config.vsh.yaml | head -5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eUnable to find image \'addrowlines:latest\' locally\ndocker: Error response from daemon: pull access denied for addrowlines, repository does not exist or may require \'docker login\': denied: requested access to the resource is denied.\nSee \'docker run --help\'.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eAdd rowlines to a text file.\n\nOptions:\n    file\n        type: file\n        The input file.\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:19,href:"/docs/reference_config/functionality/",title:"Functionality",description:"The functionality-part of the config file describes the behaviour of the script in terms of arguments and resources.",content:'\u003cp\u003eBy specifying a few restrictions (e.g. mandatory arguments) and adding\nsome descriptions, viash will automatically generate a stylish\ncommand-line interface for you.\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eAn example of such a functionality yaml can be found below, each part of\nwhich is explained in more depth in the following sections.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: exe\n  version: \u0026quot;1.0.0\u0026quot;\n  description: |\n    This component performs function Y and Z.\n    It is possible to make this a multiline string.\n  arguments:\n    - name: --input\n      type: file\n      direction: input\n      alternatives: [-i]\n      description: Input file(s)\n      default: input.txt\n      must_exist: true\n      required: false\n      multiple: true\n      multiple_sep: \u0026quot;,\u0026quot;\n    - name: --output                           \n      type: file\n      direction: output\n      alternatives: [-o]\n      description: Output file\n      default: output.txt\n      required: true\n      multiple: false\n  resources:\n    - type: bash_script\n      path: script.sh\n    - path: additional_resource.txt\n  tests:\n    - type: bash_script\n      path: tests/first_unit_test.sh\n    - type: r_script\n      path: tests/second_unit_test.R\n    - path: tests/test_resource.txt\n  authors:\n    - name: Bob Cando\n      roles: [maintainer, author]\n      email: bob@can.do\n      props: {github: bobcando, orcid: 0000-0001-0002-0003}\n    - name: Tim Farbe\n      roles: [author]\n      email: tim@far.be\n  info:\n    foo: bar\n    custom_tag: custom_value\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="name-string"\u003ename [string]\u003c/h2\u003e\n\u003cp\u003eName of the component and the filename of the executable when built with\n\u003ccode\u003eviash build\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003ename: exe\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="version-string"\u003eversion [string]\u003c/h2\u003e\n\u003cp\u003eVersion of the component. This field will be used to version the\nexecutable and the Docker container.\u003c/p\u003e\n\u003ch2 id="description-string"\u003edescription [string]\u003c/h2\u003e\n\u003cp\u003eA description of the component. This will be displayed with \u003ccode\u003e--help\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003edescription: |\n  This component performs function Y and Z.\n  It is possible to make this a multiline string.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="arguments-list"\u003earguments [list]\u003c/h2\u003e\n\u003cp\u003eA list of arguments for this component. For each argument, a type and a\nname must be specified. Depending on the type of argument, different\nproperties can be set. Common properties for all argument types are the\nfollowing.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etype: string/file/integer/double/boolean/boolean_true/boolean_false\u003c/code\u003e,\nthe type of argument determining to what object type the value will\nbe cast in the downstream scripts.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edirection: input/output\u003c/code\u003e, the directionality of the argument. Only\nneeds to be specified for output files. Default: “input”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ename: --foo\u003c/code\u003e, the name of the argument. Can also be \u003ccode\u003e-foo\u003c/code\u003e or\n\u003ccode\u003efoo\u003c/code\u003e. The number of dashes determines how values can be passed:\n\u003cul\u003e\n\u003cli\u003ewith \u003ccode\u003e--foo\u003c/code\u003e: long option, e.g. \u003ccode\u003eexe --foo=bar\u003c/code\u003e or\n\u003ccode\u003eexe --foo bar\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ewith \u003ccode\u003e-foo\u003c/code\u003e: short option, e.g. \u003ccode\u003eexe -foo bar\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ewith \u003ccode\u003efoo\u003c/code\u003e: argument, e.g. \u003ccode\u003eexe bar\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ealternatives: [-f]\u003c/code\u003e, list of alternative names. Typically only used\nto provide a short alternative option.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edescription: Description of foo\u003c/code\u003e, a description of the argument.\nMultiline descriptions are supported.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefault: bar\u003c/code\u003e, the default value when no argument value is\nprovided. Not allowed when \u003ccode\u003erequired: true\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequired: true/false\u003c/code\u003e, whether the argument is required. If true\nand the functionality is executed, an error will be produced if no\nvalue is provided. Default = false.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultiple: true/false\u003c/code\u003e, whether to treat the argument value as an\narray or not. Arrays can be passed using the delimiter \u003ccode\u003e--foo=1:2:3\u003c/code\u003e\nor by providing the same argument multiple times \u003ccode\u003e--foo 1 --foo 2\u003c/code\u003e.\nDefault = false.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultiple_sep: \u0026quot;:\u0026quot;\u003c/code\u003e, the delimiter for providing multiple values.\nDefault = “:”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn types: * \u003ccode\u003etype: string\u003c/code\u003e, The value passed through an argument of\nthis type is converted to an ‘str’ object in Python, and to a\n‘character’ object in R. * \u003ccode\u003etype: integer\u003c/code\u003e, The resulting value is an\n‘int’ in Python and an ‘integer’ in R. * \u003ccode\u003etype: double\u003c/code\u003e, The resulting\nvalue is a ‘float’ in Python and an ‘double’ in R. * \u003ccode\u003etype: boolean\u003c/code\u003e,\nThe resulting value is a ‘bool’ in Python and a ‘logical’ in R. *\n\u003ccode\u003etype: boolean_true/boolean_false\u003c/code\u003e, Arguments of this type can only be\nused by providing a flag \u003ccode\u003e--foo\u003c/code\u003e or not. The resulting value is a ‘bool’\nin Python and a ‘logical’ in R. These properties cannot be altered:\nrequired is false, default is undefined, multiple is false. *\n\u003ccode\u003etype: file\u003c/code\u003e, The resulting value is still an ‘str’ in Python and a\n‘character’ in R. In order to correctly pass files in some platforms\n(e.g. Docker and Nextflow), viash needs to know which arguments are\ninput/output files. Additional property values: -\n\u003ccode\u003emust_exist: true/false\u003c/code\u003e, denotes whether the file or folder should\nexist at the start of the execution.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e- name: --foo                           \n  type: file\n  alternatives: [-f]\n  description: Description of foo\n  default: \u0026quot;/foo/bar\u0026quot;\n  must_exist: true\n  required: false\n  multiple: true\n  multiple_sep: \u0026quot;,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="resources-list"\u003eresources [list]\u003c/h2\u003e\n\u003cp\u003eThe first resource should be a script (\u003ccode\u003ebash_script\u003c/code\u003e, \u003ccode\u003er_script\u003c/code\u003e,\n\u003ccode\u003epython_script\u003c/code\u003e, \u003ccode\u003ejavascript_script\u003c/code\u003e, \u003ccode\u003escala_script\u003c/code\u003e) which is what will\nbe executed when the functionality is run. Additional resources will be\ncopied to the same directory.\u003c/p\u003e\n\u003cp\u003eCommon properties:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etype: file/r_script/python_script/bash_script/javascript_script/scala_script\u003c/code\u003e,\nthe type of resource. The first resource cannot be of type \u003ccode\u003efile\u003c/code\u003e.\nWhen the type is not specified, the default type is simply \u003ccode\u003efile\u003c/code\u003e.\nFor more information regarding how to write a script in Bash, R or\nPython with viash, check out the guides for the respective languages\non the left.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ename: filename\u003c/code\u003e, the resulting name of the resource.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epath: path/to/file\u003c/code\u003e, the path of the input file. Can be a relative\nor an absolute path, or a URI.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etext: ...multiline text...\u003c/code\u003e, the raw content of the input file.\nExactly one of \u003ccode\u003epath\u003c/code\u003e or \u003ccode\u003etext\u003c/code\u003e must be defined, the other\nundefined.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis_executable: true/false\u003c/code\u003e, whether the resulting file is made\nexecutable.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eresources:\n  - type: r_script\n    path: script.R\n  - type: file\n    path: resource1.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="tests-list"\u003etests [list]\u003c/h2\u003e\n\u003cp\u003eOne or more Bash/R/Python scripts to be used to test the component\nbehaviour when \u003ccode\u003eviash test\u003c/code\u003e is invoked. Additional files of type \u003ccode\u003efile\u003c/code\u003e\nwill be made available only during testing. Each test script should\nexpect no command-line inputs, be platform-independent, and return an\nexit code \u0026gt;0 when unexpected behaviour occurs during testing.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003etests:\n  - type: bash_script\n    path: tests/test1.sh\n  - type: r_script\n    path: tests/test2.R\n  - path: resource1.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="authors-list"\u003eauthors [list]\u003c/h2\u003e\n\u003cp\u003eA list of authors (introduced in viash 0.3.1). An author must at least\nhave a name, but can also have a list of roles, an e-mail address, and a\nmap of custom properties.\u003c/p\u003e\n\u003cp\u003eSuggested values for roles are:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eRole\u003c/th\u003e\n\u003cth\u003eAbbrev.\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003emaintainer\u003c/td\u003e\n\u003ctd\u003emnt\u003c/td\u003e\n\u003ctd\u003efor the maintainer of the code. Ideally, exactly one maintainer is specified.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eauthor\u003c/td\u003e\n\u003ctd\u003eaut\u003c/td\u003e\n\u003ctd\u003efor persons who have made substantial contributions to the software.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003econtributor\u003c/td\u003e\n\u003ctd\u003ectb\u003c/td\u003e\n\u003ctd\u003efor persons who have made smaller contributions (such as code patches).\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003edatacontributor\u003c/td\u003e\n\u003ctd\u003edtc\u003c/td\u003e\n\u003ctd\u003efor persons or organisations that contributed data sets for the software\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ecopyrightholder\u003c/td\u003e\n\u003ctd\u003ecph\u003c/td\u003e\n\u003ctd\u003efor all copyright holders. This is a legal concept so should use the legal name of an institution or corporate body.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003efunder\u003c/td\u003e\n\u003ctd\u003efnd\u003c/td\u003e\n\u003ctd\u003efor persons or organizations that furnished financial support for the development of the software\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eThe \u003ca href="https://www.loc.gov/marc/relators/relaterm.html"\u003efull list of\nroles\u003c/a\u003e is extremely\ncomprehensive.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eauthors:\n  - name: Bob Cando\n    roles: [maintainer, author]\n    email: bob@can.do\n    props: {github: bobcando, orcid: 0000-0001-0002-0003}\n  - name: Tim Farbe\n    roles: [author]\n    email: tim@far.be\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="info-list"\u003einfo [list]\u003c/h2\u003e\n\u003cp\u003eA map for storing custom annotation (introduced in viash 0.4.0).\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003einfo:\n  foo: bar\n  custom_tag: custom_value\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:20,href:"/docs/reference_config/platform-native/",title:"Native Platform",description:"Running a viash component on a native platform means that the script will be executed in your current environment.",content:'\u003cp\u003eAny dependencies are assumed to have been installed by the user, so the\nnative platform is meant for developers (who know what they’re doing) or\nfor simple bash scripts (which have no extra dependencies).\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eAn example of a native platform yaml can be found below, each part of\nwhich is explained in more depth in the following sections.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eplatforms:\n  - type: native\n    id: native_platform\n    version: \u0026quot;1.0.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="id-string"\u003eid [string]\u003c/h2\u003e\n\u003cp\u003eAs with all platforms, you can give a platform a different name. By\nspecifying \u003ccode\u003eid: foo\u003c/code\u003e, you can target this platform (only) by specifying\n\u003ccode\u003e-p foo\u003c/code\u003e in any of the viash commands.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eid: foo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="version-string"\u003eversion [string]\u003c/h2\u003e\n\u003cp\u003eThe version of the platform specifications. Has no significant impact\nwhen using the native platform.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eversion: \u0026quot;0.1.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:21,href:"/docs/reference_config/platform-docker/",title:"Docker Platform",description:"Run a viash component on a Docker backend platform.",content:'\u003cp\u003eBy specifying which dependencies your component needs, users will be\nable to build a docker container from scratch using the setup flag, or\npull it from a docker repository.\u003c/p\u003e\n\u003ch2 id="example"\u003eExample\u003c/h2\u003e\n\u003cp\u003eAn example of a docker platform yaml can be found below, each part of\nwhich is explained in more depth in the following sections.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e- type: docker\n  id: custom_platform_name\n  image: bash:4.0\n  version: \u0026quot;0.1.0\u0026quot;\n  target_image: myorganisation/example_docker\n  chown: true\n  port: [80, 8080]\n  workdir: /app\n  setup:\n    - type: docker\n      build_args: \n        - GITHUB_PAT=\u0026quot;$GITHUB_PAT\u0026quot;\n    - type: apt\n      packages:\n        - imagemagick\n    - type: r\n      cran:\n        - tidyverse\n        - dynutils\n    - type: docker\n      run: \n        - \u0026quot;git clone https://github.com/data-intuitive/randpy.git\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="id-string"\u003eid [string]\u003c/h2\u003e\n\u003cp\u003eAs with all platforms, you can give a platform a different name. By\nspecifying \u003ccode\u003eid: foo\u003c/code\u003e, you can target this platform (only) by specifying\n\u003ccode\u003e-p foo\u003c/code\u003e in any of the viash commands.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eid: foo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="version-string"\u003eversion [string]\u003c/h2\u003e\n\u003cp\u003eThe version of the platform specifications. This will automatically be\nused as a tag for the target docker image name.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eversion: \u0026quot;0.1.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="image-string"\u003eimage [string]\u003c/h2\u003e\n\u003cp\u003eThe base container to start from.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eimage: \u0026quot;bash:4.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="target_image-string"\u003etarget_image [string]\u003c/h2\u003e\n\u003cp\u003eIf anything is specified in the \u003ccode\u003esetup\u003c/code\u003e section, running the \u003ccode\u003e---setup\u003c/code\u003e\nwill result in a container with the name of \u003ccode\u003e\u0026lt;target_image\u0026gt;:\u0026lt;version\u0026gt;\u003c/code\u003e.\nIf nothing is specified in the \u003ccode\u003esetup\u003c/code\u003e section, simply \u003ccode\u003eimage\u003c/code\u003e will be\nused.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003etarget_image: myfoo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="chown-boolean"\u003echown [boolean]\u003c/h2\u003e\n\u003cp\u003eIn Linux, files created by a Docker container will be owned by \u003ccode\u003eroot\u003c/code\u003e.\nWith \u003ccode\u003echown: true\u003c/code\u003e, viash will automatically change the ownership of\noutput files (arguments with \u003ccode\u003etype: file\u003c/code\u003e and \u003ccode\u003edirection: output\u003c/code\u003e) to\nthe user running the viash command after execution of the component.\nDefault value: \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003echown: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="port-list-of-strings"\u003eport [list of strings]\u003c/h2\u003e\n\u003cp\u003eA list of enabled ports. This doesn’t change the Dockerfile but gets\nadded as a command-line argument at runtime.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eport:\n  - 80\n  - 8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="workdir-string"\u003eworkdir [string]\u003c/h2\u003e\n\u003cp\u003eThe working directory when starting the container. This doesn’t change\nthe Dockerfile but gets added as a command-line argument at runtime.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003eworkdir: /home/user\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="setup-list"\u003esetup [list]\u003c/h2\u003e\n\u003cp\u003eA list of requirements for installing apt, apk, R, Python, JavaScript\npackages or specifying other Docker setup instructions. The order in\nwhich these dependencies are specified determines the order in which\nthey will be installed.\u003c/p\u003e\n\u003ch3 id="r-requirements-list"\u003eR requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which R packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup: \n  - type: r\n    cran: [ dynutils ]\n    bioc: [ AnnotationDbi ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ rcannood/SCORPIUS ]\n    gitlab: [ org/package ]\n    svn: [ https://path.to.svn/group/repo ]\n    url: [ https://github.com/hadley/stringr/archive/HEAD.zip ]\n    script: [ \'devtools::install(\u0026quot;.\u0026quot;)\' ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="python-requirements-list"\u003ePython requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which Python packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: python\n    pip: [ numpy ]\n    git: [ https://some.git.repository/org/repo ]\n    github: [ jkbr/httpie ]\n    gitlab: [ foo/bar ]\n    mercurial: [ http://... ]\n    svn: [ http://...]\n    bazaar: [ http://... ]\n    url: [ http://... ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="javascript-requirements-list"\u003eJavaScript requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which JavaScript packages should be available in order to run\nthe component.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: javascript\n    npm: [ packagename ]\n    git: [ https://... ]\n    github: [ owner/repository ]\n    url: [ https://... ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="aptitude-requirements-list"\u003eAptitude requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which apt packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: apt\n    packages: [ sl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="alpine-requirements-list"\u003eAlpine requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which apk packages should be available in order to run the\ncomponent.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: apk\n    packages: [ sl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="docker-requirements-list"\u003eDocker requirements [list]\u003c/h3\u003e\n\u003cp\u003eSpecify which Docker commands should be run during setup.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003esetup:\n  - type: docker\n    build_args: [ GITHUB_PAT=hello_world ]\n    run: [ git clone ... ]\n    resources: \n      - resource.txt /path/to/resource.txt\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:22,href:"/docs/reference_config/platform-nextflow/",title:"Nextflow Platform",description:"Run a viash component as a Nextflow module.",content:""},{id:23,href:"/docs/reference_config/file_formats/",title:"Regarding file formats",description:"A viash config can be written as a standalone YAML or can be included as a header in the script itself.",content:'\u003cp\u003eThe following two file formats are equivalent.\u003c/p\u003e\n\u003ch2 id="config-format"\u003eConfig format\u003c/h2\u003e\n\u003cp\u003eMetadata \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello\n  arguments:\n    - name: \u0026quot;name\u0026quot;\n      type: string\n      default: Bob\n  resources:\n    - type: bash_script\n      path: script.sh\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScript \u003ccode\u003escript.sh\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/bin/bash\necho Hello $par_name\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="script-format"\u003eScript format\u003c/h2\u003e\n\u003cp\u003eScript \u003ccode\u003escript.vsh.sh\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/bin/bash\n\n#\' functionality:\n#\'   name: hello\n#\'   arguments:\n#\'     - name: \u0026quot;name\u0026quot;\n#\'       type: string\n#\'       default: Bob\n#\' platforms:\n#\' - type: native\n\necho Hello $par_name\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:24,href:"/docs/reference_config/config_mods/",title:"Dynamic Config Modding",description:"The config can be dynamically altered from the command line to change the component's behaviour during the build-stage.",content:"\u003cp\u003eSince version 0.4.0, viash supports modifying a \u003ca href=\"/docs/reference_config/config/\"\u003eviash\nconfig\u003c/a\u003e YAML at runtime using a custom\nDSL. This allows making dynamic changes to your components or projects.\nAll viash subcommands have support for the DSL through the\n\u003ccode\u003e-c|--config_mod\u003c/code\u003e parameter.\u003c/p\u003e\n\u003cp\u003eThe easiest way to explain is perhaps by showing some examples. The\nfollowing statements are all valid under the DSL definition.\u003c/p\u003e\n\u003cp\u003eChanging the version of a component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.functionality.version := \u0026quot;0.3.0\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eChanging the registry of docker containers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdding an author to the list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.functionality.authors += { name: \u0026quot;Mr. T\u0026quot;, role: \u0026quot;sponsor\u0026quot; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese commands come in really handy when building a lot of components,\nfor example using the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eviash ns build \\\n  -c '.functionality.version := \u0026quot;0.3.0\u0026quot;' \\\n  -c '.platforms[.type == \u0026quot;docker\u0026quot;].container_registry := \u0026quot;url-to-registry\u0026quot;' \\\n  -c '.functionality.authors += { name: \u0026quot;Mr. T\u0026quot;, role: \u0026quot;sponsor\u0026quot; }'\n\u003c/code\u003e\u003c/pre\u003e\n"},{id:25,href:"/docs/help/frequently_asked_questions/",title:"Frequently Asked Questions",description:"Frequently Asked Questions",content:'\u003ch2 id="running-components"\u003eRunning Components\u003c/h2\u003e\n\u003ch3 id="running-a-component-throws-an-unable-to-find-image-error-how-do-i-fix-this"\u003eRunning a component throws an ‘Unable to find image’ error. How do I fix this?\u003c/h3\u003e\n\u003cp\u003eDepending on how an executable was created, a Docker container might not\nhave been created.\u003c/p\u003e\n\u003cp\u003eTo solve this issue, run the executable with a \u003ccode\u003e---setup\u003c/code\u003e flag attached.\nThis will automatically build the Docker container for you.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e$ target/docker/foo/foo ---setup\n\u0026gt; docker build -t foo:0.0.1 /home/rcannood/workspace/viash_temp/viashsetupdocker-foo-KeBjFs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr when working with \u003ccode\u003eviash run\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e$ viash run src/mnn/config.vsh.yaml -- ---setup\n\u0026gt; docker build -t foo:0.0.1 /home/rcannood/workspace/viash_temp/viashsetupdocker-foo-KeBjFs\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:26,href:"/docs/contributing/guidelines/",title:"Contributing Guidelines",description:"",content:'\u003ch2 id="to-do"\u003eto do.\u003c/h2\u003e\n'},{id:27,href:"/docs/contributing/conduct/",title:"Code of Conduct",description:"Contributor Covenant Code of Conduct",content:'\u003ch2 id="our-pledge"\u003eOur Pledge\u003c/h2\u003e\n\u003cp\u003eWe as members, contributors, and leaders pledge to make participation in\nour community a harassment-free experience for everyone, regardless of\nage, body size, visible or invisible disability, ethnicity, sex\ncharacteristics, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance,\nrace, religion, or sexual identity and orientation.\u003c/p\u003e\n\u003cp\u003eWe pledge to act and interact in ways that contribute to an open,\nwelcoming, diverse, inclusive, and healthy community.\u003c/p\u003e\n\u003ch2 id="our-standards"\u003eOur Standards\u003c/h2\u003e\n\u003cp\u003eExamples of behavior that contributes to a positive environment for our\ncommunity include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDemonstrating empathy and kindness toward other people\u003c/li\u003e\n\u003cli\u003eBeing respectful of differing opinions, viewpoints, and experiences\u003c/li\u003e\n\u003cli\u003eGiving and gracefully accepting constructive feedback\u003c/li\u003e\n\u003cli\u003eAccepting responsibility and apologizing to those affected by our\nmistakes, and learning from the experience\u003c/li\u003e\n\u003cli\u003eFocusing on what is best not just for us as individuals, but for the\noverall community\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExamples of unacceptable behavior include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe use of sexualized language or imagery, and sexual attention or\nadvances of any kind\u003c/li\u003e\n\u003cli\u003eTrolling, insulting or derogatory comments, and personal or\npolitical attacks\u003c/li\u003e\n\u003cli\u003ePublic or private harassment\u003c/li\u003e\n\u003cli\u003ePublishing others’ private information, such as a physical or email\naddress, without their explicit permission\u003c/li\u003e\n\u003cli\u003eOther conduct which could reasonably be considered inappropriate in\na professional setting\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="enforcement-responsibilities"\u003eEnforcement Responsibilities\u003c/h2\u003e\n\u003cp\u003eCommunity leaders are responsible for clarifying and enforcing our\nstandards of acceptable behavior and will take appropriate and fair\ncorrective action in response to any behavior that they deem\ninappropriate, threatening, offensive, or harmful.\u003c/p\u003e\n\u003cp\u003eCommunity leaders have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other\ncontributions that are not aligned to this Code of Conduct, and will\ncommunicate reasons for moderation decisions when appropriate.\u003c/p\u003e\n\u003ch2 id="scope"\u003eScope\u003c/h2\u003e\n\u003cp\u003eThis Code of Conduct applies within all community spaces, and also\napplies when an individual is officially representing the community in\npublic spaces. Examples of representing our community include using an\nofficial e-mail address, posting via an official social media account,\nor acting as an appointed representative at an online or offline event.\u003c/p\u003e\n\u003ch2 id="enforcement"\u003eEnforcement\u003c/h2\u003e\n\u003cp\u003eInstances of abusive, harassing, or otherwise unacceptable behavior may\nbe reported to the community leaders responsible for enforcement at\n[\u003ca href="mailto:admin@data-intuitive.com"\u003eadmin@data-intuitive.com\u003c/a\u003e]. All complaints will be reviewed and\ninvestigated promptly and fairly.\u003c/p\u003e\n\u003cp\u003eAll community leaders are obligated to respect the privacy and security\nof the reporter of any incident.\u003c/p\u003e\n\u003ch2 id="enforcement-guidelines"\u003eEnforcement Guidelines\u003c/h2\u003e\n\u003cp\u003eCommunity leaders will follow these Community Impact Guidelines in\ndetermining the consequences for any action they deem in violation of\nthis Code of Conduct:\u003c/p\u003e\n\u003ch3 id="1-correction"\u003e1. Correction\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: Use of inappropriate language or other behavior\ndeemed unprofessional or unwelcome in the community.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A private, written warning from community leaders,\nproviding clarity around the nature of the violation and an explanation\nof why the behavior was inappropriate. A public apology may be\nrequested.\u003c/p\u003e\n\u003ch3 id="2-warning"\u003e2. Warning\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: A violation through a single incident or series of\nactions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, for a specified period of\ntime. This includes avoiding interactions in community spaces as well as\nexternal channels like social media. Violating these terms may lead to a\ntemporary or permanent ban.\u003c/p\u003e\n\u003ch3 id="3-temporary-ban"\u003e3. Temporary Ban\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: A serious violation of community standards,\nincluding sustained inappropriate behavior.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No\npublic or private interaction with the people involved, including\nunsolicited interaction with those enforcing the Code of Conduct, is\nallowed during this period. Violating these terms may lead to a\npermanent ban.\u003c/p\u003e\n\u003ch3 id="4-permanent-ban"\u003e4. Permanent Ban\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity Impact\u003c/strong\u003e: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior, harassment of an\nindividual, or aggression toward or disparagement of classes of\nindividuals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConsequence\u003c/strong\u003e: A permanent ban from any sort of public interaction\nwithin the community.\u003c/p\u003e\n\u003ch2 id="attribution"\u003eAttribution\u003c/h2\u003e\n\u003cp\u003eThis Code of Conduct is adapted from the \u003ca href="https://www.contributor-covenant.org"\u003eContributor\nCovenant\u003c/a\u003e, version 2.0, available\nat\n\u003ca href="https://www.contributor-covenant.org/version/2/0/code_of_conduct.html"\u003ehttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCommunity Impact Guidelines were inspired by \u003ca href="https://github.com/mozilla/diversity"\u003eMozilla’s code of conduct\nenforcement ladder\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor answers to common questions about this code of conduct, see the FAQ\nat \u003ca href="https://www.contributor-covenant.org/faq"\u003ehttps://www.contributor-covenant.org/faq\u003c/a\u003e. Translations are\navailable at \u003ca href="https://www.contributor-covenant.org/translations"\u003ehttps://www.contributor-covenant.org/translations\u003c/a\u003e.\u003c/p\u003e\n'},{id:28,href:"/docs/contributing/dev_environment/",title:"Dev Environment",description:"Installation requirements and instructions.",content:'\u003ch2 id="building-from-source"\u003eBuilding from source\u003c/h2\u003e\n\u003cp\u003eThe following needs to be installed on your system in order to install\nviash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGNU\n\u003ca href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html#Autotools-Introduction"\u003eAutotools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eOpenJDK\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://www.scala-sbt.org/"\u003esbt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo build and install viash, run the following commands.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure --prefix=~\nmake\nmake install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you wish to install viash for all users and not just yourself, run\nthe following commands instead.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure\nmake\nsudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="building-from-source-using-docker"\u003eBuilding from source using docker\u003c/h2\u003e\n\u003cp\u003eIf you have Java and Docker installed (but not \u003ccode\u003esbt\u003c/code\u003e), run this instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure --prefix=~\nmake docker\nmake install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="ide-setup"\u003eIDE setup\u003c/h2\u003e\n\u003c!-- todo: document --\u003e\n'},{id:29,href:"/docs/contributing/",title:"Contributing",description:"Contributing",content:""},{id:30,href:"/docs/creating_components/",title:"Creating Components",description:"Creating Components",content:""},{id:31,href:"/docs/creating_pipelines/",title:"Creating Pipelines",description:"Creating Pipelines",content:""},{id:32,href:"/docs/help/",title:"Help",description:"Help",content:""},{id:33,href:"/docs/prologue/",title:"Prologue",description:"Prologue",content:"\u003cp\u003eContent\u003c/p\u003e\n"},{id:34,href:"/docs/reference_commands/",title:"Reference: Commands",description:"Reference: Commands",content:""},{id:35,href:"/docs/reference_config/",title:"Reference: Config",description:"Reference: Config",content:""},{id:36,href:"/docs/",title:"Docs",description:"viash documentation",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()