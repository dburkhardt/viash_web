var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/docs/creating_components/bash/",title:"Creating a Bash component",description:"Developing a new viash component.",content:'\u003cp\u003eIn this tutorial, you’ll create a component that does the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtract all hyperlinks from a markdown file\u003c/li\u003e\n\u003cli\u003eCheck if every URL is reachable\u003c/li\u003e\n\u003cli\u003eCreate a text report with the results\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe component will be able to run locally and as a docker container. In\norder to create a component you need two files: a script for the\nfunctionality and a config file that describes the component.\u003c/p\u003e\n\u003cp\u003eThe files used in this tutorial can be found here:\u003c/p\u003e\n\u003cp\u003e\u003ca href="https://github.com/data-intuitive/viash_docs/examples/md_url_checker"\u003ehttps://github.com/data-intuitive/viash_docs/examples/md_url_checker\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://www.docker.com/"\u003eDocker\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAn installation of \u003ca href="https://curl.se/"\u003ecURL\u003c/a\u003e. Install this via your\npackage manager if you don’t have it installed yet.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe recommend you take a look at the \u003ca href="/getting_started/hello_world_bash"\u003ehello world\nexample\u003c/a\u003e first to understand how\ncomponents work.\u003c/p\u003e\n\u003ch2 id="write-a-script-in-bash"\u003eWrite a script in bash\u003c/h2\u003e\n\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case a bash script.\u003cbr\u003e\nCreate a new folder named \u003cstrong\u003emy_viash_component\u003c/strong\u003e and open it. Now\ncreate a new file named \u003cstrong\u003escript.sh\u003c/strong\u003e in there and add this code as its\ncontent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e#!/usr/bin/env bash\n\n### 1 ###\n\n## VIASH START\n\npar_inputfile=\u0026quot;Testfile.md\u0026quot;\npar_domain=\u0026quot;http://www.data-intuitive.com/viash_docs\u0026quot;\npar_output=\u0026quot;output.txt\u0026quot;\n\n## VIASH END\n\namount_of_errors=0\n\necho \u0026quot;Extracting URLs\u0026quot;\n\n### 2 ###\n\n# Extract the titles and URLs from the markdown file with sed and put them into arrays\nreadarray -t title_array \u0026lt;\u0026lt;\u0026lt;$(sed -rn \'s@^.*\\[(.*)\\]\\((.*)\\).*$@\\1@p\' $par_inputfile)\nreadarray -t url_array \u0026lt;\u0026lt;\u0026lt;$(sed -rn \'s@^.*\\[(.*)\\]\\((.*)\\).*$@\\2@p\' $par_inputfile)\n\n# Get length of array\namount_of_urls=$(echo \u0026quot;${#url_array[@]}\u0026quot;)\n\necho \u0026quot;Checking $amount_of_urls URLs\u0026quot;\n\n# Clear file\n\u0026gt;$par_output\n\n### 3 ###\n\n# Iterate over the array of titles and check each URL\nfor ((n = 0; n \u0026lt; ${#title_array[*]}; n++)); do\n    title=\u0026quot;${title_array[n]}\u0026quot;\n    url=\u0026quot;${url_array[n]}\u0026quot;\n\n    ### 4 ###\n\n    # If an URL doesn\'t start with \'http\', add the domain before it\n    if [[ $url != http* ]]; then\n        url=\u0026quot;$par_domain${url_array[n]}\u0026quot;\n    fi\n\n    echo \u0026quot;$(($n + 1)): $url\u0026quot;\n\n    echo -e \u0026quot;Link name: $title\u0026quot; \u0026gt;\u0026gt;$par_output\n    echo -e \u0026quot;URL: $url\u0026quot; \u0026gt;\u0026gt;$par_output\n\n    ### 5 ###\n\n    # Do a cURL and get the status code from the last response after following any redirects\n    status_code=$(curl -ILs --max-redirs 5 $url | tac | grep -m1 HTTP)\n    expected_code=\u0026quot;200\u0026quot;\n\n    # Check if status code obtained via cURL contains the expected code\n    if [[ $status_code == *$expected_code* ]]; then\n        echo \u0026quot;OK\u0026quot;\n        echo -e \u0026quot;Status: OK, can be reached.\u0026quot; \u0026gt;\u0026gt;$par_output\n    else\n        echo $status_code\n        echo -e \u0026quot;Status: ERROR! URL cannot be reached. Status code: $status_code\u0026quot; \u0026gt;\u0026gt;$par_output\n        amount_of_errors=$(($amount_of_errors + 1))\n    fi\n\n    echo -e \u0026quot;---\u0026quot; \u0026gt;\u0026gt;$par_output\ndone\n\necho \u0026quot;\u0026quot;\necho \u0026quot;$par_inputfile has been checked and a report named $par_output has been generated.\n$amount_of_errors of $amount_of_urls URLs could not be resolved.\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the numbered comments scattered about looking like \u003ccode\u003e### x ###\u003c/code\u003e,\nhere’s a breakdown of the code:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe variables are placed between \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e\nfor debugging purposes, their final values will be dynamically\ngenerated by viash once the script is turned into a component. If\nyou want to skip the testing of your script, you can leave these out\nand viash will create variables based on the configuration file.\nThere are three variables:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epar_inputfile\u003c/code\u003e: The markdown file that needs to be parsed.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_domain\u003c/code\u003e: The domain URL that gets inserted before any\nrelative URLs. For example, “/documentation/intro” could be\nreplaced with “\u003ca href="https://my-website/documentation/intro"\u003ehttps://my-website/documentation/intro\u003c/a\u003e” to\ncreate a valid URL.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_output\u003c/code\u003e: The path of the output text file that will contain\nthe report.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe script parses the markdown file and extracts the hyperlink\ntitles and URLs using some nifty\n\u003ca href="https://www.gnu.org/software/sed/manual/sed.html"\u003esed\u003c/a\u003e regex. It\nthen puts those strings into two arrays for later use.\u003c/li\u003e\n\u003cli\u003eStart a for-loop to iterate the title array.\u003c/li\u003e\n\u003cli\u003eAny relative URLs (or those that don’t start with “http” at least)\nwill get the domain added before it.\u003c/li\u003e\n\u003cli\u003ecURL is used to check for a response from the URL. The resulting\nstatus code is stored and compared to the expected code. The results\nget written to the terminal and the report.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id="test-the-script"\u003eTest the script\u003c/h2\u003e\n\u003cp\u003eBefore turning the script into a component, it’s a good idea to test if\nit actually works as expected.\u003cbr\u003e\nAs the script expects a markdown file with hyperlinks, create a new file\nin the script folder named \u003cstrong\u003eTestfile.md\u003c/strong\u003e and paste in the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-markdown"\u003e# Test File\n\nThis is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.\nSome links to websites:\n\n- [Google](https://www.google.com)\n- [Reddit](https://www.reddit.com)\n- [A broken link](http://microsoft.com/random-link)\n\nLinks that are relative to [Viash Docs](http://www.data-intuitive.com/viash_docs/):\n\n- You can [install viash here](/getting_started/installation).\n- It\'s important to write [tests](/good_practices/testing) for your components.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow open a terminal in the folder and execute the following command to\nmake your script executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003echmod +x ./script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, run the script by executing this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./script.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe script will now show the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExtracting URLs\nChecking 6 URLs\n1: https://www.google.com\nOK\n2: https://www.reddit.com\nOK\n3: http://microsoft.com/random-link\nHTTP/2 404 \n4: http://www.data-intuitive.com/viash_docs/\nOK\n5: http://www.data-intuitive.com/viash_docs/getting_started/installation\nOK\n6: http://www.data-intuitive.com/viash_docs/good_practices/testing\nOK\n\nTestfile.md has been checked and a report named output.txt has been generated.\n1 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you get this same output, that means the script is working as\nintended! Feel free to take a peek at the generated \u003cstrong\u003eoutput.txt\u003c/strong\u003e file\nas well. You might have noticed you didn’t have to provide any\narguments, that’s because the values are hard-coded into the script for\ndebugging purposes.\u003c/p\u003e\n\u003cp\u003eNow the script has been tested, it’s time to create a config file to\ndescribe the component based on it.\u003c/p\u003e\n\u003ch2 id="describe-the-component-using-yaml"\u003eDescribe the component using YAML\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eviash config file\u003c/strong\u003e is a \u003ca href="https://yaml.org/"\u003eYAML\u003c/a\u003e file that\ndescribes the behavior and supported platforms of a viash component.\nCreate new file named \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e and paste the following\ntemplate inside of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: NAME\n  description: DESCRIPTION\n  arguments:                     \n  - type: string\n    name: --input\n    description: INPUT DESCRIPTION\n  resources:\n  - type: LANGUAGE_script\n    path: SCRIPT\nplatforms:\n  - type: native\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery config file requires these two dictionaries:\n\u003ca href="http://www.data-intuitive.com/viash_docs/getting_started/hello_world_bash/#functionality"\u003efunctionality\u003c/a\u003e\nand\n\u003ca href="http://www.data-intuitive.com/viash_docs/getting_started/hello_world_bash/#platforms"\u003eplatforms\u003c/a\u003e.\nThis bare-bones config file makes it easy to “fill in the blanks” for\nthis example. For more information about config files, you can take a\nlook at the \u003ca href="/config"\u003eConfig\u003c/a\u003e page.\u003c/p\u003e\n\u003cp\u003eLet’s start off by defining the functionality of our component.\u003c/p\u003e\n\u003ch3 id="defining-the-functionality"\u003eDefining the functionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e dictionary describes what the component does and\nthe resources it needs to do so. The first key is \u003cstrong\u003ename\u003c/strong\u003e, this will be\nthe name of the component once it’s built. Replace the \u003cstrong\u003eNAME\u003c/strong\u003e value\nwith \u003cstrong\u003emd_url_checker\u003c/strong\u003e or any other name of your choosing.\u003c/p\u003e\n\u003cp\u003eNext up is the \u003cstrong\u003edescription\u003c/strong\u003e key, its value will be printed out at the\ntop when the \u003cstrong\u003e–help\u003c/strong\u003e command is called. Replace \u003cstrong\u003eDESCRIPTION\u003c/strong\u003e with\n“\u003cstrong\u003eCheck if URLs in a markdown are reachable and create a text report\nwith the results.\u003c/strong\u003e”. You can use multiple lines for a description by\nstarting its value with a pipe (|) and a new line, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: md_url_checker\n  description: |\n    This is the first line of my description.\n    Here\'s a second line!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003cstrong\u003earguments\u003c/strong\u003e dictionary contains all of the arguments that are\naccepted by the component. These arguments will be injected as variables\nin the script. In the case of the example script, this are the variables\nwe’re working with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epar_inputfile\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_domain\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epar_output\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create good arguments, you need to ask yourself a few essential\nquestions about each variable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat is the most fitting \u003ca href="config/functionality/#arguments-list"\u003edata\ntype\u003c/a\u003e?\u003c/li\u003e\n\u003cli\u003eIs it an input or an output?\u003c/li\u003e\n\u003cli\u003eIs it required?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s take a closer look at \u003ccode\u003epar_inputfile\u003c/code\u003e for starters:\u003c/p\u003e\n\u003cp\u003eWe know it’s a file, as the script needs the path to a markdown \u003cstrong\u003efile\u003c/strong\u003e\nas its \u003cstrong\u003einput\u003c/strong\u003e. It’s also definitely a \u003cstrong\u003erequired\u003c/strong\u003e variable, as the\nscript would be pointless without it.\u003cbr\u003e\nWith this in mind, modify the first argument as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChange \u003cstrong\u003etype\u003c/strong\u003e’s value to \u003cstrong\u003efile\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eSet \u003cstrong\u003ename\u003c/strong\u003e’s value to \u003cstrong\u003e–inputfile\u003c/strong\u003e. The name of an argument has\nto match the variable name as the argument will be injected into the\nfinal script. In the case of \u003cstrong\u003ebash\u003c/strong\u003e scripts, the variable name\ngets a \u003cstrong\u003e‘par_’\u003c/strong\u003e prefix add to it. This is the reason why the\nscript variables all start with \u003cstrong\u003e‘par_’\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eUse “\u003cstrong\u003eThe input markdown file.\u003c/strong\u003e” for the \u003cstrong\u003edescription\u003c/strong\u003e value.\nThis description will be included when the \u003cstrong\u003e–help\u003c/strong\u003e option is\ncalled.\u003c/li\u003e\n\u003cli\u003eAdd a new key named \u003cstrong\u003erequired\u003c/strong\u003e and set its value to \u003cstrong\u003etrue\u003c/strong\u003e. This\nensures that the component will not be run without a value for this\nargument.\u003c/li\u003e\n\u003cli\u003eAdd another key, name it \u003cstrong\u003emust_exist\u003c/strong\u003e and set its value to\n\u003cstrong\u003etrue\u003c/strong\u003e. This key is unique to \u003cstrong\u003efile\u003c/strong\u003e type arguments, it adds\nextra logic to the component to check if a file exists before\nrunning the component. This saves you from having to do this check\nyourself in the script.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat’s it for the first argument! The result should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow for \u003ccode\u003epar_domain\u003c/code\u003e, this is a simple \u003cstrong\u003eoptional string\u003c/strong\u003e that gets\nadded before relative URLs. Make room for a new argument by creating a\nnew line below \u003ccode\u003emust_exist: true\u003c/code\u003e and press \u003cstrong\u003eShift + Tab\u003c/strong\u003e to back up\none tab so the cursor is aligned with the start of the first argument.\nAdd the \u003ccode\u003e--domain\u003c/code\u003e argument here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf an argument isn’t required, you can simply omit the \u003cstrong\u003erequired\u003c/strong\u003e key.\nAgain, the variable name in the script will get the **’_par’**\nprefix added automatically in bash scripts. Here’s what the arguments\ndictionary look like up until now:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  arguments:                     \n  - type: file\n    name: --inputfile\n    description: The input markdown file.\n    required: true\n    must_exist: true\n  - type: string                           \n    name: --domain\n    description: The domain URL that gets inserted before any relative URLs. For example, \u0026quot;/documentation/intro\u0026quot; could be replaced with \u0026quot;https://my-website/documentation/intro\u0026quot; to create a valid URL.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe final variable to create an argument for is \u003ccode\u003epar_output\u003c/code\u003e. This is\nanother \u003cstrong\u003efile\u003c/strong\u003e and clearly an \u003cstrong\u003eoutput\u003c/strong\u003e. Its value \u003cstrong\u003eisn’t required\u003c/strong\u003e\nas we can use a \u003cstrong\u003edefault\u003c/strong\u003e path if no explicit value is given.\u003cbr\u003e\nAdd yet another new argument with the following keys and values:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdd a \u003cstrong\u003etype\u003c/strong\u003e key and set \u003cstrong\u003efile\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eThe next key is \u003cstrong\u003ename\u003c/strong\u003e, use \u003cstrong\u003e–output\u003c/strong\u003e as its value.\u003c/li\u003e\n\u003cli\u003eFor the \u003cstrong\u003edescription\u003c/strong\u003e, use “\u003cstrong\u003eThe path of the output text file\nthat will contain the report.\u003c/strong\u003e”.\u003c/li\u003e\n\u003cli\u003eAdd a new key and name it \u003cstrong\u003edefault\u003c/strong\u003e. This will act as the default\nvalue when not specified by the user of the component. Set its value\nto \u003cstrong\u003e“output.txt”\u003c/strong\u003e, including the quotation marks.\u003c/li\u003e\n\u003cli\u003eFinally, add the \u003cstrong\u003edirection\u003c/strong\u003e key and set its value to \u003cstrong\u003eoutput\u003c/strong\u003e.\nThis specifies the direction of an argument as either \u003cstrong\u003einput\u003c/strong\u003e or\n\u003cstrong\u003eoutput\u003c/strong\u003e, with input being the default. Specifying that an\nargument is an output is important so the component can correctly\nhandle the writing of files and the passing of values in a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe finished argument should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: file                           \n    name: --output\n    description: The path of the output text file that will contain the report.\n    default: \u0026quot;output.txt\u0026quot;\n    direction: output\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith that, there’s just one more part of the functionality to fill in:\nthe script itself!\u003cbr\u003e\nEvery viash component has one or more resources, the most important of\nwhich is often the script. The template already contains a \u003cstrong\u003eresources\u003c/strong\u003e\ndictionary, so replace the following values to point to the script:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSet the value of \u003cstrong\u003etype\u003c/strong\u003e to \u003cstrong\u003ebash_script\u003c/strong\u003e. The script used in\nthis case was written in \u003cstrong\u003ebash\u003c/strong\u003e, so the resource type is set\naccordingly so viash knows what flavor of code to generate to create\nthe final component. You can find a full overview of the different\nresource types on the \u003ca href="/config/functionality/#resources-list"\u003eFunctionality\npage\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eChange the value of \u003cstrong\u003epath\u003c/strong\u003e to \u003cstrong\u003escript.sh\u003c/strong\u003e. This points to the\nresource and can be a relative path, an absolute path or even a URL.\nIn this case we keep the script in the same directory as the config\nfile to keep things simple.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat finishes up the functionality side of the component! All that’s\nleft is defining the platforms with their dependencies and then running\nand building the component.\u003c/p\u003e\n\u003ch3 id="defining-the-platforms"\u003eDefining the platforms\u003c/h3\u003e\n\u003cp\u003eThe platforms dictionary specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms are specified, a\nnative platform is assumed. Here’s a quick overview of the platforms:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003enative\u003c/strong\u003e: The platform for developers that know what they’re doing\nor for simple components without any dependencies. All dependencies\nneed to be installed on the system the component is run on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edocker\u003c/strong\u003e: This platform is recommended for most components. The\ndependencies are resolved by using \u003ca href="https://www.docker.com/"\u003edocker\u003c/a\u003e\ncontainers, either from scratch or by pulling one from a docker\nrepository. This has huge benefits as the end user doesn’t need to\nhave any of the dependencies installed locally.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enextflow\u003c/strong\u003e: This converts the component into a\n\u003ca href="https://www.nextflow.io/"\u003eNextFlow\u003c/a\u003e module that can be imported\ninto a pipeline.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn this tutorial, we’ll take a look at both the native and docker\nplatforms. The platforms are also defined in the \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e\nfile at the very bottom. The native platform is actually already defined\nin the template, that one \u003cstrong\u003etype\u003c/strong\u003e key with a value of \u003cstrong\u003enative\u003c/strong\u003e is\nenough! Now for adding the docker platform, add a new line below the\nlast and add the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  - type: docker\n    image: bash:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells viash that this component can be built to a docker container\nwith the \u003ca href="https://hub.docker.com/_/bash"\u003elatest bash image\u003c/a\u003e as its base.\nIf your script doesn’t depend on any packages, this would be all you’d\nhave to add when using a bash script. The script in our example however\nneeds \u003cstrong\u003ecurl\u003c/strong\u003e installed to work. Luckily, this isn’t a problem since\nviash \u003ca href="config/platform-docker/#example"\u003esupports defining dependencies\u003c/a\u003e\nwhich then get pulled from inside the docker container before running\nthe script. To add curl as a dependancy that needs to be installed, add\nthese lines below \u003ccode\u003eimage: bash:latest\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e    setup:\n      - type: apk\n        packages: [ curl ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will prompt the\n\u003ca href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management"\u003eapk\u003c/a\u003e\npackage manager to download and install curl inside of the container.\nThat’s it for the config! Be sure to save it and let’s move on to\nactually running the component you’ve created. For reference, you can\ntake a look at the completed \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file in \u003ca href="https://github.com/data-intuitive/viash_docs/tree/master/examples/md_url_checker/config.vsh.yaml"\u003eour Github\nrepository\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="run-the-component"\u003eRun the component\u003c/h2\u003e\n\u003cp\u003eTime to run the component! First off, let’s see what the output of\n\u003ccode\u003e--help\u003c/code\u003e is. To do that, open a terminal in the \u003cstrong\u003emy_viash_component\u003c/strong\u003e\nfolder and execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will show the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCheck if URLs in a markdown are reachable and create a text report with the results.\n\nOptions:\n    --inputfile=file\n        type: file, required parameter\n        The input markdown file.\n\n    --domain=string\n        type: string\n        The domain URL that gets inserted before any relative URLs. For example, /documentation/intro could be replaced with https://my-website/documentation/intro to create a valid URL.\n\n    --output=file\n        type: file, default: output.txt\n        The path of the output text file that will contain the report.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the values you entered into the config file are all\nhere.\u003cbr\u003e\nNext, let’s run the component natively with some arguments. You can use\none of your own markdown files as the input if you desire. In that case,\nreplace \u003cstrong\u003eTestfile.md\u003c/strong\u003e in the command with the path to your file.\u003cbr\u003e\nExecute the following command to run the component with the default\nplatform, in this case \u003cstrong\u003enative\u003c/strong\u003e as it’s the first in the \u003cstrong\u003eplatforms\u003c/strong\u003e\ndictionary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run config.vsh.yaml -- --inputfile=Testfile.md --domain=http://www.data-intuitive.com/viash_docs/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all goes well, you’ll see something like this output in the terminal\nand a file named \u003cstrong\u003emy_report.txt\u003c/strong\u003e will have appeared:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExtracting URLs\nChecking 6 URLs\n1: https://www.google.com\nOK\n2: https://www.reddit.com\nOK\n3: http://microsoft.com/random-link\nHTTP/2 404 \n4: http://www.data-intuitive.com/viash_docs/\nOK\n5: http://www.data-intuitive.com/viash_docs//getting_started/installation\nOK\n6: http://www.data-intuitive.com/viash_docs//good_practices/testing\nOK\n\nTestfile.md has been checked and a report named my_report.txt has been generated.\n1 of 6 URLs could not be resolved.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor more information on the run command, take a look at \u003ca href="/commands/run/"\u003ethe viash run\ncommand page\u003c/a\u003e. Great! With that working, the next step\nis building an executable.\u003c/p\u003e\n\u003ch2 id="building-an-executable"\u003eBuilding an executable\u003c/h2\u003e\n\u003cp\u003eYou can generate an executable using either the native or the docker\nplatform. The former will generate a file that can be run locally, but\ndepends on your locally installed software packages to work. A docker\nexecutable on the other hand can build and start up a docker container\nthat handles the dependencies for you.\u003cbr\u003e\nTo create a native build, execute the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA new folder named \u003cstrong\u003eoutput\u003c/strong\u003e will have been created with an executable\ninside named \u003cstrong\u003emd_url_checker\u003c/strong\u003e. To test it out, execute the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eoutput/md_url_checker --inputfile=Testfile.md --domain=http://www.data-intuitive.com/viash_docs/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is the same as by running the component, but the executable\ncan be easily shared and now includes the ability to feed arguments to\nit and an included \u003ccode\u003e--help\u003c/code\u003e command. Not bad!\u003cbr\u003e\nNext up is the docker executable. You can specify the platform with the\n\u003ccode\u003e-p\u003c/code\u003e argument and choose an output folder using \u003ccode\u003e-o\u003c/code\u003e, apart from that\nit’s the same as the previous build command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build -p docker -o docker_output config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll now have a \u003cstrong\u003edocker_ouput\u003c/strong\u003e folder alongside the \u003cstrong\u003eoutput\u003c/strong\u003e one.\nThis folder also contains a file named \u003cstrong\u003emd_url_checker\u003c/strong\u003e, but its\ninner workings are slightly different than before. Run\n\u003cstrong\u003emd_url_checker\u003c/strong\u003e with the full arguments list to test what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003edocker_output/md_url_checker --inputfile=Testfile.md --domain=http://www.data-intuitive.com/viash_docs/ --output=my_report.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s what just happened:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the docker image wasn’t found, viash will download it.\u003c/li\u003e\n\u003cli\u003eA check is made to see if a container named “md_url_checker”\nexists. If not, one will be built with the image defined in the\nconfig as its base.\u003c/li\u003e\n\u003cli\u003eAll dependencies defined in the config are taken care of.\u003c/li\u003e\n\u003cli\u003eThe script is run with the passed arguments and the output is passed\nto your shell. The \u003cstrong\u003emy_report.txt\u003c/strong\u003e file is written to your\nworking directory.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor more information about the \u003ccode\u003eviash build\u003c/code\u003e command, take a look at\n\u003ca href="/commands/build/"\u003eits command page\u003c/a\u003e. That concludes the building of\nexecutables based on components using viash!\u003c/p\u003e\n\u003ch2 id="writing-and-running-a-unit-test"\u003eWriting and running a unit test\u003c/h2\u003e\n\u003cp\u003eTo finish off this tutorial, it’s important to talk about unit tests. To\nensure that your component works as expected during its development\ncycle, writing one or more tests is essential. Luckily, writing a unit\ntest for a viash component is straightforward.\u003c/p\u003e\n\u003cp\u003eYou just need to add test parameters in the config file and write a\nscript which runs the executable and verifies the output. When running\ntests, viash will automatically build an executable and place it\nalongside the other defined resources in a temporary working directory.\nTo get started, open up \u003cstrong\u003econfig.vsh.yaml\u003c/strong\u003e file again and add this at\nthe end of the functionality dictionary, between the \u003ccode\u003epath: script.sh\u003c/code\u003e\nand \u003ccode\u003eplatforms:\u003c/code\u003e lines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e  tests:\n  - type: bash_script\n    path: test.sh\n  - path: Testfile.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis test dictionary contains a reference to the test script and all of\nthe files that need to be copied over in order to complete a test. In\nthe case of our example, \u003cstrong\u003etest.sh\u003c/strong\u003e will be the test script and\n\u003cstrong\u003eTestfile.md\u003c/strong\u003e is necessary as an input markdown file is required for\nthe script to function. Now create a new file named \u003cstrong\u003etest.sh\u003c/strong\u003e in the\n\u003cstrong\u003emy_viash_component\u003c/strong\u003e folder and add this as its content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eset -ex # exit the script when one of the checks fail and output all commands.\n\n# check 1\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\u0026quot;\n\n# run compononent with required input(s)\n./md_url_checker --inputfile Testfile.md \u0026gt; test-output.txt\n\n[[ ! -f test-output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Test output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\ngrep -q \'1: https://www.google.com\' test-output.txt # Did the script find the URL?\ngrep -q \'HTTP/2 404\' test-output.txt  # Did the web request return a 404 for the page that doesn\'t exist?\n\n# check 2\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\u0026quot;\n\n[[ ! -f output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\ngrep -q \'URL: https://www.google.com\' output.txt # Was the URL written correctly in the report?\ngrep -q \'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404\' output.txt # Was the error written correctly in the report?\ngrep -q \'Link name: install viash here\' output.txt # Was link name written correctly in the report?\n\necho \u0026quot;\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\u0026quot;\nexit 0 # don\'t forget to put this at the end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis bash script will run the component and perform several checks to\nits output. A successful test runs all the way down and exits with a \u003cstrong\u003e0\nexit code\u003c/strong\u003e, any other code means a failure:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eset -ex\u003c/code\u003e will stop the script once any of the lines fail and will\noutput all commands to the shell with a ‘+’ before it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./md_url_checker --inputfile Testfile.md \u0026gt; test-output.txt\u003c/code\u003e runs\nthe component and writes its output to a file.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e[[ ! -f test-output.txt ]] \u0026amp;\u0026amp; echo \u0026quot;Test output file could not be found!\u0026quot; \u0026amp;\u0026amp; exit 1\u003c/code\u003e\nchecks is the output file exists, if it doesn’t exit with a 1 code.\u003c/li\u003e\n\u003cli\u003eAll of the \u003ccode\u003egrep\u003c/code\u003e calls check if a certain piece of text could be\nfound. Each of these calls can exit the script if the text wasn’t\nfound.\u003c/li\u003e\n\u003cli\u003eIf everything succeeded, exit with a 0 code. Make sure not to forget\nthis final line in your own tests.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMake sure both the config and test files are saved, then run a test by\nrunning this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash test config.vsh.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRunning tests in temporary directory: \'/tmp/viash_test_md_url_checker2079467967227629939\'\n====================================================================\n+/tmp/viash_test_md_url_checker2079467967227629939/build_executable/md_url_checker ---setup\n====================================================================\n+/tmp/viash_test_md_url_checker2079467967227629939/test_test.sh/test.sh\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\'\n\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\n+ ./md_url_checker --inputfile Testfile.md\n+ [[ ! -f test-output.txt ]]\n+ grep -q \'1: https://www.google.com\' test-output.txt\n+ grep -q \'HTTP/2 404\' test-output.txt\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\'\n\u0026gt;\u0026gt;\u0026gt; Checking whether an output file was created correctly\n+ [[ ! -f output.txt ]]\n+ grep -q \'URL: https://www.google.com\' output.txt\n+ grep -q \'Status: ERROR! URL cannot be reached. Status code: HTTP/2 404\' output.txt\n+ grep -q \'Link name: install viash here\' output.txt\n+ echo \'\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\'\n\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\n+ exit 0\n====================================================================\n\u001b[32mSUCCESS! All 1 out of 1 test scripts succeeded!\u001b[0m\nCleaning up temporary directory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the test succeeds it simply writes the full output to the shell. If\nthere’s any issues, the script stops and an error message will appear in\nred. For more information on tests take a look at the \u003ca href="/good_practices/testing/"\u003eTesting\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow you’re ready to use viash to creating components from your own\nscripts, check out the rest of our documentation on the left. Here are\nsome good starting points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003ca href="/commands/"\u003eviash commands\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="/config/functionality/"\u003eoverview of the functionality\ndictionary\u003c/a\u003e of the config file\u003c/li\u003e\n\u003cli\u003eMore details about \u003ca href="/config/platform-docker/"\u003ethe docker platform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:1,href:"/docs/prologue/introduction/",title:"Introduction",description:"viash helps you turn a script (Bash/R/Python/Scala/JavaScript) into a reusable component.",content:'\u003c!-- TODO: What is viash if you would describe it in one or two sentences?\nviash is a ... --\u003e\n\u003cp\u003eBy providing some meta-data regarding its functionality and the platform\non which you want to run the software, viash can help you:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWrap your script in an executable with a CLI and \u003ccode\u003e--help\u003c/code\u003e\nfunctionality.\u003c/li\u003e\n\u003cli\u003eSeamlessly execute your component natively on the host platform or\nin a \u003cstrong\u003eDocker\u003c/strong\u003e container.\u003c/li\u003e\n\u003cli\u003eCombine multiple components in a \u003cstrong\u003eNextflow\u003c/strong\u003e pipeline.\u003c/li\u003e\n\u003cli\u003eUnit-test your component to ensure that it works at all times.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="example-use-cases"\u003eExample use cases\u003c/h2\u003e\n\u003cp\u003eHere are a few use cases which serve as motivation for viash:\u003c/p\u003e\n\u003c!-- TODO: Rewrite use cases, the reason why viash helps in those situations should be crystal clear to someone that has never seen viash before, this part of the docs is presented before the installation after all. Ideally each of these should have "viash can help here by../In this case, viash can.../etc." --\u003e\n\u003cul\u003e\n\u003cli\u003eYou want to combine several tools in a pipeline and every tool has\nspecific requirements on how they should be run. Even worse: some\nrequirements might directly conflict with each other.\u003c/li\u003e\n\u003cli\u003eYour next data analysis project is very similar to the previous\nproject, so you copy and paste the source code. Unfortunately, you\ndetect a bug in some of your code, so now you need to go back and\nfix the same bug in all the different projects.\u003c/li\u003e\n\u003cli\u003eYou want to look back at a data analysis you performed two years\nago. Unfortunately, the software you used back then is not supported\nanymore, or the newest version produces totally different results.\nWith viash you can package the older version together with its\ndependencies in an executable so you don’t have to worry about\nconflicts or deprecated versions\u003c/li\u003e\n\u003cli\u003eYou developed a \u003ca href="https://jupyter.org/"\u003eJupyter\u003c/a\u003e notebook report for\na data analysis. You wish to share it with your colleague, only to\nspend two hours installing your \u003ca href="https://docs.conda.io/"\u003eConda\u003c/a\u003e\nstack on their laptop.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="getting-started"\u003eGetting started\u003c/h2\u003e\n\u003cp\u003eHere are some links to get you started with viash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/installation"\u003eInstalling viash\u003c/a\u003e: This guide walks\nyou through the steps to install viash on your machine.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_bash"\u003eRunning your first component\n(Bash)\u003c/a\u003e: Get a feel for viash\nwith a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial, written in Bash.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_python"\u003eRunning your first component\n(Python)\u003c/a\u003e: Get a feel for viash\nwith a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial, written in Python.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_r"\u003eRunning your first component (R)\u003c/a\u003e:\nGet a feel for viash with a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial,\nwritten in R.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="documentation"\u003eDocumentation\u003c/h2\u003e\n\u003cp\u003eOnce you understand how viash works and what it could do for you, take a\nlook at our docs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/commands"\u003eCommands\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/config"\u003eConfig files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/good_practices"\u003eGood practices\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCheck out the navigation menu on the left for more in-depth information\nabout each topic.\u003c/p\u003e\n'},{id:2,href:"/docs/reference/ns-list/",title:"viash ns list",description:"",content:'\u003ch1 id="viash-ns-list"\u003eviash ns list\u003c/h1\u003e\n\u003cp\u003eList a namespace containing many \u003ca href="/config"\u003eviash config\u003c/a\u003e files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash ns list [-n nmspc] [-s src] [-p docker] [--tsv file.tsv]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-l, --parallel\u003c/code\u003e: Whether or not to run the process in parallel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Acts as a regular expression to filter the\nplatform ids specified in the found config files. If this is not\nprovided, all platforms will be used. If no platforms are defined in\na config, the native platform will be used. In addition, the path to\na platform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-q, --query  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which components get selected by name\nand namespace. Can be a regex. Example: “^mynamespace/component1$”.\n–query_name \u003carg\u003e Filter which components get selected by name. Can\nbe a regex. Example: “^component1”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-n, --query_namespace  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which namespaces get selected\nby namespace. Can be a regex. Example: “^mynamespace$”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --src  \u0026lt;arg\u0026gt;\u003c/code\u003e: A source directory containing \u003ca href="/config"\u003eviash\nconfig\u003c/a\u003e files, possibly structured in a hierarchical folder\nstructure. Default: src/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-t, --tsv  \u0026lt;arg\u0026gt;\u003c/code\u003e: Path to write a summary of the list results to.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:3,href:"/docs/reference/run/",title:"viash run",description:"",content:'\u003ch1 id="viash-run"\u003eviash run\u003c/h1\u003e\n\u003cp\u003eExecutes a viash component from the provided \u003ca href="/config"\u003eviash config\u003c/a\u003e\nfile. viash generates a temporary executable and immediately executes it\nwith the given parameters.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash run config.vsh.yaml [-p docker] [-k true/false]  -- [arguments for script]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation. (default = List())\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:4,href:"/docs/creating_components/python/",title:"Creating a Python component",description:"Developing a new viash component.",content:'\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case a Python script.\u003c/p\u003e\n\u003ch4 id="write-a-script-in-python"\u003eWrite a script in Python\u003c/h4\u003e\n\u003cp\u003eThis is a simple script which prints a simple message, along with any\ninput provided to it through the \u003ccode\u003epar[\u0026quot;input\u0026quot;]\u003c/code\u003e parameter. Optionally,\nyou can override the greeter with \u003ccode\u003epar[\u0026quot;greeter\u0026quot;]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="script.py"\u003e\u003ccode\u003escript.py\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003e## VIASH START\npar = {\n  \u0026quot;input\u0026quot;: [\u0026quot;I am debug!\u0026quot;],\n  \u0026quot;greeter\u0026quot;: \u0026quot;Hello world!\u0026quot;\n}\n\n## VIASH END\n\nif par[\u0026quot;input\u0026quot;] is None:\n  par[\u0026quot;input\u0026quot;] = []\n\nprint(par[\u0026quot;greeter\u0026quot;], *par[\u0026quot;input\u0026quot;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnything between the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines will\nautomatically be replaced at runtime with parameter values from the CLI.\nAnything between these two lines can be used to test the script without\nviash:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003epython script.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world! I am debug!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we write a meta-file describing the functionality of this\ncomponent in YAML format.\u003c/p\u003e\n\u003ch4 id="describe-the-component-with-as-a-yaml"\u003eDescribe the component with as a YAML\u003c/h4\u003e\n\u003cp\u003eA \u003ca href="config"\u003eviash config\u003c/a\u003e file describes the behaviour of a script and\nthe platform it runs on. It consists of two main sections:\n\u003ccode\u003efunctionality\u003c/code\u003e and \u003ccode\u003eplatforms\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="config.vsh.yaml"\u003e\u003ccode\u003eyaml\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003efunctionality:\n  name: hello_world_py\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: python_script\n    path: script.py\n  tests:\n  - type: python_script\n    path: test.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;python:3.8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href="config/functionality"\u003efunctionality\u003c/a\u003e section describes the core\nfunctionality of the component, such as its inputs, outputs, arguments,\nand extra resources. For each of the arguments, specifying a description\nand a set of argument restrictions help create a useful command-line\ninterface. To ensure that your component works as expected, writing one\nor more tests is essential.\u003c/p\u003e\n\u003cp\u003eThe platforms section specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms are specified, a\nnative platform with no system requirements is assumed.\u003c/p\u003e\n\u003ch3 id="writing-a-first-unit-test"\u003eWriting a first unit test\u003c/h3\u003e\n\u003cp\u003eWriting a unit test for a viash component is relatively simple. You just\nneed to write a Bash script (or R, or Python) which runs the executable\nmultiple times, and verifies the output. Take note that the test needs\nto produce an error code not equal to 0 when a mistake is found.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="test.py"\u003e\u003ccode\u003etest.py\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eimport unittest\nimport os\nfrom os import path\nimport subprocess\n\nclass Tester(unittest.TestCase):\n    def simple_test(self):\n        out = subprocess.check_output([\u0026quot;./hello_world_py\u0026quot;, \u0026quot;I\u0026quot;, \u0026quot;am\u0026quot;, \u0026quot;viash\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertEqual(out, \u0026quot;Hello world! I am viash\\n\u0026quot;)\n        \n    def less_params(self):\n        out = subprocess.check_output([\u0026quot;./hello_world_py\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertEqual(out, \u0026quot;Hello world!\\n\u0026quot;)\n        \n    def simple_test(self):\n        out = subprocess.check_output([\u0026quot;./hello_world_py\u0026quot;, \u0026quot;General\u0026quot;, \u0026quot;Kenobi\u0026quot;, \u0026quot;--greeter=Hello there.\u0026quot;]).decode(\u0026quot;utf-8\u0026quot;)\n        self.assertEqual(out, \u0026quot;Hello there. General Kenobi.\\n\u0026quot;)\n\nunittest.main()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen running the test, viash will automatically build an executable and\nplace it – along with other resources and test resources – in a\ntemporary working directory.\u003c/p\u003e\n'},{id:5,href:"/docs/prologue/installation/",title:"Installation",description:"Installation requirements and instructions.",content:'\u003ch2 id="supported-operating-systems"\u003eSupported Operating Systems\u003c/h2\u003e\n\u003cp\u003eYou can run viash on the following operating systems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003emacOS\u003c/li\u003e\n\u003cli\u003eWindows using \u003ca href="https://docs.microsoft.com/en-us/windows/wsl/install-win10"\u003eWindows Subsystem for\nLinux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eviash is developed in \u003ca href="https://www.scala-lang.org/"\u003eScala 2.12\u003c/a\u003e, so\nyou’ll need an \u003ca href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html"\u003eOracle Java SE Runtime Environment 8\ninstallation\u003c/a\u003e\nin order to use it.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="installing-viash"\u003eInstalling viash\u003c/h2\u003e\n\u003ch3 id="packaged-release"\u003ePackaged release\u003c/h3\u003e\n\u003cp\u003eTo install viash, download the \u003ca href="https://github.com/data-intuitive/viash/releases/latest"\u003elatest\nrelease\u003c/a\u003e and\nsave it to the \u003ccode\u003e~/bin\u003c/code\u003e folder or any other directory that is specified\nyour \u003ccode\u003e$PATH\u003c/code\u003e variable. To verify what directories are included, run this\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eecho $PATH\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="installing-viash-to-bin"\u003eInstalling viash to ~/bin\u003c/h4\u003e\n\u003cp\u003eIn order to add \u003ccode\u003e~/bin\u003c/code\u003e to your $PATH, you need to edit \u003ccode\u003e~/.bashrc\u003c/code\u003e and\nadd the following line to the end of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eexport PATH=\u0026quot;$HOME/bin:$PATH\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can use nano for this for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003enano ~/.bashrc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, create a \u003ccode\u003e~/bin\u003c/code\u003e folder, reload $PATH, download the latest release\nof viash to \u003ccode\u003e~/bin\u003c/code\u003e and add executable permissions to viash. Here’s a\none-liner command that does this for you:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emkdir ~/bin ; source ~/.bashrc \u0026amp;\u0026amp;\nwget \u0026quot;https://github.com/data-intuitive/viash/releases/latest/download/viash\u0026quot; -O ~/bin/viash \u0026amp;\u0026amp;\nchmod +x ~/bin/viash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Replace \u003ccode\u003e~/.bashrc\u003c/code\u003e with \u003ccode\u003e~/.zshrc\u003c/code\u003e in the command above if\nyou’re using ZSH instead of Bash.\u003c/p\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="installing-viash-to-usrbin"\u003eInstalling viash to /usr/bin\u003c/h4\u003e\n\u003cp\u003eIf you wish to install viash to your usr/bin folder instead, run the\nfollowing command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003esudo wget \u0026quot;https://github.com/data-intuitive/viash/releases/latest/download/viash\u0026quot; -O /usr/bin/viash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="build-from-source"\u003eBuild from source\u003c/h3\u003e\n\u003cp\u003eThe following needs to be installed on your system in order to install\nviash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGNU\n\u003ca href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html#Autotools-Introduction"\u003eAutotools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html"\u003eOracle Java SE Runtime Environment 8\ninstallation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://www.scala-sbt.org/"\u003esbt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo build and install viash, run the following commands.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure --prefix=~\nmake\nmake install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you wish to install viash for all users and not just yourself, run\nthe following commands instead.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure\nmake\nsudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="build-from-source-using-docker"\u003eBuild from source using docker\u003c/h3\u003e\n\u003cp\u003eIf you have Java and Docker installed, but not \u003ccode\u003esbt\u003c/code\u003e, run this instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure --prefix=~\nmake docker\nmake install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:6,href:"/docs/reference/build/",title:"viash build",description:"",content:'\u003ch1 id="viash-build"\u003eviash build\u003c/h1\u003e\n\u003cp\u003eBuild an executable from the provided \u003ca href="/config"\u003eviash config\u003c/a\u003e file.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash build config.vsh.yaml -o output [-p docker] [-m] [-s]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation. (default = List())\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-m, --meta\u003c/code\u003e: Print out some meta information at the end.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-o, --output  \u0026lt;arg\u0026gt;\u003c/code\u003e: Path to directory in which the executable and\nany resources is built to. Default: “output/”. (default = output/)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified. –push Whether or not to\npush the container to a Docker registry [Docker Platform only].\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --setup\u003c/code\u003e: Whether or not to set up the platform environment\nafter building the executable.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-w, --write_meta\u003c/code\u003e: Write out some meta information to\nRESOURCES_DIR/viash.yaml at the end.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:7,href:"/docs/creating_components/r/",title:"Creating an R component",description:"Developing a new viash component.",content:'\u003cp\u003eThe first step of developing this component, is writing the core\nfunctionality of the component, in this case an R script.\u003c/p\u003e\n\u003ch4 id="write-a-script-in-r"\u003eWrite a script in R\u003c/h4\u003e\n\u003cp\u003eThis is a simple script which prints a simple message, along with any\ninput provided to it through the \u003ccode\u003epar[\u0026quot;input\u0026quot;]\u003c/code\u003e parameter. Optionally,\nyou can override the greeter with \u003ccode\u003epar[\u0026quot;greeter\u0026quot;]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="script.R"\u003e\u003ccode\u003escript.R\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e## VIASH START\npar \u0026lt;- list(\n  input = \u0026quot;I am debug!\u0026quot;,\n  greeter = \u0026quot;Hello world!\u0026quot;\n)\n\n## VIASH END\n\ncat(par$greeter, \u0026quot; \u0026quot;, paste(par$input, collapse = \u0026quot; \u0026quot;), \u0026quot;\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnything between the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines will\nautomatically be replaced at runtime with parameter values from the CLI.\nAnything between these two lines can be used to test the script without\nviash:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eRscript script.R\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e## Hello world! I am debug!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we write a meta-file describing the functionality of this\ncomponent in YAML format.\u003c/p\u003e\n\u003ch4 id="describe-the-component-with-as-a-yaml"\u003eDescribe the component with as a YAML\u003c/h4\u003e\n\u003cp\u003eA \u003ca href="/config"\u003eviash config\u003c/a\u003e file describes the behaviour of a script and\nthe platform it runs on. It consists of two main sections:\n\u003ccode\u003efunctionality\u003c/code\u003e and \u003ccode\u003eplatforms\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="config.vsh.yaml"\u003e\u003ccode\u003eyaml\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003efunctionality:\n  name: hello_world_r\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: r_script\n    path: script.R\n  tests:\n  - type: r_script\n    path: test.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;rocker/tidyverse:4.0.4\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href="/config/functionality"\u003efunctionality\u003c/a\u003e section describes the core\nfunctionality of the component, such as its inputs, outputs, arguments,\nand extra resources. For each of the arguments, specifying a description\nand a set of argument restrictions help create a useful command-line\ninterface. To ensure that your component works as expected, writing one\nor more tests is essential.\u003c/p\u003e\n\u003cp\u003eThe platforms section specifies the requirements to execute the\ncomponent on zero or more platforms. The list of currently supported\nplatforms are \u003ca href="/config/platform-native"\u003eNative\u003c/a\u003e,\n\u003ca href="/config/platform-docker"\u003eDocker\u003c/a\u003e, and\n\u003ca href="/config/platform-nextflow"\u003eNextflow\u003c/a\u003e. If no platforms are specified, a\nnative platform with no system requirements is assumed.\u003c/p\u003e\n\u003ch3 id="writing-a-first-unit-test"\u003eWriting a first unit test\u003c/h3\u003e\n\u003cp\u003eWriting a unit test for a viash component is relatively simple. You just\nneed to write a Bash script (or R, or Python) which runs the executable\nmultiple times, and verifies the output. Take note that the test needs\nto produce an error code not equal to 0 when a mistake is found.\u003c/p\u003e\n\u003cp\u003eContents of \u003ca href="test.R"\u003e\u003ccode\u003etest.R\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003elibrary(testthat)\nlibrary(processx)\n\n# check 1\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./hello_world_r\u0026quot;, c(\u0026quot;I\u0026quot;, \u0026quot;am\u0026quot;, \u0026quot;viash!\u0026quot;))\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;Hello world! I am viash!\u0026quot;)\n\n# check 2\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct when no parameters are given\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./hello_world_r\u0026quot;)\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;Hello world!\u0026quot;)\n\n# check 3\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Checking whether output is correct when more parameters are given\\n\u0026quot;)\nout \u0026lt;- processx::run(\u0026quot;./hello_world_r\u0026quot;, args = c(\u0026quot;General\u0026quot;, \u0026quot;Kenobi.\u0026quot;, \u0026quot;--greeter=Hello there.\u0026quot;))\nexpect_equal(out$status, 0)\nexpect_match(out$stdout, regexp = \u0026quot;Hello there. General Kenobi.\u0026quot;)\n\ncat(\u0026quot;\u0026gt;\u0026gt;\u0026gt; Test finished successfully!\\n\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen running the test, viash will automatically build an executable and\nplace it – along with other resources and test resources – in a\ntemporary working directory.\u003c/p\u003e\n'},{id:8,href:"/docs/prologue/supported_languages/",title:"Supported languages",description:"You can use several programming languages with viash to write your own components. To get started with your preferred language, take a look at the language specific Hello World examples and the [Creating components](/creating_components) section. ",content:'\u003ch2 id="bash"\u003eBash\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_bash"\u003eBash Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for Bash.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e: This\ntutorial explains how to create your own viash component from\nscratch using a Bash script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="python"\u003ePython\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_python"\u003ePython Hello World example\u003c/a\u003e:\nAn introduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for Python.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e: This\ntutorial explains how to create your own viash component from\nscratch using a Python script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="r"\u003eR\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_r"\u003eR Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for R.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e: This tutorial\nexplains how to create your own viash component from scratch using\nan R script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="scala"\u003eScala\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="javascript"\u003eJavascript\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="c"\u003eC\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n'},{id:9,href:"/docs/reference/test/",title:"viash test",description:"",content:'\u003ch1 id="viash-test"\u003eviash test\u003c/h1\u003e\n\u003cp\u003eTest the component using the tests defined in the \u003ca href="/config"\u003eviash\nconfig\u003c/a\u003e file.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash test config.vsh.yaml [-p docker] [-k true/false]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation. (default = List())\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:10,href:"/docs/reference/config-view/",title:"viash config view",description:"",content:'\u003ch1 id="viash-config-view"\u003eviash config view\u003c/h1\u003e\n\u003cp\u003eView the config file after parsing.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash config view config.vsh.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econfig\u003c/code\u003e: A viash config file (example: \u003ccode\u003econfig.vsh.yaml\u003c/code\u003e). This\nargument can also be a script with the config as a header.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Specifies which platform amongst those\nspecified in the config to use. If this is not provided, the first\nplatform will be used. If no platforms are defined in the config,\nthe native platform will be used. In addition, the path to a\nplatform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:11,href:"/docs/prologue/hello_world_bash/",title:"Hello World (Bash)",description:"We have provided a simple **Hello World** component as an introduction to viash. Follow the steps below to learn how to run a component and get a result back from it.",content:'\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="https://viash.io/examples/hello_world/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: bash_script\n    path: script.sh\n  tests:\n  - type: bash_script\n    path: test.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world/script.sh"\u003e\u003ccode\u003escript.sh\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small Bash script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e## VIASH START\npar_input=\u0026quot;I am debug!\u0026quot;\npar_greeter=\u0026quot;Hello world!\u0026quot;\n## VIASH END\n\necho $par_greeter $par_input\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nand adding the \u003ccode\u003epar_\u003c/code\u003e prefix, their values will automatically be\nreplaced at runtime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. You can read more about writing and\nrunning viash tests \u003ca href="https://viash.io/good_practices/testing/"\u003eon the Testing\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/config/platform-native/"\u003eNative\u003c/a\u003e, \u003ca href="/config/platform-docker/"\u003eDocker\u003c/a\u003e,\nand \u003ca href="/config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:12,href:"/docs/reference/ns-build/",title:"viash ns build",description:"",content:'\u003ch1 id="viash-ns-build"\u003eviash ns build\u003c/h1\u003e\n\u003cp\u003eBuild a namespace from many \u003ca href="/config"\u003eviash config\u003c/a\u003e files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash ns build [-n nmspc] [-s src] [-t target] [-p docker] [--setup] [---push] [--parallel] [--flatten]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-f, --flatten\u003c/code\u003e: Flatten the target builds, handy for building one\nplatform to a bin directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-l, --parallel\u003c/code\u003e: Whether or not to run the process in parallel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Acts as a regular expression to filter the\nplatform ids specified in the found config files. If this is not\nprovided, all platforms will be used. If no platforms are defined in\na config, the native platform will be used. In addition, the path to\na platform yaml file can also be specified. –push Whether or not to\npush the container to a Docker registry [Docker Platform only].\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-q, --query  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which components get selected by name\nand namespace. Can be a regex. Example: “^mynamespace/component1$”.\n–query_name \u003carg\u003e Filter which components get selected by name. Can\nbe a regex. Example: “^component1”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-n, --query_namespace  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which namespaces get selected\nby namespace. Can be a regex. Example: “^mynamespace$”. –setup\nWhether or not to set up the platform environment after building the\nexecutable.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --src  \u0026lt;arg\u0026gt;\u003c/code\u003e: A source directory containing \u003ca href="/config"\u003eviash\nconfig\u003c/a\u003e files, possibly structured in a hierarchical folder\nstructure. Default: src/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-t, --target  \u0026lt;arg\u0026gt;\u003c/code\u003e: A target directory to build the executables\ninto. Default: target/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-w, --write_meta\u003c/code\u003e: Write out some meta information to\nRESOURCES_DIR/viash.yaml at the end.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:13,href:"/docs/prologue/hello_world_python/",title:"Hello World (Python)",description:"We have provided a simple **Hello World** component as an introduction to viash. Follow the steps below to learn how to run a component and get a result back from it.",content:'\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://www.python.org/downloads"\u003einstallation of python 3\u003c/a\u003e. You\nmay have to install the \u003ccode\u003epython-is-python3\u003c/code\u003e package on Ubuntu and\nits derivatives to make Python 3 the default version.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world_py/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="https://viash.io/examples/hello_world_py/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world_py\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: python_script\n    path: script.py\n  tests:\n  - type: python_script\n    path: test.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;python:3.8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world_py/script.py"\u003e\u003ccode\u003escript.py\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small Python script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003e## VIASH START\npar = {\n  \u0026quot;input\u0026quot;: [\u0026quot;I am debug!\u0026quot;],\n  \u0026quot;greeter\u0026quot;: \u0026quot;Hello world!\u0026quot;\n}\n\n## VIASH END\n\nif par[\u0026quot;input\u0026quot;] is None:\n  par[\u0026quot;input\u0026quot;] = []\n\nprint(par[\u0026quot;greeter\u0026quot;], *par[\u0026quot;input\u0026quot;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nin a \u003ccode\u003epar\u003c/code\u003e dictionary. Their values will automatically be replaced at\nruntime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. You can read more about writing and\nrunning viash tests \u003ca href="https://viash.io/good_practices/testing/"\u003eon the Testing\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/config/platform-native/"\u003eNative\u003c/a\u003e, \u003ca href="/config/platform-docker/"\u003eDocker\u003c/a\u003e,\nand \u003ca href="/config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- Mike. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, Mike.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world_py\u003c/strong\u003e in a (new)\nfolder named \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world_py NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:14,href:"/docs/reference/ns-test/",title:"viash ns test",description:"",content:'\u003ch1 id="viash-ns-test"\u003eviash ns test\u003c/h1\u003e\n\u003cp\u003eTest a namespace containing many \u003ca href="/config"\u003eviash config\u003c/a\u003e files.\u003c/p\u003e\n\u003cp\u003eUsage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e  viash ns test [-n nmspc] [-s src] [-p docker] [--parallel] [--tsv file.tsv] [--append]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-a, --append\u003c/code\u003e: Append to tsv instead of overwrite\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-c, --config_mod  \u0026lt;arg\u0026gt;...\u003c/code\u003e: Modify a \u003ca href="/config"\u003eviash config\u003c/a\u003e at\nruntime using a custom DSL. For more information, see the online\ndocumentation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-k, --keep  \u0026lt;arg\u0026gt;\u003c/code\u003e: Whether or not to keep temporary files. By\ndefault, files will be deleted if all goes well but remain when an\nerror occurs. By specifying –keep true, the temporary files will\nalways be retained, whereas –keep false will always delete them. The\ntemporary directory can be overwritten by setting defining a\nVIASH_TEMP directory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-l, --parallel\u003c/code\u003e: Whether or not to run the process in parallel.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-p, --platform  \u0026lt;arg\u0026gt;\u003c/code\u003e: Acts as a regular expression to filter the\nplatform ids specified in the found config files. If this is not\nprovided, all platforms will be used. If no platforms are defined in\na config, the native platform will be used. In addition, the path to\na platform yaml file can also be specified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-q, --query  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which components get selected by name\nand namespace. Can be a regex. Example: “^mynamespace/component1$”.\n–query_name \u003carg\u003e Filter which components get selected by name. Can\nbe a regex. Example: “^component1”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-n, --query_namespace  \u0026lt;arg\u0026gt;\u003c/code\u003e: Filter which namespaces get selected\nby namespace. Can be a regex. Example: “^mynamespace$”.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s, --src  \u0026lt;arg\u0026gt;\u003c/code\u003e: A source directory containing \u003ca href="/config"\u003eviash\nconfig\u003c/a\u003e files, possibly structured in a hierarchical folder\nstructure. Default: src/.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-t, --tsv  \u0026lt;arg\u0026gt;\u003c/code\u003e: Path to write a summary of the test results to.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-h, --help\u003c/code\u003e: Show help message\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:15,href:"/docs/prologue/hello_world_r/",title:"Hello World (R)",description:"You can use several programming languages with viash to write your own components. To get started with your preferred language, take a look at the language specific Hello World examples and the [Creating components](/creating_components) section. ",content:'\u003ch1 id="hello-world"\u003eHello world\u003c/h1\u003e\n\u003cp\u003eWe have provided a simple \u003cstrong\u003eHello World\u003c/strong\u003e component as an introduction\nto viash. Follow the steps below to learn how to run a component and get\na result back from it.\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://cran.r-project.org/mirrors.html"\u003einstallation of the R software\nenvironment\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=https://viash.io/examples/hello_world_r/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world! \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow Does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="https://viash.io/examples/hello_world_r/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world_r\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: r_script\n    path: script.R\n  tests:\n  - type: r_script\n    path: test.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;rocker/tidyverse:4.0.4\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="https://viash.io/examples/hello_world_r/script.r"\u003e\u003ccode\u003escript.r\u003c/code\u003e\u003c/a\u003e. This\nfile is the ‘brain’ of the component, it’s small R script which prints\nout two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-r"\u003e## VIASH START\npar \u0026lt;- list(\n  input = \u0026quot;I am debug!\u0026quot;,\n  greeter = \u0026quot;Hello world!\u0026quot;\n)\n\n## VIASH END\n\ncat(par$greeter, \u0026quot; \u0026quot;, paste(par$input, collapse = \u0026quot; \u0026quot;), \u0026quot;\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nin a \u003ccode\u003epar\u003c/code\u003e list. Their values will automatically be replaced at runtime\nwith parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. You can read more about writing and\nrunning viash tests \u003ca href="https://viash.io/good_practices/testing/"\u003eon the Testing\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/config/platform-native/"\u003eNative\u003c/a\u003e, \u003ca href="/config/platform-docker/"\u003eDocker\u003c/a\u003e,\nand \u003ca href="/config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- Mike. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, Mike.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world_r\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world_r NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:16,href:"/docs/creating_components/",title:"Creating components",description:"Creating components",content:""},{id:17,href:"/docs/prologue/",title:"Prologue",description:"Prologue",content:"\u003cp\u003eContent\u003c/p\u003e\n"},{id:18,href:"/docs/reference/",title:"Reference",description:"Reference",content:""},{id:19,href:"/docs/",title:"Docs",description:"viash documentation",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()