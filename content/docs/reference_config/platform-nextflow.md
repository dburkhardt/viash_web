---
title: "Nextflow Platform"
description: "Run a viash component as a Nextflow module."
lead: "Run a viash component as a Nextflow module."
date: 2021-05-28T14:00:00+00:00
lastmod: "2021-06-01T20:09:45+00:00"
draft: false
images: []
menu:
  docs:
    parent: "reference_config"
weight: 550
toc: true
---



## Example

This is an example of a NextFlow platform definition:

``` yaml
...
platforms:
  ...
  - type: nextflow
    publish: true
    per_id: true
    label: highmem
```

### `id`

The platform definition can be given a unique identifier, which is
especially useful when multiple `type: nextflow` platform definitions
are present for the same component/module:

-   `id` is optional
-   No default value if used

### `image`, `tag`/`version` and `registry`

If no image attributes are configured, viash will use an auto-generated
image name:

    [<namespace>/]<name>:<version>

This name corresponds to the one given by the Docker platform when a
custom build is required. This means that it will only work when a
docker platform definition is used that applies customizations.

If no customizations are applied to the docker platform, it means that
it uses a simple base image and the auto-generated name above will not
be used. It’s possible to manually configure an image to be used to run
the module in mainly two ways:

1.  By simply adding a `image: <name>:<tag>` as an attribute.
2.  By specifying the different parts of the container name explicitly:
    -   `image` for the image name
    -   `tag` or `version`: a tag for the container is fetched from the
        following (in order):
        1.  If a platform `version` is configured, use this
        2.  If a platform `tag` is configured, use it
        3.  Use the global `version` for this viash config
    -   `registry` if the image should be fetched from a remote registry

To repeat: The auto-generated image name is ideal in cases where a
custom container is built for the Docker platform, this container is
built (or can be fetched from a registry) and used in the NextFlow
platform. If no customizations are applied, one should add the correct
`image: ...` to both the `docker` and `nextflow` platform
configurations.

### `publish`

NextFlow uses the autogenerated `work` dirs to manage process IO under
the hood. In order effectively *output* something one can *publish* the
results a module or step in the pipeline. In order to do this, add
`publish: true` to the config:

-   `publish` is optional
-   Default value is `false`

This attribute simply defines if output of a component should be
published yes or no. The output location has to be provided at pipeline
launch by means of the option `--output ...` or in `nextflow.config`:

    params.output = "..."

By default, a subdirectory is created corresponding to the unique ID
that is passed in the triplet. Let us illustrate this with an example.
The following code snippet uses the value of `--input` as an input of a
workflow. The input can include a wildcard so that multiple samples can
run in parallel. We use the parent directory name
(`.getParent().baseName`) as an identifier for the sample. We pass this
as the first entry of the triplet:

``` groovy
Channel.fromPath(params.input) \
    | map{ it -> [ it.getParent().baseName , it ] } \
    | map{ it -> [ it[0] , it[1], params ] }
    | ...
```

Say the resulting sample names are `SAMPLE1` and `SAMPLE2`. The next
step in the pipeline will be published (at least by default) under:

    <output>/SAMPLE1/
    <output>/SAMPLE2/

### `path`

When `publish: true`, this attribute defines where the output is written
*relative* to the `params.output` setting. For example,
`path: processed` in combination with `--output s3://some_bucket/` will
store the output of this component under

    s3://some_bucket/processed/

This attribute gives control over the directory structure of the output.
For example:

``` yaml
path: raw_data
```

Or even:

``` yaml
path: raw_data/bcl
```

Please note that `per_id` and `path` can be combined.

### `per_id`

When `publish: true`, we already noted that a subdirectory is created
automatically per unique `id`. In order to avoid the creation of this
subdirectory, `per_id: false` can be added to the platform
configuration.

`path` (see above) is used, but if needed an additional subdirectory can
be automatically

In the previous example, given two *samples* `SAMPLE1` and `SAMPLE2`
running in parallel jobs the output would be stored under:

    s3://some_bucket/processed/SAMPLE1/<outputfiles for sample1>
    s3://some_bucket/processed/SAMPLE2/<outputfiles for sample2>

with the attribute `per_id: false` this will become:

    s3://some_bucket/processed/<outputfiles for samples 1 and 2>

Please note that all output files automatically have a unique name
attached to them (see earlier) and so not creating the unique
subdirectory is strictly speaking not necessary to avoid collisions.

-   The attribute is optional
-   The default value is `true`

### `label` / `labels`

When running the module in a cluster context and depending on the
cluster type, [NextFlow allows for attaching
labels](https://www.nextflow.io/docs/latest/process.html#label) to the
process that can later be used as selectors for associating resources to
this process.

In order to attach one label to a process/component, one can use the
`label: ...` attribute, multiple labels can be added using
`labels: [ ..., ... ]` and the two can even be mixed.

In the main `nextflow.config`, one can now use this label:

    process {
      ...
      withLabel: bigmem {
         maxForks = 5
         ...
      }
    }

### `stageInMode`

By default Nextflow will create a symbolic link to the inputs for a
process/module and run the tool at hand using those symbolic links. Some
applications do not cope well with this strategy, in that case the files
should effectively be copied rather than linked to. This can be achieved
by using `stageInMode: copy`…

-   The attribute is optional
-   The default value is `symlink`
