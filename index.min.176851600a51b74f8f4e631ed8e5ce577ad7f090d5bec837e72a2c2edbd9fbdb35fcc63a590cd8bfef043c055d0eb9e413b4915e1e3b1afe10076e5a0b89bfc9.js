var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/docs/prologue/introduction/",title:"Introduction",description:"viash helps you turn a script (Bash/R/Python/Scala/JavaScript) into a reusable component.",content:'\u003c!-- TODO: What is viash if you would describe it in one or two sentences?\nviash is a ... --\u003e\n\u003cp\u003eBy providing some meta-data regarding its functionality and the platform\non which you want to run the software, viash can help you:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWrap your script in an executable with a CLI and \u003ccode\u003e--help\u003c/code\u003e\nfunctionality.\u003c/li\u003e\n\u003cli\u003eSeamlessly execute your component natively on the host platform or\nin a \u003cstrong\u003eDocker\u003c/strong\u003e container.\u003c/li\u003e\n\u003cli\u003eCombine multiple components in a \u003cstrong\u003eNextflow\u003c/strong\u003e pipeline.\u003c/li\u003e\n\u003cli\u003eUnit-test your component to ensure that it works at all times.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="example-use-cases"\u003eExample use cases\u003c/h2\u003e\n\u003cp\u003eHere are a few use cases which serve as motivation for viash:\u003c/p\u003e\n\u003c!-- TODO: Rewrite use cases, the reason why viash helps in those situations should be crystal clear to someone that has never seen viash before, this part of the docs is presented before the installation after all. Ideally each of these should have "viash can help here by../In this case, viash can.../etc." --\u003e\n\u003cul\u003e\n\u003cli\u003eYou want to combine several tools in a pipeline and every tool has\nspecific requirements on how they should be run. Even worse: some\nrequirements might directly conflict with each other.\u003c/li\u003e\n\u003cli\u003eYour next data analysis project is very similar to the previous\nproject, so you copy and paste the source code. Unfortunately, you\ndetect a bug in some of your code, so now you need to go back and\nfix the same bug in all the different projects.\u003c/li\u003e\n\u003cli\u003eYou want to look back at a data analysis you performed two years\nago. Unfortunately, the software you used back then is not supported\nanymore, or the newest version produces totally different results.\nWith viash you can package the older version together with its\ndependencies in an executable so you don’t have to worry about\nconflicts or deprecated versions\u003c/li\u003e\n\u003cli\u003eYou developed a \u003ca href="https://jupyter.org/"\u003eJupyter\u003c/a\u003e notebook report for\na data analysis. You wish to share it with your colleague, only to\nspend two hours installing your \u003ca href="https://docs.conda.io/"\u003eConda\u003c/a\u003e\nstack on their laptop.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="getting-started"\u003eGetting started\u003c/h2\u003e\n\u003cp\u003eHere are some links to get you started with viash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/installation"\u003eInstalling viash\u003c/a\u003e: This guide walks\nyou through the steps to install viash on your machine.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_bash"\u003eRunning your first component\n(Bash)\u003c/a\u003e: Get a feel for viash\nwith a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial, written in Bash.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_python"\u003eRunning your first component\n(Python)\u003c/a\u003e: Get a feel for viash\nwith a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial, written in Python.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_r"\u003eRunning your first component (R)\u003c/a\u003e:\nGet a feel for viash with a classic \u003cstrong\u003eHello World\u003c/strong\u003e tutorial,\nwritten in R.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="documentation"\u003eDocumentation\u003c/h2\u003e\n\u003cp\u003eOnce you understand how viash works and what it could do for you, take a\nlook at our docs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/commands"\u003eCommands\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/config"\u003eConfig files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/good_practices"\u003eGood practices\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCheck out the navigation menu on the left for more in-depth information\nabout each topic.\u003c/p\u003e\n'},{id:1,href:"/docs/prologue/installation/",title:"Installation",description:"Installation requirements and instructions.",content:'\u003ch2 id="supported-operating-systems"\u003eSupported Operating Systems\u003c/h2\u003e\n\u003cp\u003eYou can run viash on the following operating systems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003cli\u003emacOS\u003c/li\u003e\n\u003cli\u003eWindows using \u003ca href="https://docs.microsoft.com/en-us/windows/wsl/install-win10"\u003eWindows Subsystem for\nLinux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eviash is developed in \u003ca href="https://www.scala-lang.org/"\u003eScala 2.12\u003c/a\u003e, so\nyou’ll need an \u003ca href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html"\u003eOracle Java SE Runtime Environment 8\ninstallation\u003c/a\u003e\nin order to use it.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="installing-viash"\u003eInstalling viash\u003c/h2\u003e\n\u003ch3 id="packaged-release"\u003ePackaged release\u003c/h3\u003e\n\u003cp\u003eTo install viash, download the \u003ca href="https://github.com/data-intuitive/viash/releases/latest"\u003elatest\nrelease\u003c/a\u003e and\nsave it to the \u003ccode\u003e~/bin\u003c/code\u003e folder or any other directory that is specified\nyour \u003ccode\u003e$PATH\u003c/code\u003e variable. To verify what directories are included, run this\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eecho $PATH\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="installing-viash-to-bin"\u003eInstalling viash to ~/bin\u003c/h4\u003e\n\u003cp\u003eIn order to add \u003ccode\u003e~/bin\u003c/code\u003e to your $PATH, you need to edit \u003ccode\u003e~/.bashrc\u003c/code\u003e and\nadd the following line to the end of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eexport PATH=\u0026quot;$HOME/bin:$PATH\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can use nano for this for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003enano ~/.bashrc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, create a \u003ccode\u003e~/bin\u003c/code\u003e folder, reload $PATH, download the latest release\nof viash to \u003ccode\u003e~/bin\u003c/code\u003e and add executable permissions to viash. Here’s a\none-liner command that does this for you:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emkdir ~/bin ; source ~/.bashrc \u0026amp;\u0026amp;\nwget \u0026quot;https://github.com/data-intuitive/viash/releases/latest/download/viash\u0026quot; -O ~/bin/viash \u0026amp;\u0026amp;\nchmod +x ~/bin/viash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Replace \u003ccode\u003e~/.bashrc\u003c/code\u003e with \u003ccode\u003e~/.zshrc\u003c/code\u003e in the command above if\nyou’re using ZSH instead of Bash.\u003c/p\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="installing-viash-to-usrbin"\u003eInstalling viash to /usr/bin\u003c/h4\u003e\n\u003cp\u003eIf you wish to install viash to your usr/bin folder instead, run the\nfollowing command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003esudo wget \u0026quot;https://github.com/data-intuitive/viash/releases/latest/download/viash\u0026quot; -O /usr/bin/viash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="build-from-source"\u003eBuild from source\u003c/h3\u003e\n\u003cp\u003eThe following needs to be installed on your system in order to install\nviash:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGNU\n\u003ca href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html#Autotools-Introduction"\u003eAutotools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html"\u003eOracle Java SE Runtime Environment 8\ninstallation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://www.scala-sbt.org/"\u003esbt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo build and install viash, run the following commands.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure --prefix=~\nmake\nmake install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you wish to install viash for all users and not just yourself, run\nthe following commands instead.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure\nmake\nsudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id="build-from-source-using-docker"\u003eBuild from source using docker\u003c/h3\u003e\n\u003cp\u003eIf you have Java and Docker installed, but not \u003ccode\u003esbt\u003c/code\u003e, run this instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e./configure --prefix=~\nmake docker\nmake install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify your installation, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash --help\n\u003c/code\u003e\u003c/pre\u003e\n'},{id:2,href:"/docs/prologue/supported_languages/",title:"Supported languages",description:"You can use several programming languages with viash to write your own components. To get started with your preferred language, take a look at the language specific Hello World examples and the [Creating components](/creating_components) section. ",content:'\u003ch2 id="bash"\u003eBash\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_bash"\u003eBash Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for Bash.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e: This\ntutorial explains how to create your own viash component from\nscratch using a Bash script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="python"\u003ePython\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_python"\u003ePython Hello World example\u003c/a\u003e:\nAn introduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for Python.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e: This\ntutorial explains how to create your own viash component from\nscratch using a Python script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="r"\u003eR\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/getting_started/hello_world_r"\u003eR Hello World example\u003c/a\u003e: An\nintroduction to how viash works using a variation on the classic\n“Hello World” programming example. This example is written\nspecifically for R.\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e: This tutorial\nexplains how to create your own viash component from scratch using\nan R script at its core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="scala"\u003eScala\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="javascript"\u003eJavascript\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n\u003ch2 id="c"\u003eC\u003c/h2\u003e\n\u003cp\u003eThe documentation for this language is still in progress.\u003c/p\u003e\n'},{id:3,href:"/docs/prologue/hello_world_bash/",title:"Hello World (Bash)",description:"You can use several programming languages with viash to write your own components. To get started with your preferred language, take a look at the language specific Hello World examples and the [Creating components](/creating_components) section. ",content:'\u003ch1 id="hello-world"\u003eHello world\u003c/h1\u003e\n\u003cp\u003eWe have provided a simple \u003cstrong\u003eHello World\u003c/strong\u003e component as an introduction\nto viash. Follow the steps below to learn how to run a component and get\na result back from it.\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=http://www.data-intuitive.com/viash_docs/examples/hello_world/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="http://www.data-intuitive.com/viash_docs/examples/hello_world/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: bash_script\n    path: script.sh\n  tests:\n  - type: bash_script\n    path: test.sh\nplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="http://www.data-intuitive.com/viash_docs/examples/hello_world/script.sh"\u003e\u003ccode\u003escript.sh\u003c/code\u003e\u003c/a\u003e.\nThis file is the ‘brain’ of the component, it’s small Bash script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003e## VIASH START\npar_input=\u0026quot;I am debug!\u0026quot;\npar_greeter=\u0026quot;Hello world!\u0026quot;\n## VIASH END\n\necho $par_greeter $par_input\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nand adding the \u003ccode\u003epar_\u003c/code\u003e prefix, their values will automatically be\nreplaced at runtime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. You can read more about writing and\nrunning viash tests \u003ca href="http://www.data-intuitive.com/viash_docs/good_practices/testing/"\u003eon the Testing\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/config/platform-native/"\u003eNative\u003c/a\u003e, \u003ca href="/config/platform-docker/"\u003eDocker\u003c/a\u003e,\nand \u003ca href="/config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:4,href:"/docs/prologue/hello_world_python/",title:"Hello World (Python)",description:"You can use several programming languages with viash to write your own components. To get started with your preferred language, take a look at the language specific Hello World examples and the [Creating components](/creating_components) section. ",content:'\u003ch1 id="hello-world"\u003eHello world\u003c/h1\u003e\n\u003cp\u003eWe have provided a simple \u003cstrong\u003eHello World\u003c/strong\u003e component as an introduction\nto viash. Follow the steps below to learn how to run a component and get\na result back from it.\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://www.python.org/downloads"\u003einstallation of python 3\u003c/a\u003e. You\nmay have to install the \u003ccode\u003epython-is-python3\u003c/code\u003e package on Ubuntu and\nits derivatives to make Python 3 the default version.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=http://www.data-intuitive.com/viash_docs/examples/hello_world_py/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="http://www.data-intuitive.com/viash_docs/examples/hello_world_py/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world_py\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: python_script\n    path: script.py\n  tests:\n  - type: python_script\n    path: test.py\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;python:3.8\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="http://www.data-intuitive.com/viash_docs/examples/hello_world_py/script.py"\u003e\u003ccode\u003escript.py\u003c/code\u003e\u003c/a\u003e.\nThis file is the ‘brain’ of the component, it’s small Python script\nwhich prints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-python"\u003e## VIASH START\npar = {\n  \u0026quot;input\u0026quot;: [\u0026quot;I am debug!\u0026quot;],\n  \u0026quot;greeter\u0026quot;: \u0026quot;Hello world!\u0026quot;\n}\n\n## VIASH END\n\nif par[\u0026quot;input\u0026quot;] is None:\n  par[\u0026quot;input\u0026quot;] = []\n\nprint(par[\u0026quot;greeter\u0026quot;], *par[\u0026quot;input\u0026quot;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nin a \u003ccode\u003epar\u003c/code\u003e dictionary. Their values will automatically be replaced at\nruntime with parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. You can read more about writing and\nrunning viash tests \u003ca href="http://www.data-intuitive.com/viash_docs/good_practices/testing/"\u003eon the Testing\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/config/platform-native/"\u003eNative\u003c/a\u003e, \u003ca href="/config/platform-docker/"\u003eDocker\u003c/a\u003e,\nand \u003ca href="/config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- Mike. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, Mike.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world_py\u003c/strong\u003e in a (new)\nfolder named \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world_py NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:5,href:"/docs/prologue/hello_world_r/",title:"Hello World (R)",description:"You can use several programming languages with viash to write your own components. To get started with your preferred language, take a look at the language specific Hello World examples and the [Creating components](/creating_components) section. ",content:'\u003ch1 id="hello-world"\u003eHello world\u003c/h1\u003e\n\u003cp\u003eWe have provided a simple \u003cstrong\u003eHello World\u003c/strong\u003e component as an introduction\nto viash. Follow the steps below to learn how to run a component and get\na result back from it.\u003c/p\u003e\n\u003ch2 id="prerequisites"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along with this tutorial, you need to have this software\ninstalled on your machine:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn \u003ca href="/getting_started/installation"\u003einstallation of viash\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eBash\u003c/strong\u003e Unix shell.\u003c/li\u003e\n\u003cli\u003eAn \u003ca href="https://cran.r-project.org/mirrors.html"\u003einstallation of the R software\nenvironment\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="running-the-component"\u003eRunning the component\u003c/h2\u003e\n\u003cp\u003eYou can run a simple ‘Hello World’ component by running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eURL=http://www.data-intuitive.com/viash_docs/examples/hello_world_r/config.vsh.yaml\nviash run $URL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello world! \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery component accepts –help as an option, which outputs a description\nof the component and a list of accepted options. Run the command below\nto see the help for the ‘Hello World’ component:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eA very simple \'Hello world\' component.\n\nOptions:\n    string1 string2 ...\n        type: string, multiple values allowed\n\n    --greeter=string\n        type: string, default: Hello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the ‘Hello World’ component accepts several string\narguments and a \u003ccode\u003e--greeter\u003c/code\u003e option. Run the command below and replace\nNAME with your name to see what happens:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run $URL -- NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="how-does-the-hello-world-component-work"\u003eHow Does the hello world component work?\u003c/h2\u003e\n\u003cp\u003eWhen you call ‘viash run’, viash parses the\n\u003ca href="http://www.data-intuitive.com/viash_docs/examples/hello_world_r/config.vsh.yaml"\u003e\u003ccode\u003econfig.vsh.yaml\u003c/code\u003e\u003c/a\u003e\nfile, which is a meta description of the component written in the yaml\nserialization language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003efunctionality:\n  name: hello_world_r\n  description: A very simple \'Hello world\' component.\n  arguments:\n  - type: string\n    name: input\n    multiple: true\n    multiple_sep: \u0026quot; \u0026quot;\n  - type: string\n    name: --greeter\n    default: \u0026quot;Hello world!\u0026quot;\n  resources:\n  - type: r_script\n    path: script.R\n  tests:\n  - type: r_script\n    path: test.R\nplatforms:\n  - type: native\n  - type: docker\n    image: \u0026quot;rocker/tidyverse:4.0.4\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis config file describes the behavior of a script and the platform it\nruns on. Every config file consists of two main sections:\n\u003cstrong\u003efunctionality\u003c/strong\u003e and \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id="functionality"\u003eFunctionality\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003efunctionality\u003c/strong\u003e attribute describes the core functionality of the\ncomponent, such as its inputs, outputs, arguments, and extra resources.\nThe ‘Hello World’ component accepts two arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003einput\u003c/strong\u003e that accepts multiple space-separated\narguments.\u003c/li\u003e\n\u003cli\u003eA second \u003ccode\u003estring\u003c/code\u003e named \u003cstrong\u003e–greeter\u003c/strong\u003e which defaults to “Hello\nworld!”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese arguments are passed on to the \u003cstrong\u003eresources\u003c/strong\u003e. In this case,\nthere’s a single reference to a file named\n\u003ca href="http://www.data-intuitive.com/viash_docs/examples/hello_world_r/script.r"\u003e\u003ccode\u003escript.r\u003c/code\u003e\u003c/a\u003e.\nThis file is the ‘brain’ of the component, it’s small R script which\nprints out two environment values: \u003ccode\u003epar_input\u003c/code\u003e and \u003ccode\u003epar_greeter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-r"\u003e## VIASH START\npar \u0026lt;- list(\n  input = \u0026quot;I am debug!\u0026quot;,\n  greeter = \u0026quot;Hello world!\u0026quot;\n)\n\n## VIASH END\n\ncat(par$greeter, \u0026quot; \u0026quot;, paste(par$input, collapse = \u0026quot; \u0026quot;), \u0026quot;\\n\u0026quot;, sep = \u0026quot;\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny variables defined in the config file will be automatically generated\nbetween the \u003ccode\u003e## VIASH START\u003c/code\u003e and \u003ccode\u003e## VIASH END\u003c/code\u003e lines. You can add\npre-defined values here for debugging purposes by adding the variables\nin a \u003ccode\u003epar\u003c/code\u003e list. Their values will automatically be replaced at runtime\nwith parameter values from the CLI.\u003c/p\u003e\n\u003cp\u003eFinally, there’s a \u003cstrong\u003etests\u003c/strong\u003e section to put your test scripts. It’s a\ngood practice to write tests and run these every time you update your\ncomponent and/or the resources. You can read more about writing and\nrunning viash tests \u003ca href="http://www.data-intuitive.com/viash_docs/good_practices/testing/"\u003eon the Testing\npage\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id="platforms"\u003ePlatforms\u003c/h3\u003e\n\u003cp\u003eThe \u003cstrong\u003eplatforms\u003c/strong\u003e attribute specifies the requirements to execute the\ncomponent on one or more platforms:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplatforms:\n  - type: native\n  - type: docker\n    image: bash:4.0\n  - type: docker\n    id: alpine\n    image: alpine\n    setup:\n      - type: apk\n        packages: [ bash ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe list of currently supported platforms are\n\u003ca href="/config/platform-native/"\u003eNative\u003c/a\u003e, \u003ca href="/config/platform-docker/"\u003eDocker\u003c/a\u003e,\nand \u003ca href="/config/platform-nextflow/"\u003eNextflow\u003c/a\u003e. If no platforms are\nspecified, a native platform with no system requirements is assumed.\u003c/p\u003e\n\u003cp\u003eYou can specify what platform a component should run on by passing the\n\u003ccode\u003e-p\u003c/code\u003e or \u003ccode\u003e--platform\u003c/code\u003e option. For example, try running the following\ncommand:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash run -p native $URL -- Mike. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, Mike.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe results should be exactly the same as viash automatically picks the\nfirst platform when you don’t pass the platform option, in this case\nthat’s \u003ccode\u003enative\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id="exporting-a-component-as-an-executable"\u003eExporting a component as an executable\u003c/h2\u003e\n\u003cp\u003eComponents can be exported to executables, making it easy to share\nscripted functionality without the need to have viash installed on the\ntarget system.\u003cbr\u003e\nRun the following command to make viash parse the config file and export\nthe result to an executable called \u003cstrong\u003ehello_world_r\u003c/strong\u003e in a (new) folder\nnamed \u003cstrong\u003emy_hello_world\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003eviash build $URL -o my_hello_world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can now run the following command to run the generated executable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-bash"\u003emy_hello_world/hello_world_r NAME. --greeter=\u0026quot;Hello there,\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHello there, NAME.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id="whats-next"\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics of how viash works, take a look at\nhow to write your own component:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/creating_components/bash"\u003eCreating a Bash component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/python"\u003eCreating a Python component\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="/creating_components/r"\u003eCreating an R component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:6,href:"/docs/prologue/",title:"xx",description:"yy",content:"\u003cp\u003eContent\u003c/p\u003e\n"},{id:7,href:"/docs/",title:"Docs",description:"viash documentation",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()